[{"categories":["Video"],"content":"《再见，郑大》 郑州大学2020官方毕业视频","date":"2020-06-28","objectID":"/zzu01/","tags":["ZZU"],"title":"《再见，郑大》 郑州大学2020官方毕业视频","uri":"/zzu01/"},{"categories":["Video"],"content":" 视频信息 2020年郑州大学官方毕业视频《再见，郑大》 郑州大学党委学生工作部、学生处，郑州大学信息工程学院，联合制作 ","date":"2020-06-28","objectID":"/zzu01/:0:0","tags":["ZZU"],"title":"《再见，郑大》 郑州大学2020官方毕业视频","uri":"/zzu01/"},{"categories":["Documentation"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-11","objectID":"/extended-shortcodes/","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-11","objectID":"/extended-shortcodes/:0:0","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"1 style 注意 Hugo extended 版本对于 style shortcode 是必需的. style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2020-03-11","objectID":"/extended-shortcodes/:1:0","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"2 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage ","date":"2020-03-11","objectID":"/extended-shortcodes/:2:0","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. 一个 image 示例: {{\u003c image src=\"lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"lighthouse-small.jpg\" src_l=\"lighthouse-large.jpg\" \u003e}} 呈现的输出效果如下: Lighthouse (image)\" Lighthouse (image) ","date":"2020-03-11","objectID":"/extended-shortcodes/:3:0","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"4 admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2020-03-11","objectID":"/extended-shortcodes/:4:0","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"5 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-11","objectID":"/extended-shortcodes/:5:0","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"5.1 流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:5:1","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"5.2 时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:5:2","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"5.3 甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:5:3","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"5.4 类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:5:4","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"5.5 状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:5:5","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"5.6 Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:5:6","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"5.7 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:5:7","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"6 echarts ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}}title:text:折线统计图top:2%left:centertooltip:trigger:axislegend:data:- 邮件营销- 联盟广告- 视频广告- 直接访问- 搜索引擎top:10%grid:left:5%right:5%bottom:5%top:20%containLabel:truetoolbox:feature:saveAsImage:title:保存为图片xAxis:type:categoryboundaryGap:falsedata:- 周一- 周二- 周三- 周四- 周五- 周六- 周日yAxis:type:valueseries:- name:邮件营销type:linestack:总量data:- 120- 132- 101- 134- 90- 230- 210- name:联盟广告type:linestack:总量data:- 220- 182- 191- 234- 290- 330- 310- name:视频广告type:linestack:总量data:- 150- 232- 201- 154- 190- 330- 410- name:直接访问type:linestack:总量data:- 320- 332- 301- 334- 390- 330- 320- name:搜索引擎type:linestack:总量data:- 820- 932- 901- 934- 1290- 1330- 1320{{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2020-03-11","objectID":"/extended-shortcodes/:6:0","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"7 mapbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:7:0","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"8 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-11","objectID":"/extended-shortcodes/:8:0","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"8.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"Wavelength.jpg\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:8:1","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"8.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:8:2","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"8.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:8:3","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"8.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-03-11","objectID":"/extended-shortcodes/:8:4","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"9 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1zt4y197cf 一个 bilibili 示例: {{\u003c bilibili BV1zt4y197cf \u003e}} 或者 {{\u003c bilibili id=BV1zt4y197cf \u003e}} 呈现的输出效果如下: 如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1zt4y197cf?p=1 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1zt4y197cf 1 \u003e}} 或者 {{\u003c bilibili id=BV1zt4y197cf p=1 \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:9:0","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"10 typeit typeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-11","objectID":"/extended-shortcodes/:10:0","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"10.1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:10:1","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"10.2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:10:2","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"10.3 分组内容 默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/extended-shortcodes/:10:3","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Documentation"],"content":"11 script script shortcode 用来在你的文章中插入  Javascript 脚本. 注意 脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库. 一个 script 示例: {{\u003c script \u003e}} console.log('Hello LoveIt!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2020-03-11","objectID":"/extended-shortcodes/:11:0","tags":["Shortcodes"],"title":"扩展 Shortcodes","uri":"/extended-shortcodes/"},{"categories":["Video"],"content":"【挑战杯】新型医用敷料参赛视频","date":"2019-09-22","objectID":"/cc02/","tags":["ChallengeCup"],"title":"【挑战杯】新型医用敷料参赛视频","uri":"/cc02/"},{"categories":["Video"],"content":" 视频信息 【挑战杯】新型医用敷料参赛视频。 制作软件：AE Pr 视频制作：杨勃隆 ","date":"2019-09-22","objectID":"/cc02/:0:0","tags":["ChallengeCup"],"title":"【挑战杯】新型医用敷料参赛视频","uri":"/cc02/"},{"categories":["Video"],"content":"【挑战杯】新型绿色墙砖参赛视频","date":"2019-09-05","objectID":"/cc03/","tags":["ChallengeCup"],"title":"【挑战杯】新型绿色墙砖参赛视频","uri":"/cc03/"},{"categories":["Video"],"content":" 视频信息 【挑战杯】新型绿色墙砖参赛视频。 制作软件：AE Pr 视频制作：杨勃隆 ","date":"2019-09-05","objectID":"/cc03/:0:0","tags":["ChallengeCup"],"title":"【挑战杯】新型绿色墙砖参赛视频","uri":"/cc03/"},{"categories":["Video"],"content":"【挑战杯】机器人工作室宣传视频","date":"2019-09-05","objectID":"/cc04/","tags":["ChallengeCup"],"title":"【挑战杯】机器人工作室宣传视频","uri":"/cc04/"},{"categories":["Video"],"content":" 视频信息 【挑战杯】机器人工作室宣传视频。 制作软件：AE Pr 视频制作：杨勃隆 ","date":"2019-09-05","objectID":"/cc04/:0:0","tags":["ChallengeCup"],"title":"【挑战杯】机器人工作室宣传视频","uri":"/cc04/"},{"categories":["Video"],"content":"【挑战杯】口袋医学参赛视频","date":"2019-02-12","objectID":"/cc01/","tags":["ChallengeCup"],"title":"【挑战杯】口袋医学参赛视频","uri":"/cc01/"},{"categories":["Video"],"content":" 视频信息 【挑战杯】口袋医学参赛视频，解放大脑的断层解剖数据库。 制作软件：AE Pr 视频制作：杨勃隆 ","date":"2019-02-12","objectID":"/cc01/:0:0","tags":["ChallengeCup"],"title":"【挑战杯】口袋医学参赛视频","uri":"/cc01/"},{"categories":["Video"],"content":"《致2020即将毕业的研究生》郑州大学2020研究生官方毕业视频","date":"2020-06-28","objectID":"/zzu02/","tags":["ZZU"],"title":"《致2020即将毕业的研究生》郑州大学2020研究生官方毕业视频","uri":"/zzu02/"},{"categories":["Video"],"content":" 视频信息 2020年郑州大学研究生毕业视频《致2020即将毕业的研究生》 郑州大学研究生院、党委研究生工作部出品 菠萝视频工作室制作 ","date":"2020-06-28","objectID":"/zzu02/:0:0","tags":["ZZU"],"title":"《致2020即将毕业的研究生》郑州大学2020研究生官方毕业视频","uri":"/zzu02/"},{"categories":["Documentation"],"content":"Emoji的用法指南.","date":"2020-03-11","objectID":"/emoji-support/","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Documentation"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用 内联 Shortcodes. 要全局使用 emoji, 需要在你的网站 配置 中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 ","date":"2020-03-11","objectID":"/emoji-support/:0:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Documentation"],"content":"Emoji 符号清单 Emoji 符号清单是 emoji 代码的非常有用的参考. ","date":"2020-03-11","objectID":"/emoji-support/:1:0","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Documentation"],"content":"表情与情感 笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent 爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes 吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face 带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking 中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face 困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping 不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face 戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face 戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face 担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face 否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones 特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot 猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat 猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil 情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2020-03-11","objectID":"/emoji-support/:1:1","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Documentation"],"content":"人与身体 张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute 部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand 一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up 握紧的手势 图标 代码 图标 代码 👍 👍 thumbsup 👎 👎 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right 两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray 握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie 身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips 人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman 身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇‍♂️ bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging 人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman 幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus 人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men 体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling 休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed 家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 👩‍❤️‍👨 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍","date":"2020-03-11","objectID":"/emoji-support/:1:2","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Documentation"],"content":"动物与自然 哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints 鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl 两栖动物 icon code icon code 🐸 frog 爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon 海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell 虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion 花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip 其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2020-03-11","objectID":"/emoji-support/:1:3","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Documentation"],"content":"食物与饮料 水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato 蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut 快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn 亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango 海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid 甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot 饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass 餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2020-03-11","objectID":"/emoji-support/:1:4","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Documentation"],"content":"旅游与地理 地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan 地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park 建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty 宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba 其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent 陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction 水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship 空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket 旅馆 icon code icon code 🛎️ bellhop_bell 时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2020-03-11","objectID":"/emoji-support/:1:5","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Documentation"],"content":"活动 事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket 奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal 体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski 游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards 艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2020-03-11","objectID":"/emoji-support/:1:6","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Documentation"],"content":"物品 服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem 声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell 音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio 乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum 电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax 电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd 灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern 书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label 钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart 邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box 书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil 办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket 锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key 工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains 科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite 医疗 图标 代码 图标 代码 💉 syringe 💊 pill 生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart 其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2020-03-11","objectID":"/emoji-support/:1:7","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Documentation"],"content":"符号 交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage 警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard 箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top 宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star 生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus 影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off 数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign 标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash 货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign 按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten 字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button 其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2020-03-11","objectID":"/emoji-support/:1:8","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Documentation"],"content":"旗帜 常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag 国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2020-03-11","objectID":"/emoji-support/:1:9","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Documentation"],"content":"GitHub 自定义 Emoji 图标 代码 图标 代码 ⚛ atom :basecamp: basecamp :basecampy: basecampy :bowtie: bowtie :electron: electron :feelsgood: feelsgood :finnadie: finnadie :goberserk: goberserk :godmode: godmode :hurtrealbad: hurtrealbad :neckbeard: neckbeard :octocat: octocat :rage1: rage1 :rage2: rage2 :rage3: rage3 :rage4: rage4 :shipit: shipit squirrel :suspect: suspect :trollface: trollface .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2020-03-11","objectID":"/emoji-support/:1:10","tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["Video"],"content":"【郑州大学】2018郑州大学研究生毕业宣传片","date":"2020-02-12","objectID":"/zzu04/","tags":["ZZU"],"title":"【郑州大学】2018郑州大学研究生毕业宣传片","uri":"/zzu04/"},{"categories":["Video"],"content":" 视频信息 【郑州大学】2018郑州大学研究生毕业宣传片 郑州大学研究生院、党委研究生工作部出品 菠萝视频工作室制作 ","date":"2020-02-12","objectID":"/zzu04/:0:0","tags":["ZZU"],"title":"【郑州大学】2018郑州大学研究生毕业宣传片","uri":"/zzu04/"},{"categories":["Video"],"content":"【郑州大学】2019级新生开学典礼正片","date":"2020-02-12","objectID":"/zzu05/","tags":["ZZU"],"title":"【郑州大学】2019级新生开学典礼正片","uri":"/zzu05/"},{"categories":["Video"],"content":" 视频信息 【郑州大学】2019级新生开学典礼正片 郑州大学党委学生工作部、学生处，郑州大学信息工程学院出品 菠萝视频工作室制作 ","date":"2020-02-12","objectID":"/zzu05/:0:0","tags":["ZZU"],"title":"【郑州大学】2019级新生开学典礼正片","uri":"/zzu05/"},{"categories":["Video"],"content":"【郑州大学】2019郑州大学毕业视频","date":"2019-09-28","objectID":"/zzu03/","tags":["ZZU"],"title":"【郑州大学】2019郑州大学毕业视频","uri":"/zzu03/"},{"categories":["Video"],"content":" 视频信息 【郑州大学】2019郑州大学毕业视频 郑州大学研究生院、党委研究生工作部出品 菠萝视频工作室制作 ","date":"2019-09-28","objectID":"/zzu03/:0:0","tags":["ZZU"],"title":"【郑州大学】2019郑州大学毕业视频","uri":"/zzu03/"},{"categories":["Documentation"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2020-03-11","objectID":"/basic-markdown-syntax/","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"这篇文章提供了博客中使用的基本 Markdown 语法示例. 注意 这篇文章借鉴了一篇很棒的来自 Grav的文章 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧  将此页保存为书签，以备将来参考! ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:0:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:1:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:2:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:3:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:4:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:5:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"6 强调 ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:6:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:6:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:6:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:6:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:6:4","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:7:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"8 列表 ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:8:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:8:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:8:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:8:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"9 代码 ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:9:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"行内代码 用\u003ccode\u003e \u003c/code\u003e 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:9:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:9:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:9:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:9:4","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:10:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"11 链接 ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:11:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:11:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:11:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:11:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:12:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Documentation"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \" The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \" The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧 LoveIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2020-03-11","objectID":"/basic-markdown-syntax/:13:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Java"],"content":"[Java核心技术] Java网络编程","date":"2022-02-24","objectID":"/java12/","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"Java 核心技术读书笔记——Java网络编程 ","date":"2022-02-24","objectID":"/java12/:0:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"1 Java UDP编程 笔记 TCP：Transmission Control Protocol 传输控制协议，面向连接的协议 两台机器的可靠无差错的数据传输 双向字节流传递 UDP：User Datagram Protocol 用户数据报协议，面向无连接协议 不保证可靠的数据传输 速度快，也可以在较差网络下使用 计算机通讯：数据从一个IP的 port 出发（发送方），运输到 另外一个IP的 port（接收方） UDP：无连接无状态的通讯协议， 发送方发送消息，如果接收方刚好在目的地，则可以接受。如果 不在，那这个消息就丢失了 发送方也无法得知是否发送成功 UDP 的好处就是简单，节省，经济 ","date":"2022-02-24","objectID":"/java12/:1:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"1.1 DatagramSocket 通讯的数据管道 send 和 receive 方法 （可选，多网卡）绑定一个 IP 和 Port ","date":"2022-02-24","objectID":"/java12/:1:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"1.2 DatagramPacket 集装箱：封装数据 地址标签：目的地 IP+Port ","date":"2022-02-24","objectID":"/java12/:1:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"1.3 实例 接收消息 import java.net.*; public class UdpRecv { public static void main(String[] args) throws Exception { DatagramSocket ds=new DatagramSocket(3000); byte [] buf=new byte[1024]; DatagramPacket dp=new DatagramPacket(buf,1024); System.out.println(\"UdpRecv: 我在等待信息\"); ds.receive(dp); System.out.println(\"UdpRecv: 我接收到信息\"); String strRecv=new String(dp.getData(),0,dp.getLength()) + \" from \" + dp.getAddress().getHostAddress()+\":\"+dp.getPort(); System.out.println(strRecv); Thread.sleep(1000); System.out.println(\"UdpRecv: 我要发送信息\"); String str=\"hello world 222\"; DatagramPacket dp2=new DatagramPacket(str.getBytes(),str.length(), InetAddress.getByName(\"127.0.0.1\"),dp.getPort()); ds.send(dp2); System.out.println(\"UdpRecv: 我发送信息结束\"); ds.close(); } } /** * * UdpRecv: 我在等待信息 * UdpRecv: 我接收到信息 * hello world from 127.0.0.1:61933 * UdpRecv: 我要发送信息 * UdpRecv: 我发送信息结束 * */ 发送消息 import java.net.*; public class UdpSend { public static void main(String [] args) throws Exception { DatagramSocket ds=new DatagramSocket(); String str=\"hello world\"; DatagramPacket dp=new DatagramPacket(str.getBytes(),str.length(), InetAddress.getByName(\"127.0.0.1\"),3000); System.out.println(\"UdpSend: 我要发送信息\"); ds.send(dp); System.out.println(\"UdpSend: 我发送信息结束\"); Thread.sleep(1000); byte [] buf=new byte[1024]; DatagramPacket dp2=new DatagramPacket(buf,1024); System.out.println(\"UdpSend: 我在等待信息\"); ds.receive(dp2); System.out.println(\"UdpSend: 我接收到信息\"); String str2=new String(dp2.getData(),0,dp2.getLength()) + \" from \" + dp2.getAddress().getHostAddress()+\":\"+dp2.getPort(); System.out.println(str2); ds.close(); } } /** * * * UdpSend: 我要发送信息 * UdpSend: 我发送信息结束 * UdpSend: 我在等待信息 * UdpSend: 我接收到信息 * hello world 222 from 127.0.0.1:3000 * */ ","date":"2022-02-24","objectID":"/java12/:1:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"2 TCP 编程 TCP协议：有链接、保证可靠的无误差通讯 ① 服务器：创建一个ServerSocket，等待连接 ② 客户机：创建一个Socket，连接到服务器 ③ 服务器：ServerSocket接收到连接，创建一个Socket和客户的Socket建立专线连接，后续服务器和客户机的对话(这一对Socket)会在一个单独的线程（服务器端）上运行 ④ 服务器的ServerSocket继续等待连接，返回 ① TCP协议TCP 网络编程 \" TCP协议 ","date":"2022-02-24","objectID":"/java12/:2:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"2.1 ServerSocket: 服务器码头 需要绑定port 如果有多块网卡，需要绑定一个IP地址 ","date":"2022-02-24","objectID":"/java12/:2:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"2.2 Socket: 运输通道 客户端需要绑定服务器的地址和Port 客户端往Socket输入流写入数据，送到服务端 客户端从Socket输出流取服务器端过来的数据 服务端反之亦然 SocketSocket \" Socket ","date":"2022-02-24","objectID":"/java12/:2:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"2.3 相关规则 服务端等待响应时，处于阻塞状态 服务端可以同时响应多个客户端 服务端每接受一个客户端，就启动一个独立的线程与之对 应 客户端或者服务端都可以选择关闭这对Socket的通道 实例 服务端先启动，且一直保留 import java.net.*; import java.io.*; public class TcpServer { public static void main(String [] args) { try { ServerSocket ss=new ServerSocket(8001); //驻守在8001端口 Socket s=ss.accept(); //阻塞，等到有客户端连接上来 System.out.println(\"welcome to the java world\"); InputStream ips=s.getInputStream(); //有人连上来，打开输入流 OutputStream ops=s.getOutputStream(); //打开输出流 //同一个通道，服务端的输出流就是客户端的输入流；服务端的输入流就是客户端的输出流 ops.write(\"Hello, Client!\".getBytes()); //输出一句话给客户端 BufferedReader br = new BufferedReader(new InputStreamReader(ips)); //从客户端读取一句话 System.out.println(\"Client said: \" + br.readLine()); ips.close(); ops.close(); s.close(); ss.close(); } catch(Exception e) { e.printStackTrace(); } } } /** * * * 输入：Hello Server * I want to send: Hello Server * Server said: Hello, Client! * * */ 客户端后启动，可以先退出 import java.net.*; import java.io.*; public class TcpClient { public static void main(String[] args) { try { Socket s = new Socket(InetAddress.getByName(\"127.0.0.1\"), 8001); //需要服务端先开启 //同一个通道，服务端的输出流就是客户端的输入流；服务端的输入流就是客户端的输出流 InputStream ips = s.getInputStream(); //开启通道的输入流 BufferedReader brNet = new BufferedReader(new InputStreamReader(ips)); OutputStream ops = s.getOutputStream(); //开启通道的输出流 DataOutputStream dos = new DataOutputStream(ops); BufferedReader brKey = new BufferedReader(new InputStreamReader(System.in)); while (true) { String strWord = brKey.readLine(); if (strWord.equalsIgnoreCase(\"quit\")) { break; } else { System.out.println(\"I want to send: \" + strWord); dos.writeBytes(strWord + System.getProperty(\"line.separator\")); System.out.println(\"Server said: \" + brNet.readLine()); } } dos.close(); brNet.close(); brKey.close(); s.close(); } catch (Exception e) { e.printStackTrace(); } } } /** * * welcome to the java world * Client said: Hello Server * * */ ","date":"2022-02-24","objectID":"/java12/:2:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"3 Java HTTP编程 HTTP HTTP 超文本传输协议(HyperText Transfer Protocol) 用于从WWW（World Wide Web）服务器传输超文本到本地浏览 器的传输协议 1989年蒂姆•伯纳斯•李（Tim Berners Lee）提出了一种能让远隔两 地的研究者们共享知识的设想 借助多文档之间相互关联形成的超文本 （HyperText），连成可 相互参阅的 WWW 1990年问世，1997年发布版本1.1，2015年发布版本2.0 资源文件采用HTML编写，以URL形式对外提供 ","date":"2022-02-24","objectID":"/java12/:3:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"3.1 HTTP访问方式 GET：从服务器获取资源到客户端 POST：从客户端向服务器发送数据 PUT：上传文件 DELETE：删除文件 HEAD：报文头部 OPTIONS：询问支持的方法 TRACE：追踪路径 CONNECT：用隧道协议连接代理 ","date":"2022-02-24","objectID":"/java12/:3:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"Java HTTP编程(java.net包) 支持模拟成浏览器的方式去访问网页 URL , Uniform Resource Locator，代表一个资源 URLConnection 获取资源的连接器 根据URL的openConnection()方法获得URLConnection connect方法，建立和资源的联系通道 getInputStream方法，获取资源的内容 GET实例 import java.io.*; import java.net.*; import java.util.*; public class URLConnectionGetTest { public static void main(String[] args) { try { String urlName = \"http://www.baidu.com\"; URL url = new URL(urlName); URLConnection connection = url.openConnection(); // 建立连接通道 connection.connect(); // 打印http的头部信息 Map\u003cString, List\u003cString\u003e\u003e headers = connection.getHeaderFields(); for (Map.Entry\u003cString, List\u003cString\u003e\u003e entry : headers.entrySet()) { String key = entry.getKey(); for (String value : entry.getValue()) System.out.println(key + \": \" + value); } // 输出将要收到的内容属性信息 System.out.println(\"----------\"); System.out.println(\"getContentType: \" + connection.getContentType()); System.out.println(\"getContentLength: \" + connection.getContentLength()); System.out.println(\"getContentEncoding: \" + connection.getContentEncoding()); System.out.println(\"getDate: \" + connection.getDate()); System.out.println(\"getExpiration: \" + connection.getExpiration()); System.out.println(\"getLastModifed: \" + connection.getLastModified()); System.out.println(\"----------\"); BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\")); // 输出收到的内容 String line = \"\"; while((line=br.readLine()) != null) { System.out.println(line); } br.close(); } catch (IOException e) { e.printStackTrace(); } } } /** * * null: HTTP/1.1 200 OK * Server: bfe * Content-Length: 2381 * Date: Tue, 01 Mar 2022 16:27:49 GMT * Content-Type: text/html * ---------- * getContentType: text/html * getContentLength: 2381 * getContentEncoding: null * getDate: 1646152069000 * getExpiration: 0 * getLastModifed: 0 * ---------- * \u003c!DOCTYPE html\u003e * ...... * * * */ POST实例 import java.io.*; import java.net.*; import java.nio.file.*; import java.util.*; public class URLConnectionPostTest { public static void main(String[] args) throws IOException { String urlString = \"https://tools.usps.com/go/ZipLookupAction.action\"; Object userAgent = \"HTTPie/0.9.2\"; Object redirects = \"1\"; CookieHandler.setDefault(new CookieManager(null, CookiePolicy.ACCEPT_ALL)); Map\u003cString, String\u003e params = new HashMap\u003cString, String\u003e(); params.put(\"tAddress\", \"1 Market Street\"); params.put(\"tCity\", \"San Francisco\"); params.put(\"sState\", \"CA\"); String result = doPost(new URL(urlString), params, userAgent == null ? null : userAgent.toString(), redirects == null ? -1 : Integer.parseInt(redirects.toString())); System.out.println(result); } public static String doPost(URL url, Map\u003cString, String\u003e nameValuePairs, String userAgent, int redirects) throws IOException { HttpURLConnection connection = (HttpURLConnection) url.openConnection(); if (userAgent != null) connection.setRequestProperty(\"User-Agent\", userAgent); if (redirects \u003e= 0) connection.setInstanceFollowRedirects(false); connection.setDoOutput(true); //输出请求的参数 try (PrintWriter out = new PrintWriter(connection.getOutputStream())) { boolean first = true; for (Map.Entry\u003cString, String\u003e pair : nameValuePairs.entrySet()) { //参数必须这样拼接 a=1\u0026b=2\u0026c=3 if (first) { first = false; } else { out.print('\u0026'); } String name = pair.getKey(); String value = pair.getValue(); out.print(name); out.print('='); out.print(URLEncoder.encode(value, \"UTF-8\")); } } String encoding = connection.getContentEncoding(); if (encoding == null) { encoding = \"UTF-8\"; } if (redirects \u003e 0) { int responseCode = connection.getResponseCode(); System.out.println(\"responseCode: \" + responseCode); if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_SEE_OTHER) { String location = connection.getHeaderField(\"Location\"); if (location != null) { URL base = connection.getURL(); connection.disconnect(); return doPost(new URL(base, location), nameValuePairs, userAgent, redirects - 1); } } } else if (redirects == 0) { t","date":"2022-02-24","objectID":"/java12/:3:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"4 HttpClient HttpClient HttpClient 包含一下两个包： JDK HTTP Client （JDK自带，从9开始) Apache HttpComponents的HttpClient (Apache出品) ","date":"2022-02-24","objectID":"/java12/:4:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"4.1 JDK HttpClient JDK 9 新增，JDK10更新，JDK11正式发布 收录在java.net.http包 取代URLConnection 支持HTTP/1.1和HTTP/2 实现大部分HTTP方法 主要类 HttpClient HttpRequest HttpResponse JDK HttpClient GET 实例 import java.io.IOException; import java.net.URI; import java.net.URLEncoder; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.nio.charset.Charset; /* 获取百度首页的源码 */ public class JDKHttpClientGetTest { public static void main(String[] args) throws IOException, InterruptedException { doGet(); } public static void doGet() { try{ HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder(URI.create(\"http://www.baidu.com\")).build(); HttpResponse response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body()); } catch(Exception e) { e.printStackTrace(); } } } JDK HttpClient POST 实例 import java.io.IOException; import java.net.URI; import java.net.URLEncoder; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; /* */ public class JDKHttpClientPostTest { public static void main(String[] args) throws IOException, InterruptedException { doPost(); } public static void doPost() { try { HttpClient client = HttpClient.newBuilder().build(); HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(\"https://tools.usps.com/go/ZipLookupAction.action\")) //.header(\"Content-Type\",\"application/x-www-form-urlencoded\") .header(\"User-Agent\", \"HTTPie/0.9.2\") .header(\"Content-Type\",\"application/x-www-form-urlencoded;charset=utf-8\") //.method(\"POST\", HttpRequest.BodyPublishers.ofString(\"tAddress=1 Market Street\u0026tCity=San Francisco\u0026sState=CA\")) //.version(Version.HTTP_1_1) .POST(HttpRequest.BodyPublishers.ofString(\"tAddress=\" + URLEncoder.encode(\"1 Market Street\", \"UTF-8\") + \"\u0026tCity=\" + URLEncoder.encode(\"San Francisco\", \"UTF-8\") + \"\u0026sState=CA\")) //.POST(HttpRequest.BodyPublishers.ofString(\"tAddress=\" + URLEncoder.encode(\"1 Market Street\", \"UTF-8\") + \"\u0026tCity=\" + URLEncoder.encode(\"San Francisco\", \"UTF-8\") + \"\u0026sState=CA\")) .build(); HttpResponse response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.statusCode()); System.out.println(response.headers()); System.out.println(response.body().toString()); } catch(Exception e) { e.printStackTrace(); } } } ","date":"2022-02-24","objectID":"/java12/:4:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"4.2 HttpComponents hc.apache.org, Apache出品 从HttpClient进化而来 是一个集成的Java HTTP工具包 实现所有HTTP方法：get/post/put/delete 支持自动转向 支持https协议 支持代理服务器等 HttpComponents GET 实例 import java.io.IOException; import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.ResponseHandler; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.methods.HttpGet; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.util.EntityUtils; public class HttpComponentsGetTest { public final static void main(String[] args) throws Exception { CloseableHttpClient httpClient = HttpClients.createDefault(); RequestConfig requestConfig = RequestConfig.custom() .setConnectTimeout(5000) //设置连接超时时间 .setConnectionRequestTimeout(5000) // 设置请求超时时间 .setSocketTimeout(5000) .setRedirectsEnabled(true)//默认允许自动重定向 .build(); HttpGet httpGet = new HttpGet(\"http://www.baidu.com\"); httpGet.setConfig(requestConfig); String srtResult = \"\"; try { HttpResponse httpResponse = httpClient.execute(httpGet); if(httpResponse.getStatusLine().getStatusCode() == 200){ srtResult = EntityUtils.toString(httpResponse.getEntity(), \"UTF-8\");//获得返回的结果 System.out.println(srtResult); }else { //异常处理 } } catch (IOException e) { e.printStackTrace(); }finally { try { httpClient.close(); } catch (IOException e) { e.printStackTrace(); } } } } HttpComponents POST 实例 import java.io.IOException; import java.net.URLEncoder; import java.util.ArrayList; import java.util.List; import org.apache.http.HttpResponse; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.HttpPost; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClientBuilder; import org.apache.http.impl.client.LaxRedirectStrategy; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils; public class HttpComponentsPostTest { public final static void main(String[] args) throws Exception { //获取可关闭的 httpCilent //CloseableHttpClient httpClient = HttpClients.createDefault(); CloseableHttpClient httpClient = HttpClientBuilder.create().setRedirectStrategy(new LaxRedirectStrategy()).build(); //配置超时时间 RequestConfig requestConfig = RequestConfig.custom(). setConnectTimeout(10000).setConnectionRequestTimeout(10000) .setSocketTimeout(10000).setRedirectsEnabled(false).build(); HttpPost httpPost = new HttpPost(\"https://tools.usps.com/go/ZipLookupAction.action\"); //设置超时时间 httpPost.setConfig(requestConfig); //装配post请求参数 List\u003cBasicNameValuePair\u003e list = new ArrayList\u003cBasicNameValuePair\u003e(); list.add(new BasicNameValuePair(\"tAddress\", URLEncoder.encode(\"1 Market Street\", \"UTF-8\"))); //请求参数 list.add(new BasicNameValuePair(\"tCity\", URLEncoder.encode(\"San Francisco\", \"UTF-8\"))); //请求参数 list.add(new BasicNameValuePair(\"sState\", \"CA\")); //请求参数 try { UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list,\"UTF-8\"); //设置post求情参数 httpPost.setEntity(entity); httpPost.setHeader(\"User-Agent\", \"HTTPie/0.9.2\"); //httpPost.setHeader(\"Content-Type\",\"application/form-data\"); HttpResponse httpResponse = httpClient.execute(httpPost); String strResult = \"\"; if(httpResponse != null){ System.out.println(httpResponse.getStatusLine().getStatusCode()); if (httpResponse.getStatusLine().getStatusCode() == 200) { strResult = EntityUtils.toString(httpResponse.getEntity()); } else { strResult = \"Error Response: \" + httpResponse.getStatusLine().toString(); } }else{ } System.out.println(strResult); } catch (Exception e) { e.printStackTrace(); }finally { try { if(httpClient != null){ httpClient.close(); //释放资源 } } catch (IOException e) { e.printStackTrace(); } } } } ","date":"2022-02-24","objectID":"/java12/:4:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"5 Java NIO 编程 传统的TCP和UDP通讯属于 Blocking I/O NIO（Non-Blocking I/O，非阻塞I/O，又名 New I/O）提供非阻塞通讯等方式，避免同步I/O通讯效率过低，一个线程可以管理多个连接，减少线程多的压力，不是真异步。 笔记 并发编程的同步：是指多个线程需要以一种同步的方式来访问某一个数据结构。这里同步的反义词是非同步的，即线程不安全的。 网络通讯的同步：是指客户端和服务端直接的通讯等待方式。这里的同步的反义词是异步，即无需等待另一端操作完成。 JDK 1.4引入，1.7升级 NIO 2.0 (包括了AIO) 主要在java.nio包中 主要类 Buffer 缓存区 Channel 通道 Selector 多路选择器 NIO 服务端-客户端通讯示意图NIO 服务端-客户端通讯示意图 \" NIO 服务端-客户端通讯示意图 ","date":"2022-02-24","objectID":"/java12/:5:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"5.1 Buffer 缓冲区 Buffer 缓冲区：一个可以读写的内存区域 ByteBuffer CharBuffer DoubleBuffer IntBuffer LongBuffer ShortBuffer 注意：StringBuffer 不是 Buffer缓冲区 四个主要属性： capacity 容量 position 读写位置 limit 界限 mark 标记，用于重复一个读/写操作 ","date":"2022-02-24","objectID":"/java12/:5:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"5.3 Channel 通道 全双工的，支持读/写(而**Stream流是单向的**) 支持异步读写 和Buffer配合，提高效率 ServerSocketChannel 服务器TCP Socket 接入通道，接收客户端 SocketChannel TCP Socket通道，可支持阻塞/非阻塞通讯 DatagramChannel UDP 通道 FileChannel 文件通道 ","date":"2022-02-24","objectID":"/java12/:5:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"5.4 Selector多路选择器 每隔一段时间，不断轮询注册在其上的Channel 如果有一个Channel有接入、读、写操作，就会被轮询出来 根据SelectionKey可以获取相应的Channel，进行后续IO操作 避免过多的线程 SelectionKey四种类型 OP_CONNECT OP_ACCEPT OP_READ OP_WRITE Selector多路选择器Selector多路选择器 \" Selector多路选择器 ","date":"2022-02-24","objectID":"/java12/:5:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"5.5 实例 NioServer import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.Selector; import java.nio.channels.ServerSocketChannel; import java.nio.channels.SocketChannel; import java.util.Iterator; import java.util.Set; public class NioServer { public static void main(String[] args) throws IOException { int port = 8001; Selector selector = null; ServerSocketChannel servChannel = null; try { selector = Selector.open(); servChannel = ServerSocketChannel.open(); servChannel.configureBlocking(false); servChannel.socket().bind(new InetSocketAddress(port), 1024); servChannel.register(selector, SelectionKey.OP_ACCEPT); System.out.println(\"服务器在8001端口守候\"); } catch (IOException e) { e.printStackTrace(); System.exit(1); } while(true) { try { selector.select(1000); Set\u003cSelectionKey\u003e selectedKeys = selector.selectedKeys(); Iterator\u003cSelectionKey\u003e it = selectedKeys.iterator(); SelectionKey key = null; while (it.hasNext()) { key = it.next(); it.remove(); try { handleInput(selector,key); } catch (Exception e) { if (key != null) { key.cancel(); if (key.channel() != null) key.channel().close(); } } } } catch(Exception ex) { ex.printStackTrace(); } try { Thread.sleep(500); } catch(Exception ex) { ex.printStackTrace(); } } } public static void handleInput(Selector selector, SelectionKey key) throws IOException { if (key.isValid()) { // 处理新接入的请求消息 if (key.isAcceptable()) { // Accept the new connection ServerSocketChannel ssc = (ServerSocketChannel) key.channel(); SocketChannel sc = ssc.accept(); sc.configureBlocking(false); // Add the new connection to the selector sc.register(selector, SelectionKey.OP_READ); } if (key.isReadable()) { // Read the data SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer readBuffer = ByteBuffer.allocate(1024); int readBytes = sc.read(readBuffer); if (readBytes \u003e 0) { readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String request = new String(bytes, \"UTF-8\"); //接收到的输入 System.out.println(\"client said: \" + request); String response = request + \" 666\"; doWrite(sc, response); } else if (readBytes \u003c 0) { // 对端链路关闭 key.cancel(); sc.close(); } else ; // 读到0字节，忽略 } } } public static void doWrite(SocketChannel channel, String response) throws IOException { if (response != null \u0026\u0026 response.trim().length() \u003e 0) { byte[] bytes = response.getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length); writeBuffer.put(bytes); writeBuffer.flip(); channel.write(writeBuffer); } } } /** * * * 服务器在8001端口守候 * client said: f3e638a0-6324-408f-b0d8-3c87ef93133b * client said: ce4c70b2-5031-4d1e-a996-a2a99dc8899e * client said: 03ea5cde-ec89-4d4b-940a-0de89c885064 * client said: ea56b109-82b9-4621-a223-7c3ef6103044 * client said: 3377c7a3-e2cd-462d-80cc-13084d9e9daf * * */ NioClient import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.Selector; import java.nio.channels.SocketChannel; import java.util.Iterator; import java.util.Set; import java.util.UUID; public class NioClient { public static void main(String[] args) { String host = \"127.0.0.1\"; int port = 8001; Selector selector = null; SocketChannel socketChannel = null; try { selector = Selector.open(); socketChannel = SocketChannel.open(); socketChannel.configureBlocking(false); // 非阻塞 // 如果直接连接成功，则注册到多路复用器上，发送请求消息，读应答 if (socketChannel.connect(new InetSocketAddress(host, port))) { socketChannel.register(selector, SelectionKey.OP_READ); doWrite(socketChannel); } else { socketChannel.register(selector, SelectionKey.OP_CONNECT); } } catch (IOException e) { e.printStackTrace(); System.exit(1); } while (true) { try { selector.select(1000); Set\u003cSelectionKey\u003e selectedKeys = selector.selectedKeys(); Iterator\u003cSelectionKey\u003e it = selectedKeys.iterator(); SelectionKey key = null; while (it.hasNext()) { key = it.next(); it.remove(); try { //处理每一","date":"2022-02-24","objectID":"/java12/:5:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"6 Java AIO 编程 Asynchronous I/O, 异步I/O JDK 1.7引入，主要在java.nio包中 异步I/O，采用回调方法进行处理读写操作 ","date":"2022-02-24","objectID":"/java12/:6:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"6.1 主要类 AsynchronousServerSocketChannel 服务器接受请求通道 bind 绑定在某一个端口 accept 接受客户端请求 AsynchronousSocketChannel Socket通讯通道 read 读数据 write 写数据 CompletionHandler 异步处理类 completed 操作完成后异步调用方法 failed 操作失败后异步调用方法 ","date":"2022-02-24","objectID":"/java12/:6:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"6.2 三种 I/O 的区别 BIO NIO AIO 阻塞方式 阻塞 非阻塞 非阻塞 同步方式 同步 同步 异步 编程难度 简单 较难 困难 客户机/服务器线程对比 1：1 N：1 N：1 性能 低 高 高 ","date":"2022-02-24","objectID":"/java12/:6:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"6.3 实例 AioServer import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.CharBuffer; import java.nio.channels.AsynchronousChannelGroup; import java.nio.channels.AsynchronousServerSocketChannel; import java.nio.channels.AsynchronousSocketChannel; import java.nio.channels.CompletionHandler; import java.nio.charset.Charset; import java.nio.charset.CharsetDecoder; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class AioServer { public static void main(String[] args) throws IOException { AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open(); server.bind(new InetSocketAddress(\"localhost\", 8001)); System.out.println(\"服务器在8001端口守候\"); //开始等待客户端连接，一旦有连接，做completed(AsynchronousSocketChannel channel, Object attachment)任务 server.accept(null, new CompletionHandler\u003cAsynchronousSocketChannel, Object\u003e() { @Override public void completed(AsynchronousSocketChannel channel, Object attachment) { server.accept(null, this); //持续接收新的客户端请求 ByteBuffer buffer = ByteBuffer.allocate(1024); //准备读取空间 //开始读取客户端内容，一旦读取结束，做 completed(Integer result_num, ByteBuffer attachment) 任务 channel.read(buffer, buffer, new CompletionHandler\u003cInteger, ByteBuffer\u003e() { @Override public void completed(Integer result_num, ByteBuffer attachment) { attachment.flip(); //反转此Buffer CharBuffer charBuffer = CharBuffer.allocate(1024); CharsetDecoder decoder = Charset.defaultCharset().newDecoder(); decoder.decode(attachment,charBuffer,false); charBuffer.flip(); String data = new String(charBuffer.array(),0, charBuffer.limit()); System.out.println(\"client said: \" + data); channel.write(ByteBuffer.wrap((data + \" 666\").getBytes())); //返回结果给客户端 try{ channel.close(); }catch (Exception e){ e.printStackTrace(); } } @Override public void failed(Throwable exc, ByteBuffer attachment) { System.out.println(\"read error \"+exc.getMessage()); } }); } @Override public void failed(Throwable exc, Object attachment) { System.out.print(\"failed: \" + exc.getMessage()); } }); while(true){ try { Thread.sleep(5000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } /** * * * * 服务器在8001端口守候 * client said: 178a8702-cd42-4b5a-b95b-2c5647a8356a * */ AioClient import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.CharBuffer; import java.nio.channels.AsynchronousSocketChannel; import java.nio.channels.CompletionHandler; import java.nio.charset.Charset; import java.nio.charset.CharsetDecoder; import java.util.UUID; public class AioClient { public static void main(String[] a) { try { AsynchronousSocketChannel channel = AsynchronousSocketChannel.open(); //channel连接成功后，自动做channel.connect任务 channel.connect(new InetSocketAddress(\"localhost\", 8001), null, new CompletionHandler\u003cVoid, Void\u003e() { public void completed(Void result, Void attachment) { String str = UUID.randomUUID().toString(); //str向服务器写数据成功后，自动做 new CompletionHandler\u003cInteger, Object\u003e() 任务 channel.write(ByteBuffer.wrap(str.getBytes()), null, new CompletionHandler\u003cInteger, Object\u003e() { @Override public void completed(Integer result, Object attachment) { try { System.out.println(\"write \" + str + \", and wait response\"); //等待服务器响应 ByteBuffer buffer = ByteBuffer.allocate(1024); //准备读取空间 //开始读取服务器反馈内容，一旦读取结束，做completed(Integer result_num, ByteBuffer attachment) 任务 channel.read(buffer, buffer, new CompletionHandler\u003cInteger, ByteBuffer\u003e() { @Override public void completed(Integer result_num, ByteBuffer attachment) { attachment.flip(); //反转此Buffer CharBuffer charBuffer = CharBuffer.allocate(1024); CharsetDecoder decoder = Charset.defaultCharset().newDecoder(); decoder.decode(attachment,charBuffer,false); charBuffer.flip(); String data = new String(charBuffer.array(),0, charBuffer.limit()); System.out.println(\"server said: \" + data); try{ channel.close(); }catch (Exception e){ e.printStackTrace(); } } @Override public void failed(Throwable exc, ByteBuffer attachment) { System.out.pri","date":"2022-02-24","objectID":"/java12/:6:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"7 Netty 编程 Netty, http://netty.io 最早由韩国 Trustin Lee 设计开发的，后来由 JBoss 接手开发，现在是独立的 Netty Project 一个非阻塞的客户端-服务端网络通讯框架 基于异步事件驱动模型 简化Java的 TCP 和 UDP 编程 支持 HTTP/2， SSL 等多种协议 支持多种数据格式，如 JSON 等 ","date":"2022-02-24","objectID":"/java12/:7:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"7.1 关键技术 7.1.1 通道 Channel ServerSocketChannel/NioServerSocketChannel/… SocketChannel/NioSocketChannel 7.1.2 事件 EventLoop 为每个通道定义一个EventLoop，处理所有的I/O事件 EventLoop注册事件 EventLoop将事件派发给ChannelHandler EventLoop安排进一步操作 7.1.3 事件 事件按照数据流向进行分类 入站事件：连接激活/数据读取/…… 出站事件：打开到远程连接/写数据/…… 7.1.4 事件处理 ChannelHandler Channel通道发生数据或状态改变 EventLoop会将事件分类，并调用ChannelHandler的回调函数 程序员需要实现ChannelHandler内的回调函数 ChannelInboundHandler/ChannelOutboundHandler 7.1.5 ChannelHandler工作模式：责任链 责任链模式： 将请求的接收者连成一条链 在链上传递请求，直到有一个接收者处理该请求 避免请求者和接收者的耦合 责任链模式责任链模式 \" 责任链模式 ChannelHandler可以有多个，依次进行调用 ChannelPipeline作为容器，承载多个ChannelHandler 7.1.6 ByteBuf 强大的字节容器，提供丰富API进行操作 7.1.7 实例 EchoServer // EchoServer.java import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import java.net.InetSocketAddress; public class EchoServer { public static void main(String[] args) throws Exception { int port = 8001; final EchoServerHandler serverHandler = new EchoServerHandler(); EventLoopGroup group = new NioEventLoopGroup(); try { //ServerBootstrap是netty中的一个服务器引导类 ServerBootstrap b = new ServerBootstrap(); b.group(group) .channel(NioServerSocketChannel.class) //设置通道类型 .localAddress(new InetSocketAddress(port)) //设置监听端口 .childHandler(new ChannelInitializer\u003cSocketChannel\u003e() { //初始化责任链 @Override public void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(serverHandler); //添加处理类 } }); ChannelFuture f = b.bind().sync(); //开启监听 if(f.isSuccess()){ System.out.println(EchoServer.class.getName() + \" started and listening for connections on \" + f.channel().localAddress()); } f.channel().closeFuture().sync(); } finally { group.shutdownGracefully().sync(); } } } // EchoServerHandler.java import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFutureListener; import io.netty.channel.ChannelHandler.Sharable; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.ChannelInboundHandlerAdapter; import io.netty.util.CharsetUtil; public class EchoServerHandler extends ChannelInboundHandlerAdapter { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) { ByteBuf in = (ByteBuf) msg; String content = in.toString(CharsetUtil.UTF_8); System.out.println(\"Server received: \" + content); ByteBuf out = ctx.alloc().buffer(1024); out.writeBytes((content + \" 666\").getBytes()); ctx.write(out); } @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { ctx.writeAndFlush(Unpooled.EMPTY_BUFFER) .addListener(ChannelFutureListener.CLOSE); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { cause.printStackTrace(); ctx.close(); } } /** * * * MOOC1808.EchoServer started and listening for connections on /0:0:0:0:0:0:0:0:8001 * Server received: Netty rocks! * * */ EchoClient // EchoClient.java import io.netty.bootstrap.Bootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; import java.net.InetSocketAddress; public class EchoClient { public static void main(String[] args) throws Exception { String host = \"localhost\"; int port = 8001; EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap b = new Bootstrap(); b.group(group) .channel(NioSocketChannel.class) .remoteAddress(new InetSocketAddress(host, port)) .handler(new ChannelInitializer\u003cSocketChannel\u003e() { @Override public void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new EchoClientHandler()); } }); ChannelFuture f = b.connect().sync(); f.channel().closeFuture().sync(); } finally { group.shutdownGracefully().s","date":"2022-02-24","objectID":"/java12/:7:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"7.2 书籍推荐 《Netty 实战》，Norman Maurer 著，何品 译，人民邮电出版社，2017. 《Netty权威指南》，李林锋，电子工业出版社，2015 ","date":"2022-02-24","objectID":"/java12/:7:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"8 Java Mail 编程 Java MailJava Mail \" Java Mail ","date":"2022-02-24","objectID":"/java12/:8:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"8.1 Java Mail 服务器配置 邮件服务器支持 需要在邮件服务内设置，可以查看相关邮件帮助 需要知道pop服务器和smtp服务器信息 ","date":"2022-02-24","objectID":"/java12/:8:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"8.2 Java Mail 工具包 javax.mail 包和javax.mail.internet 包 https://javaee.github.io/javamail mvn dependency \u003cdependency\u003e \u003cgroupId\u003ecom.sun.mail\u003c/groupId\u003e \u003cartifactId\u003ejavax.mail\u003c/artifactId\u003e \u003cversion\u003e1.6.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-02-24","objectID":"/java12/:8:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"8.3 关键类 Session: 邮件会话 和HttpSession不同 Store: 邮件存储空间 Folder: 邮件文件夹 Message: 电子邮件 Address: 邮件地址 Transport: 发送协议类 ","date":"2022-02-24","objectID":"/java12/:8:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"8.4 实例 接收邮件 import javax.mail.*; import javax.mail.internet.*; import javax.activation.*; import java.util.*; public class MailClientRecv { private Session session; private Store store; private String username = \"ieblyang@163.com\"; private String password = \"1234567899\"; private String popServer = \"pop.163.com\"; public void init()throws Exception { //设置属性 Properties props = new Properties(); props.put(\"mail.store.protocol\", \"pop3\"); props.put(\"mail.imap.class\", \"com.sun.mail.imap.IMAPStore\"); props.put(\"mail.pop3.class\", \"com.sun.mail.pop3.POP3Store\"); // 创建Session对象 session = Session.getInstance(props,null); session.setDebug(false); //输出跟踪日志 // 创建Store对象 store = session.getStore(\"pop3\"); //连接到收邮件服务器 store.connect(popServer,username,password); } public void receiveMessage()throws Exception { String folderName = \"inbox\"; Folder folder=store.getFolder(folderName); if(folder==null) { throw new Exception(folderName+\"邮件夹不存在\"); } //打开信箱 folder.open(Folder.READ_ONLY); System.out.println(\"您的收件箱有\"+folder.getMessageCount()+\"封邮件.\"); System.out.println(\"您的收件箱有\"+folder.getUnreadMessageCount()+\"封未读的邮件.\"); //读邮件 Message[] messages=folder.getMessages(); //for(int i=1;i\u003c=messages.length;i++) for(int i=1;i\u003c=3;i++) { System.out.println(\"------第\"+i+\"封邮件-------\"); //打印邮件信息 Message message = messages[i]; //folder.getMessage(i).writeTo(System.out); System.out.println((message.getFrom())[0]); System.out.println(message.getSubject()); System.out.println(); } folder.close(false); //关闭邮件夹 } public void close()throws Exception { store.close(); } public static void main(String[] args)throws Exception { MailClientRecv client=new MailClientRecv(); //初始化 client.init(); //接收邮件 client.receiveMessage(); //关闭连接 client.close(); } } 发送邮件 文本邮件 // messages/TextMessage.java package messages; import java.util.Date; import java.util.Properties; import javax.mail.Message; import javax.mail.Session; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeMessage; import java.io.FileOutputStream; public class TextMessage { public static MimeMessage generate() throws Exception { String from = \"ieblyang@qq.com \"; // 发件人地址 String to = \"ieblyang@163.com\"; // 收件人地址 String subject = \"test\"; String body = \"您好,这是来自一封ieblyang的测试邮件\"; // 创建Session实例对象 Session session = Session.getDefaultInstance(new Properties()); // 创建MimeMessage实例对象 MimeMessage message = new MimeMessage(session); // 设置发件人 message.setFrom(new InternetAddress(from)); // 设置收件人 message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(to)); // 设置发送日期 message.setSentDate(new Date()); // 设置邮件主题 message.setSubject(subject); // 设置纯文本内容的邮件正文 message.setText(body); // 保存并生成最终的邮件内容 message.saveChanges(); // 把MimeMessage对象中的内容写入到文件中 //msg.writeTo(new FileOutputStream(\"e:/test.eml\")); return message; } } 网页邮件 // messages/ package messages; import java.util.Date; import java.util.Properties; import javax.mail.Message; import javax.mail.Session; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeMessage; import java.io.FileOutputStream; public class HtmlMessage { public static MimeMessage generate() throws Exception { String from = \"ieblyang@qq.com \"; // 发件人地址 String to = \"ieblyang@163.com\"; // 收件人地址 String subject = \"多附件邮件\"; //邮件主题 String body = \"\u003ca href=https://ieblyang.tech\u003e\" + \"欢迎大家访问我的网站\u003c/a\u003e\u003c/br\u003e\"; // 创建Session实例对象 Session session = Session.getDefaultInstance(new Properties()); // 创建MimeMessage实例对象 MimeMessage message = new MimeMessage(session); // 设置发件人 message.setFrom(new InternetAddress(from)); // 设置收件人 message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(to)); // 设置发送日期 message.setSentDate(new Date()); // 设置邮件主题 message.setSubject(subject); // 设置HTML格式的邮件正文 message.setContent(body, \"text/html;charset=gb2312\"); // 保存并生成最终的邮件内容 message.saveChanges(); // 把MimeMessage对象中的内容写入到文件中 //msg.writeTo(new FileOutputStream(\"e:/HtmlMessage.eml\")); return message; } } 附件邮件 // messages/ import java.io.FileOutputStream; import java.util.Properties; import javax.acti","date":"2022-02-24","objectID":"/java12/:8:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java网络编程","uri":"/java12/"},{"categories":["Java"],"content":"[Java核心技术] Java并发编程","date":"2022-02-22","objectID":"/java11/","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"Java 核心技术读书笔记——Java并发编程 ","date":"2022-02-22","objectID":"/java11/:0:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"1 并行计算 业务：任务多，数据量大 串行 vs 并行 串行编程简单，并行编程困难 单个计算核频率下降，计算核数增多，整体性能变高 并行困难(任务分配和执行过程高度耦合) 如何控制粒度，切割任务 如何分配任务给线程，监督线程执行过程 并行模式 主从模式 (Master-Slave) Worker模式(Worker-Worker) Java并发编程 Thread/Runnable/Thread组管理 Executor Fork-Join框架 ","date":"2022-02-22","objectID":"/java11/:1:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"2 线程组管理 线程组ThreadGroup 线程的集合 树形结构，大线程组可以包括小线程组 可以通过enumerate方法遍历组内的线程，执行操作 能够有效管理多个线程，但是管理效率低 任务分配和执行过程高度耦合 重复创建线程、关闭线程操作，无法重用线程 笔记 activeCount 返回线程组中还处于active的线程数（估计数）； enumerate 将线程组中active的线程拷贝到数组中； interrupt 对线程组中所有的线程发出interrupt信号； list 打印线程组中所有的线程信息。 // Result.java package threadgroup; /** * 搜索结果类 * */ public class Result { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } // Searcher.java package threadgroup; import java.util.Date; import java.util.Random; import java.util.concurrent.TimeUnit; public class Searcher implements Runnable { private Result result; public Searcher(Result result) { this.result=result; } @Override public void run() { String name=Thread.currentThread().getName(); System.out.printf(\"Thread %s: 启动\\n\",name); try { doTask(); result.setName(name); } catch (InterruptedException e) { System.out.printf(\"Thread %s: 被中断\\n\",name); return; } System.out.printf(\"Thread %s: 完成\\n\",name); } private void doTask() throws InterruptedException { Random random=new Random((new Date()).getTime()); int value=(int)(random.nextDouble()*100); System.out.printf(\"Thread %s: %d\\n\",Thread.currentThread().getName(),value); TimeUnit.SECONDS.sleep(value); } } // Main.java package threadgroup; import java.util.concurrent.TimeUnit; public class Main { public static void main(String[] args) { // 创建线程组 ThreadGroup threadGroup = new ThreadGroup(\"Searcher\"); Result result=new Result(); // 创建一个任务，10个线程完成 Searcher searchTask=new Searcher(result); for (int i=0; i\u003c10; i++) { Thread thread=new Thread(threadGroup, searchTask); thread.start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"========华丽丽0=======\"); // 查看线程组消息 System.out.printf(\"active 线程数量: %d\\n\",threadGroup.activeCount()); System.out.printf(\"线程组信息明细\\n\"); threadGroup.list(); System.out.println(\"========华丽丽1=======\"); // 遍历线程组 Thread[] threads=new Thread[threadGroup.activeCount()]; threadGroup.enumerate(threads); for (int i=0; i\u003cthreadGroup.activeCount(); i++) { System.out.printf(\"Thread %s: %s\\n\",threads[i].getName(),threads[i].getState()); } System.out.println(\"========华丽丽2=======\"); // Wait for the finalization of the Threadds waitFinish(threadGroup); // Interrupt all the Thread objects assigned to the ThreadGroup threadGroup.interrupt(); } public static void waitFinish(ThreadGroup threadGroup) { while (threadGroup.activeCount()\u003e9) { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } } } /** * * 运行结果： * Thread Thread-0: 启动 * Thread Thread-0: 83 * Thread Thread-1: 启动 * Thread Thread-1: 73 * Thread Thread-2: 启动 * Thread Thread-2: 1 * Thread Thread-2: 完成 * Thread Thread-3: 启动 * Thread Thread-3: 92 * Thread Thread-4: 启动 * Thread Thread-4: 73 * Thread Thread-5: 启动 * Thread Thread-5: 64 * Thread Thread-6: 启动 * Thread Thread-6: 89 * Thread Thread-7: 启动 * Thread Thread-7: 80 * Thread Thread-8: 启动 * Thread Thread-8: 8 * Thread Thread-9: 启动 * Thread Thread-9: 99 * ========华丽丽0======= * active 线程数量: 9 * 线程组信息明细 * java.lang.ThreadGroup[name=Searcher,maxpri=10] * Thread[Thread-0,5,Searcher] * Thread[Thread-1,5,Searcher] * Thread[Thread-3,5,Searcher] * Thread[Thread-4,5,Searcher] * Thread[Thread-5,5,Searcher] * Thread[Thread-6,5,Searcher] * Thread[Thread-7,5,Searcher] * Thread[Thread-8,5,Searcher] * Thread[Thread-9,5,Searcher] * ========华丽丽1======= * Thread Thread-0: TIMED_WAITING * Thread Thread-1: TIMED_WAITING * Thread Thread-3: TIMED_WAITING * Thread Thread-4: TIMED_WAITING * Thread Thread-5: TIMED_WAITING * Thread Thread-6: TIMED_WAITING * Thread Thread-7: TIMED_WAITING * Thread Thread-8: TIMED_WAITING * Thread Thread-9: TIMED_WAITING * ========华丽丽2======= * Thread Thread-7: 被中断 * Thread Thread-5: 被中断 * Thread Thread-1: 被中断 * Thread Thread-9: 被中断 * Thread Thread-3: 被中断 * Thread Thread-8: 被中断 * Thread Thread-0: 被中断 * Thread Thread-6: 被中断 * Thread Thread-4: 被中断 */ ","date":"2022-02-22","objectID":"/java11/:2:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"3 Java并发框架Executor ","date":"2022-02-22","objectID":"/java11/:3:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"3.1 Executor FrameWork 从 JDK 5 开始提供Executor FrameWork (java.util.concurrent.*) 分离任务的创建和执行者的创建 线程重复利用(new线程代价很大) ","date":"2022-02-22","objectID":"/java11/:3:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"3.2理解共享线程池的概念 预设好的多个Thread，可弹性增加 多次执行很多很小的任务 任务创建和执行过程解耦 程序员无需关心线程池执行任务过程 ","date":"2022-02-22","objectID":"/java11/:3:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"主要类：ExecutorService， ThreadPoolExecutor，Future Executors.newCachedThreadPool/newFixedThreadPool 创建线程池 ExecutorService 线程池服务 Callable 具体的逻辑对象(线程类) 笔记 Callable 和Runnable是等价的，可以用来执行一个任务 Runnable的run方法没有返回值，而Callable的call方法可以有返回值 Future 返回结果 实例1，各方法演示： // executor/example1/Server.java package executor.example1; import java.util.concurrent.Executors; import java.util.concurrent.ThreadPoolExecutor; /** * 执行服务器 * */ public class Server { //线程池 private ThreadPoolExecutor executor; public Server(){ // 创建一个默认线程池 executor=(ThreadPoolExecutor)Executors.newCachedThreadPool(); // 创建一个固定个数的线程池 //executor=(ThreadPoolExecutor)Executors.newFixedThreadPool(5); } //向线程池提交任务 public void submitTask(Task task){ System.out.printf(\"Server: A new task has arrived\\n\"); executor.execute(task); //执行 无返回值 System.out.printf(\"Server: Pool Size: %d\\n\",executor.getPoolSize()); System.out.printf(\"Server: Active Count: %d\\n\",executor.getActiveCount()); System.out.printf(\"Server: Completed Tasks: %d\\n\",executor.getCompletedTaskCount()); } // 关闭整个线程池 public void endServer() { executor.shutdown(); } } // executor/example1/Task.java package executor.example1; import java.util.Date; import java.util.concurrent.TimeUnit; /** * Task 任务类 * @author Tom * */ public class Task implements Runnable { private String name; public Task(String name){ this.name=name; } //休眠，进行两次输出 public void run() { try { Long duration=(long)(Math.random()*1000); System.out.printf(\"%s: Task %s: Doing a task during %d seconds\\n\",Thread.currentThread().getName(),name,duration); Thread.sleep(duration); } catch (InterruptedException e) { e.printStackTrace(); } System.out.printf(\"%s: Task %s: Finished on: %s\\n\",Thread.currentThread().getName(),name,new Date()); } } // executor/example1/Main.java package executor.example1; public class Main { public static void main(String[] args) throws InterruptedException { // 创建一个执行服务器 Server server=new Server(); // 创建20个任务，并发给执行器，等待完成 for (int i=0; i\u003c20; i++){ Task task=new Task(\"Task \"+i); Thread.sleep(10); //将任务提交给线程池去执行 server.submitTask(task); } // 关闭整个线程池 server.endServer(); } 运行结果 Server: A new task has arrived Server: Pool Size: 1 pool-1-thread-1: Task Task 0: Doing a task during 148 seconds Server: Active Count: 1 Server: Completed Tasks: 0 Server: A new task has arrived Server: Pool Size: 2 Server: Active Count: 2 pool-1-thread-2: Task Task 1: Doing a task during 988 seconds Server: Completed Tasks: 0 Server: A new task has arrived Server: Pool Size: 3 Server: Active Count: 3 pool-1-thread-3: Task Task 2: Doing a task during 769 seconds Server: Completed Tasks: 0 Server: A new task has arrived Server: Pool Size: 4 Server: Active Count: 4 Server: Completed Tasks: 0 pool-1-thread-4: Task Task 3: Doing a task during 698 seconds Server: A new task has arrived Server: Pool Size: 5 Server: Active Count: 5 pool-1-thread-5: Task Task 4: Doing a task during 727 seconds Server: Completed Tasks: 0 Server: A new task has arrived Server: Pool Size: 6 Server: Active Count: 6 pool-1-thread-6: Task Task 5: Doing a task during 232 seconds Server: Completed Tasks: 0 Server: A new task has arrived Server: Pool Size: 7 Server: Active Count: 7 pool-1-thread-7: Task Task 6: Doing a task during 509 seconds Server: Completed Tasks: 0 Server: A new task has arrived Server: Pool Size: 8 pool-1-thread-8: Task Task 7: Doing a task during 21 seconds Server: Active Count: 8 Server: Completed Tasks: 0 Server: A new task has arrived Server: Pool Size: 9 Server: Active Count: 9 pool-1-thread-9: Task Task 8: Doing a task during 683 seconds Server: Completed Tasks: 0 Server: A new task has arrived Server: Pool Size: 10 Server: Active Count: 10 Server: Completed Tasks: 0 pool-1-thread-10: Task Task 9: Doing a task during 616 seconds pool-1-thread-8: Task Task 7: Finished on: Mon Feb 28 21:37:57 CST 2022 Server: A new task has arrived Server: Pool Size: 10 pool-1-thread-8: Task Task 10: Doing a task during 403 seconds Server: Active Count: 10 Server: Completed Tasks: 1 Server: A new task ha","date":"2022-02-22","objectID":"/java11/:3:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"4 Java并发框架Fork-Join 笔记 Java 7 提供另一种并行框架：分解、治理、合并（分治编程） 适合用于整体任务量不好确定的场合（最小任务可确定） 关键类： ForkJoinPool 任务池 RecursiveAction RecursiveTask // SumTask.java import java.math.BigInteger; import java.util.concurrent.RecursiveTask; //分任务求和 public class SumTask extends RecursiveTask\u003cLong\u003e { private int start; private int end; public SumTask(int start, int end) { this.start = start; this.end = end; } public static final int threadhold = 5; @Override protected Long compute() { Long sum = 0L; // 如果任务小于等于阈值, 就直接执行 boolean canCompute = (end - start) \u003c= threadhold; if (canCompute) { for (int i = start; i \u003c= end; i++) { sum = sum + i; } } else { // 任务大于阈值, 分裂为2个任务 int middle = (start + end) / 2; SumTask subTask1 = new SumTask(start, middle); SumTask subTask2 = new SumTask(middle + 1, end); invokeAll(subTask1, subTask2); Long sum1 = subTask1.join(); Long sum2 = subTask2.join(); // 结果合并 sum = sum1 + sum2; } return sum; } } // SumTest.java import java.util.concurrent.ExecutionException; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.ForkJoinTask; //分任务求和 public class SumTest { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建执行线程池 ForkJoinPool pool = new ForkJoinPool(); //ForkJoinPool pool = new ForkJoinPool(4); //创建任务 SumTask task = new SumTask(1, 10000000); /提交任务 ForkJoinTask\u003cLong\u003e result = pool.submit(task); //等待结果 do { System.out.printf(\"Main: Thread Count: %d\\n\",pool.getActiveThreadCount()); System.out.printf(\"Main: Paralelism: %d\\n\",pool.getParallelism()); try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } } while (!task.isDone()); //输出结果 System.out.println(result.get().toString()); } } ","date":"2022-02-22","objectID":"/java11/:4:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"5 Java并发数据结构 笔记 常用的数据结构是线程不安全的 ArrayList, HashMap, HashSet 非同步的 多个线程同时读写，可能会抛出异常或数据错误 传统Vector，Hashtable等同步集合性能过差 并发数据结构：数据添加和删除 阻塞式集合：当集合为空或者满时，等待 非阻塞式集合：当集合为空或者满时，不等待，返回null或异常 ","date":"2022-02-22","objectID":"/java11/:5:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"5.1 List Vector 同步安全，写多读少 ArrayList 不安全 Collections.synchronizedList(List list) 基于synchronized，效率差 CopyOnWriteArrayList 读多写少，基于复制机制，非阻塞 package list; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.concurrent.CopyOnWriteArrayList; public class ListTest { public static void main(String[] args) throws InterruptedException{ //线程不安全 List\u003cString\u003e unsafeList = new ArrayList\u003cString\u003e(); //线程安全 List\u003cString\u003e safeList1 = Collections.synchronizedList(new ArrayList\u003cString\u003e()); //线程安全 CopyOnWriteArrayList\u003cString\u003e safeList2 = new CopyOnWriteArrayList\u003cString\u003e(); ListThread t1 = new ListThread(unsafeList); ListThread t2 = new ListThread(safeList1); ListThread t3 = new ListThread(safeList2); for(int i = 0; i \u003c 10; i++){ Thread t = new Thread(t1, String.valueOf(i)); t.start(); } for(int i = 0; i \u003c 10; i++) { Thread t = new Thread(t2, String.valueOf(i)); t.start(); } for(int i = 0; i \u003c 10; i++) { Thread t = new Thread(t3, String.valueOf(i)); t.start(); } //等待子线程执行完 Thread.sleep(2000); System.out.println(\"listThread1.list.size() = \" + t1.list.size()); System.out.println(\"listThread2.list.size() = \" + t2.list.size()); System.out.println(\"listThread3.list.size() = \" + t3.list.size()); //输出list中的值 System.out.println(\"unsafeList：\"); for(String s : t1.list){ if(s == null){ System.out.print(\"null \"); } else { System.out.print(s + \" \"); } } System.out.println(); System.out.println(\"safeList1：\"); for(String s : t2.list){ if(s == null){ System.out.print(\"null \"); } else { System.out.print(s + \" \"); } } System.out.println(); System.out.println(\"safeList2：\"); for(String s : t3.list){ if(s == null){ System.out.print(\"null \"); } else { System.out.print(s + \" \"); } } } } class ListThread implements Runnable{ public List\u003cString\u003e list; public ListThread(List\u003cString\u003e list){ this.list = list; } @Override public void run() { int i = 0; while(i\u003c10) { try { Thread.sleep(10); }catch (InterruptedException e){ e.printStackTrace(); } //把当前线程名称加入list中 list.add(Thread.currentThread().getName()); i++; } } } /** * * * listThread1.list.size() = 95 * listThread2.list.size() = 100 * listThread3.list.size() = 100 * unsafeList： * 5 6 3 8 4 7 9 2 0 1 1 2 3 9 6 5 7 8 4 0 5 9 null null null 2 4 7 8 0 6 1 3 9 7 5 4 8 0 1 2 9 3 7 4 5 8 0 7 null null null 5 2 6 4 8 0 1 8 5 9 3 2 7 0 4 2 3 4 9 7 1 null null 5 0 1 9 2 3 5 8 4 7 0 7 5 9 3 8 0 2 1 4 * safeList1： * 3 2 8 1 0 4 5 7 6 9 7 2 0 4 8 3 6 9 1 5 2 0 8 7 4 3 1 9 6 5 9 3 7 8 2 0 6 4 1 5 9 2 8 7 3 6 0 4 1 5 0 7 8 2 9 4 3 1 6 5 3 7 8 2 1 5 6 4 9 0 1 4 9 7 5 8 0 2 3 6 2 0 8 6 9 7 1 3 5 4 5 2 8 0 4 3 9 6 1 7 * safeList2： * 6 0 4 3 2 9 5 8 7 1 7 8 6 9 4 5 3 2 0 1 2 8 7 4 0 9 5 6 1 3 0 9 4 2 1 3 6 7 8 5 0 6 8 9 1 7 5 2 4 3 8 0 7 4 9 3 5 6 1 2 6 8 9 3 5 2 1 7 0 4 4 0 8 5 7 1 2 6 3 9 3 5 6 8 2 9 7 1 0 4 2 0 4 9 3 8 6 5 7 1 * */ ","date":"2022-02-22","objectID":"/java11/:5:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"5.2 Set HashSet 不安全 Collections.synchronizedSet(Set set) 基于synchronized，效率差 CopyOnWriteArraySet (基于CopyOnWriteArrayList实现) 读多写少， 非阻塞 package set; import java.util.*; import java.util.concurrent.CopyOnWriteArraySet; public class SetTest{ public static void main(String[] args) throws InterruptedException{ //线程不安全 Set\u003cString\u003e unsafeSet = new HashSet\u003cString\u003e(); //线程安全 Set\u003cString\u003e safeSet1 = Collections.synchronizedSet(new HashSet\u003cString\u003e()); //线程安全 CopyOnWriteArraySet\u003cString\u003e safeSet2 = new CopyOnWriteArraySet\u003cString\u003e(); SetThread t1 = new SetThread(unsafeSet); SetThread t2 = new SetThread(safeSet1); SetThread t3 = new SetThread(safeSet2); //unsafeSet的运行测试 for(int i = 0; i \u003c 10; i++){ Thread t = new Thread(t1, String.valueOf(i)); t.start(); } for(int i = 0; i \u003c 10; i++) { Thread t = new Thread(t2, String.valueOf(i)); t.start(); } for(int i = 0; i \u003c 10; i++) { Thread t = new Thread(t3, String.valueOf(i)); t.start(); } //等待子线程执行完 Thread.sleep(2000); System.out.println(\"setThread1.set.size() = \" + t1.set.size()); System.out.println(\"setThread2.set.size() = \" + t2.set.size()); System.out.println(\"setThread3.set.size() = \" + t3.set.size()); //输出set中的值 System.out.println(\"unsafeSet：\"); for(String element:t1.set){ if(element == null){ System.out.print(\"null \"); } else { System.out.print(element + \" \"); } } System.out.println(); System.out.println(\"safeSet1：\"); for(String element:t2.set){ if(element == null){ System.out.print(\"null \"); } else { System.out.print(element + \" \"); } } System.out.println(); System.out.println(\"safeSet2：\"); for(String element:t3.set){ if(element == null){ System.out.print(\"null \"); } else { System.out.print(element + \" \"); } } } } class SetThread implements Runnable{ public Set\u003cString\u003e set; public SetThread(Set\u003cString\u003e set){ this.set = set; } @Override public void run() { int i = 0; while(i\u003c10) { i++; try { Thread.sleep(10); }catch (InterruptedException e){ e.printStackTrace(); } //把当前线程名称加入list中 set.add(Thread.currentThread().getName() + i); } } } /** * * * setThread1.set.size() = 97 * setThread2.set.size() = 100 * setThread3.set.size() = 100 * unsafeSet： * 44 88 45 89 02 46 03 47 04 48 05 49 06 07 08 09 110 310 510 710 910 92 93 94 51 95 96 53 97 54 98 55 99 56 13 57 14 58 15 59 16 17 18 19 62 63 64 65 66 23 67 24 68 25 69 26 27 28 29 010 210 410 610 810 73 74 75 32 76 33 77 34 78 35 79 36 37 38 39 83 84 85 42 86 43 87 * safeSet1： * 88 01 89 02 03 04 05 06 07 08 09 110 510 91 910 92 93 94 95 96 97 98 11 99 12 13 14 15 16 17 18 19 21 22 23 24 25 26 27 28 29 010 410 810 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46 47 48 49 310 710 51 52 53 54 55 56 57 58 59 61 62 63 64 65 66 67 68 69 210 610 71 72 73 74 75 76 77 78 79 81 82 83 84 85 86 87 * safeSet2： * 21 61 51 41 01 91 81 11 71 31 22 62 32 52 82 92 12 42 02 72 93 23 83 13 33 43 73 53 03 63 24 64 84 34 04 54 94 74 44 14 25 95 15 05 55 35 75 85 65 45 86 36 76 06 56 66 16 96 26 46 27 47 97 57 77 87 67 07 37 17 98 08 38 58 78 48 18 88 68 28 09 39 29 19 49 59 79 89 99 69 610 110 910 510 810 410 010 210 310 710 * * * */ ","date":"2022-02-22","objectID":"/java11/:5:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"5.3 Map Hashtable 同步安全，写多读少 HashMap 不安全 Collections.synchronizedMap(Map map) 基于synchronized，效率差 ConcurrentHashMap 读多写少，非阻塞 package map; import java.util.*; import java.util.concurrent.ConcurrentHashMap; public class MapTest{ public static void main(String[] args) throws InterruptedException{ //线程不安全 Map\u003cInteger,String\u003e unsafeMap = new HashMap\u003cInteger,String\u003e(); //线程安全 Map\u003cInteger,String\u003e safeMap1 = Collections.synchronizedMap(new HashMap\u003cInteger,String\u003e()); //线程安全 ConcurrentHashMap\u003cInteger,String\u003e safeMap2 = new ConcurrentHashMap\u003cInteger,String\u003e(); MapThread t1 = new MapThread(unsafeMap); MapThread t2 = new MapThread(safeMap1); MapThread t3 = new MapThread(safeMap2); //unsafeMap的运行测试 for(int i = 0; i \u003c 10; i++){ Thread t = new Thread(t1); t.start(); } for(int i = 0; i \u003c 10; i++) { Thread t = new Thread(t2); t.start(); } for(int i = 0; i \u003c 10; i++) { Thread t = new Thread(t3); t.start(); } //等待子线程执行完 Thread.sleep(2000); System.out.println(\"mapThread1.map.size() = \" + t1.map.size()); System.out.println(\"mapThread2.map.size() = \" + t2.map.size()); System.out.println(\"mapThread3.map.size() = \" + t3.map.size()); //输出set中的值 System.out.println(\"unsafeMap：\"); Iterator iter = t1.map.entrySet().iterator(); while(iter.hasNext()) { Map.Entry\u003cInteger,String\u003e entry = (Map.Entry\u003cInteger,String\u003e)iter.next(); // 获取key System.out.print(entry.getKey() + \":\"); // 获取value System.out.print(entry.getValue() + \" \"); } System.out.println(); System.out.println(\"safeMap1：\"); iter = t2.map.entrySet().iterator(); while(iter.hasNext()) { Map.Entry\u003cInteger,String\u003e entry = (Map.Entry\u003cInteger,String\u003e)iter.next(); // 获取key System.out.print(entry.getKey() + \":\"); // 获取value System.out.print(entry.getValue() + \" \"); } System.out.println(); System.out.println(\"safeMap2：\"); iter = t3.map.entrySet().iterator(); while(iter.hasNext()) { Map.Entry\u003cInteger,String\u003e entry = (Map.Entry\u003cInteger,String\u003e)iter.next(); // 获取key System.out.print(entry.getKey() + \":\"); // 获取value System.out.print(entry.getValue() + \" \"); } System.out.println(); System.out.println(\"mapThread1.map.size() = \" + t1.map.size()); System.out.println(\"mapThread2.map.size() = \" + t2.map.size()); System.out.println(\"mapThread3.map.size() = \" + t3.map.size()); } } class MapThread implements Runnable { public Map\u003cInteger,String\u003e map; public MapThread(Map\u003cInteger,String\u003e map){ this.map = map; } @Override public void run() { int i=0; while(i\u003c100) { //把当前线程名称加入map中 map.put(i++,Thread.currentThread().getName()); try { Thread.sleep(10); }catch (InterruptedException e){ e.printStackTrace(); } } } } /** * * * * * * mapThread1.map.size() = 123 * mapThread2.map.size() = 100 * mapThread3.map.size() = 100 * unsafeMap： * 0:Thread-9 1:Thread-0 2:Thread-5 3:Thread-1 4:Thread-7 5:Thread-7 6:Thread-4 7:Thread-9 8:Thread-8 9:Thread-2 10:Thread-6 11:Thread-5 12:Thread-7 13:Thread-7 14:Thread-0 15:Thread-0 16:Thread-6 17:Thread-7 18:Thread-6 19:Thread-7 20:Thread-7 21:Thread-0 22:Thread-5 23:Thread-0 24:Thread-3 25:Thread-0 26:Thread-5 27:Thread-7 28:Thread-0 29:Thread-2 30:Thread-2 31:Thread-1 32:Thread-3 33:Thread-9 34:Thread-7 35:Thread-0 36:Thread-0 37:Thread-0 38:Thread-7 39:Thread-6 40:Thread-7 41:Thread-7 42:Thread-0 43:Thread-0 44:Thread-6 45:Thread-7 46:Thread-8 47:Thread-6 48:Thread-9 49:Thread-0 50:Thread-1 51:Thread-2 52:Thread-6 53:Thread-7 54:Thread-7 55:Thread-0 56:Thread-2 57:Thread-2 58:Thread-5 59:Thread-9 60:Thread-7 61:Thread-2 62:Thread-0 63:Thread-8 64:Thread-6 65:Thread-8 66:Thread-0 67:Thread-8 68:Thread-8 69:Thread-0 70:Thread-1 71:Thread-7 72:Thread-9 73:Thread-7 74:Thread-9 75:Thread-7 76:Thread-0 77:Thread-7 78:Thread-8 79:Thread-8 80:Thread-8 81:Thread-7 82:Thread-8 83:Thread-7 84:Thread-1 85:Thread-0 86:Thread-5 87:Thread-8 88:Thread-5 89:Thread-8 90:Thread-8 91:Thread-1 92:Thread-8 93:Thread-7 94:Thread-8 95:Thread-0 96:Thread-7 97:Thread-0 98:Thread-5 99:Thread-7 * safeMap1： * 0:Thread-16 1:Thread-14 2:Thread-14 3:Thread-12 4:Thread-11 5:Thread-15 6:Thread-18 7:Thread-18 8:Thread-18 9:Thread-11","date":"2022-02-22","objectID":"/java11/:5:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"5.4 Queue \u0026 Deque (队列，JDK 1.5 提出) ConcurrentLinkedQueue 非阻塞 ArrayBlockingQueue/LinkedBlockingQueue 阻塞 package queue; import java.util.*; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ConcurrentLinkedDeque; public class QueueTest { public static void main(String[] args) throws InterruptedException{ //线程不安全 Deque\u003cString\u003e unsafeQueue = new ArrayDeque\u003cString\u003e(); //线程安全 ConcurrentLinkedDeque\u003cString\u003e safeQueue1 = new ConcurrentLinkedDeque\u003cString\u003e(); ArrayBlockingQueue\u003cString\u003e safeQueue2 = new ArrayBlockingQueue\u003cString\u003e(100); QueueThread t1 = new QueueThread(unsafeQueue); QueueThread t2 = new QueueThread(safeQueue1); QueueThread t3 = new QueueThread(safeQueue2); for(int i = 0; i \u003c 10; i++){ Thread thread1 = new Thread(t1, String.valueOf(i)); thread1.start(); } for(int i = 0; i \u003c 10; i++) { Thread thread2 = new Thread(t2, String.valueOf(i)); thread2.start(); } for(int i = 0; i \u003c 10; i++) { Thread thread3 = new Thread(t3, String.valueOf(i)); thread3.start(); } //等待子线程执行完 Thread.sleep(2000); System.out.println(\"queueThread1.queue.size() = \" + t1.queue.size()); System.out.println(\"queueThread2.queue.size() = \" + t2.queue.size()); System.out.println(\"queueThread3.queue.size() = \" + t3.queue.size()); //输出queue中的值 System.out.println(\"unsafeQueue：\"); for(String s:t1.queue) { System.out.print(s + \" \"); } System.out.println(); System.out.println(\"safeQueue1：\"); for(String s:t2.queue) { System.out.print(s + \" \"); } System.out.println(); System.out.println(\"safeQueue2：\"); for(String s:t3.queue) { System.out.print(s + \" \"); } } } class QueueThread implements Runnable{ public Queue\u003cString\u003e queue; public QueueThread(Queue\u003cString\u003e queue){ this.queue = queue; } @Override public void run() { int i = 0; while(i\u003c10) { i++; try { Thread.sleep(10); }catch (InterruptedException e){ e.printStackTrace(); } //把当前线程名称加入list中 queue.add(Thread.currentThread().getName()); } } } /** * * * queueThread1.queue.size() = 83 * queueThread2.queue.size() = 100 * queueThread3.queue.size() = 100 * unsafeQueue： * 1 8 4 3 7 6 0 0 5 3 2 8 4 0 7 6 6 4 3 2 9 1 5 8 0 4 2 3 5 8 9 1 6 5 7 3 1 9 4 2 0 2 9 1 5 4 3 6 8 0 7 0 5 2 3 1 4 9 8 7 6 9 2 5 2 9 1 4 3 5 6 8 7 0 6 8 0 2 7 3 4 9 1 * safeQueue1： * 4 8 1 7 2 9 0 6 3 5 3 4 0 9 5 1 7 6 2 8 8 2 9 1 7 0 4 3 6 5 2 4 1 8 7 3 0 9 6 5 4 0 7 3 8 9 1 2 5 6 8 0 7 3 2 1 9 4 6 5 4 7 0 8 6 3 9 1 2 5 3 8 7 4 0 5 2 6 1 9 7 0 2 8 9 1 4 3 6 5 3 8 5 6 0 4 1 9 7 2 * safeQueue2： * 6 3 2 5 1 9 4 8 0 7 5 8 7 1 3 6 4 0 9 2 6 1 9 7 5 8 0 2 3 4 1 6 7 5 8 3 0 4 9 2 1 2 9 7 5 4 3 0 6 8 0 5 2 8 6 3 4 9 1 7 4 9 1 6 2 0 3 8 7 5 8 2 7 6 0 3 1 9 5 4 6 8 5 0 7 1 2 9 3 4 4 3 9 5 0 2 1 6 8 7 * * * */ ","date":"2022-02-22","objectID":"/java11/:5:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"6 Java并发协作控制 笔记 Thread/Executor/Fork-Join 线程启动，运行，结束 线程之间缺少协作 synchronized 同步 限定只有一个线程才能进入关键区 简单粗暴，性能损失有点大 ","date":"2022-02-22","objectID":"/java11/:6:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"6.1 Lock Lock也可以实现同步的效果 实现更复杂的临界区结构 tryLock方法可以预判锁是否空闲 允许分离读写的操作，多个读，一个写 性能更好 ReentrantLock类，可重入的互斥锁 ReentrantReadWriteLock类，可重入的读写锁 lock和unlock函数 import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class LockExample { private static final ReentrantLock queueLock = new ReentrantLock(); //可重入锁 private static final ReentrantReadWriteLock orderLock = new ReentrantReadWriteLock(); //可重入读写锁 /** * 有家奶茶店，点单有时需要排队 * 假设想买奶茶的人如果看到需要排队，就决定不买 * 又假设奶茶店有老板和多名员工，记单方式比较原始，只有一个订单本 * 老板负责写新订单，员工不断地查看订单本得到信息来制作奶茶，在老板写新订单时员工不能看订单本 * 多个员工可同时看订单本，在员工看时老板不能写新订单 * @param args * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException { buyMilkTea(); //handleOrder(); //需手动关闭 } public void tryToBuyMilkTea() throws InterruptedException { boolean flag = true; while(flag) { if (queueLock.tryLock()) { //queueLock.lock(); long thinkingTime = (long) (Math.random() * 500); Thread.sleep(thinkingTime); System.out.println(Thread.currentThread().getName() + \"： 来一杯珍珠奶茶，不要珍珠\"); flag = false; queueLock.unlock(); } else { //System.out.println(Thread.currentThread().getName() + \"：\" + queueLock.getQueueLength() + \"人在排队\"); System.out.println(Thread.currentThread().getName() + \"： 再等等\"); } if(flag) { Thread.sleep(1000); } } } public void addOrder() throws InterruptedException { //writeLock，写锁，排他的，只能一个线程拥有 orderLock.writeLock().lock(); long writingTime = (long) (Math.random() * 1000); Thread.sleep(writingTime); System.out.println(\"老板新加一笔订单\"); orderLock.writeLock().unlock(); } public void viewOrder() throws InterruptedException { //readLock，读锁，可以多个线程共享 orderLock.readLock().lock(); long readingTime = (long) (Math.random() * 500); Thread.sleep(readingTime); System.out.println(Thread.currentThread().getName() + \": 查看订单本\"); orderLock.readLock().unlock(); } public static void buyMilkTea() throws InterruptedException { LockExample lockExample = new LockExample(); int STUDENTS_CNT = 10; Thread[] students = new Thread[STUDENTS_CNT]; for (int i = 0; i \u003c STUDENTS_CNT; i++) { students[i] = new Thread(new Runnable() { @Override public void run() { try { long walkingTime = (long) (Math.random() * 1000); Thread.sleep(walkingTime); lockExample.tryToBuyMilkTea(); } catch(InterruptedException e) { System.out.println(e.getMessage()); } } } ); students[i].start(); } for (int i = 0; i \u003c STUDENTS_CNT; i++) students[i].join(); } public static void handleOrder() throws InterruptedException { LockExample lockExample = new LockExample(); Thread boss = new Thread(new Runnable() { @Override public void run() { while (true) { try { lockExample.addOrder(); long waitingTime = (long) (Math.random() * 1000); Thread.sleep(waitingTime); } catch (InterruptedException e) { System.out.println(e.getMessage()); } } } }); boss.start(); int workerCnt = 3; Thread[] workers = new Thread[workerCnt]; for (int i = 0; i \u003c workerCnt; i++) { workers[i] = new Thread(new Runnable() { @Override public void run() { while (true) { try { lockExample.viewOrder(); long workingTime = (long) (Math.random() * 5000); Thread.sleep(workingTime); } catch (InterruptedException e) { System.out.println(e.getMessage()); } } } }); workers[i].start(); } } } /** * * * Thread-2： 再等等 * Thread-0： 来一杯珍珠奶茶，不要珍珠 * Thread-3： 再等等 * Thread-6： 再等等 * Thread-9： 再等等 * Thread-8： 再等等 * Thread-1： 来一杯珍珠奶茶，不要珍珠 * Thread-5： 来一杯珍珠奶茶，不要珍珠 * Thread-7： 再等等 * Thread-4： 来一杯珍珠奶茶，不要珍珠 * Thread-3： 再等等 * Thread-6： 再等等 * Thread-2： 来一杯珍珠奶茶，不要珍珠 * Thread-8： 再等等 * Thread-9： 来一杯珍珠奶茶，不要珍珠 * Thread-7： 来一杯珍珠奶茶，不要珍珠 * Thread-6： 再等等 * Thread-8： 再等等 * Thread-3： 来一杯珍珠奶茶，不要珍珠 * Thread-8： 再等等 * Thread-6： 来一杯珍珠奶茶，不要珍珠 * Thread-8： 来一杯珍珠奶茶，不要珍珠 * */ ","date":"2022-02-22","objectID":"/java11/:6:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"6.2 Semaphore 信号量，由1965年Dijkstra提出的 信号量：本质上是一个计数器 计数器大于0，可以使用，等于0不能使用 可以设置多个并发量，例如限制10个访问 Semaphore acquire获取 release释放 比Lock更进一步，可以控制多个同时访问关键区 import java.util.concurrent.Semaphore; public class SemaphoreExample { private final Semaphore placeSemaphore = new Semaphore(5); public boolean parking() throws InterruptedException { if (placeSemaphore.tryAcquire()) { System.out.println(Thread.currentThread().getName() + \": 停车成功\"); return true; } else { System.out.println(Thread.currentThread().getName() + \": 没有空位\"); return false; } } public void leaving() throws InterruptedException { placeSemaphore.release(); System.out.println(Thread.currentThread().getName() + \": 开走\"); } /** * 现有一地下车库，共有车位5个，由10辆车需要停放，每次停放时，去申请信号量 * @param args * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException { int tryToParkCnt = 10; SemaphoreExample semaphoreExample = new SemaphoreExample(); Thread[] parkers = new Thread[tryToParkCnt]; for (int i = 0; i \u003c tryToParkCnt; i++) { parkers[i] = new Thread(new Runnable() { @Override public void run() { try { long randomTime = (long) (Math.random() * 1000); Thread.sleep(randomTime); if (semaphoreExample.parking()) { long parkingTime = (long) (Math.random() * 1200); Thread.sleep(parkingTime); semaphoreExample.leaving(); } } catch (InterruptedException e) { e.printStackTrace(); } } }); parkers[i].start(); } for (int i = 0; i \u003c tryToParkCnt; i++) { parkers[i].join(); } } } /** * * * Thread-5: 停车成功 * Thread-9: 停车成功 * Thread-9: 开走 * Thread-6: 停车成功 * Thread-8: 停车成功 * Thread-2: 停车成功 * Thread-4: 停车成功 * Thread-0: 没有空位 * Thread-4: 开走 * Thread-7: 停车成功 * Thread-2: 开走 * Thread-3: 停车成功 * Thread-6: 开走 * Thread-1: 停车成功 * Thread-5: 开走 * Thread-8: 开走 * Thread-3: 开走 * Thread-1: 开走 * Thread-7: 开走 * * */ ","date":"2022-02-22","objectID":"/java11/:6:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"6.3 Latch 等待锁，是一个同步辅助类 用来同步执行任务的一个或者多个线程 不是用来保护临界区或者共享资源 CountDownLatch countDown() 计数减1 await() 等待latch变成0 import java.util.concurrent.CountDownLatch; public class CountDownLatchExample { /** * 设想百米赛跑比赛 发令枪发出信号后选手开始跑，全部选手跑到终点后比赛结束 * * @param args * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException { int runnerCnt = 10; CountDownLatch startSignal = new CountDownLatch(1); CountDownLatch doneSignal = new CountDownLatch(runnerCnt); for (int i = 0; i \u003c runnerCnt; ++i) // create and start threads new Thread(new Worker(startSignal, doneSignal)).start(); System.out.println(\"准备工作...\"); System.out.println(\"准备工作就绪\"); startSignal.countDown(); // let all threads proceed System.out.println(\"比赛开始\"); doneSignal.await(); // wait for all to finish System.out.println(\"比赛结束\"); } static class Worker implements Runnable { private final CountDownLatch startSignal; private final CountDownLatch doneSignal; Worker(CountDownLatch startSignal, CountDownLatch doneSignal) { this.startSignal = startSignal; this.doneSignal = doneSignal; } public void run() { try { startSignal.await(); doWork(); doneSignal.countDown(); } catch (InterruptedException ex) { } // return; } void doWork() { System.out.println(Thread.currentThread().getName() + \": 跑完全程\"); } } } /** * * 准备工作... * 准备工作就绪 * 比赛开始 * Thread-0: 跑完全程 * Thread-6: 跑完全程 * Thread-9: 跑完全程 * Thread-5: 跑完全程 * Thread-4: 跑完全程 * Thread-8: 跑完全程 * Thread-3: 跑完全程 * Thread-2: 跑完全程 * Thread-1: 跑完全程 * Thread-7: 跑完全程 * 比赛结束 * */ ","date":"2022-02-22","objectID":"/java11/:6:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"6.4 Barrier 集合点，也是一个同步辅助类 允许多个线程在某一个点上进行同步 CyclicBarrier 构造函数是需要同步的线程数量 await等待其他线程，到达数量后，就放行 笔记 当在Barrier上await的线程数量达到预定的要求后，所有的await的线程不再等待，全部解锁。并且，Barrier将执行预定的回调动作（本程序中，回调动作就是CalculateFinalResult） import java.util.concurrent.BrokenBarrierException; import java.util.concurrent.CyclicBarrier; public class CyclicBarrierExample { /** * 假定有三行数，用三个线程分别计算每一行的和，最终计算总和 * @param args */ public static void main(String[] args) { final int[][] numbers = new int[3][5]; final int[] results = new int[3]; int[] row1 = new int[]{1, 2, 3, 4, 5}; int[] row2 = new int[]{6, 7, 8, 9, 10}; int[] row3 = new int[]{11, 12, 13, 14, 15}; numbers[0] = row1; numbers[1] = row2; numbers[2] = row3; CalculateFinalResult finalResultCalculator = new CalculateFinalResult(results); CyclicBarrier barrier = new CyclicBarrier(3, finalResultCalculator); //当有3个线程在barrier上await，就执行finalResultCalculator for(int i = 0; i \u003c 3; i++) { CalculateEachRow rowCalculator = new CalculateEachRow(barrier, numbers, i, results); new Thread(rowCalculator).start(); } } } class CalculateEachRow implements Runnable { final int[][] numbers; final int rowNumber; final int[] res; final CyclicBarrier barrier; CalculateEachRow(CyclicBarrier barrier, int[][] numbers, int rowNumber, int[] res) { this.barrier = barrier; this.numbers = numbers; this.rowNumber = rowNumber; this.res = res; } @Override public void run() { int[] row = numbers[rowNumber]; int sum = 0; for (int data : row) { sum += data; res[rowNumber] = sum; } try { System.out.println(Thread.currentThread().getName() + \": 计算第\" + (rowNumber + 1) + \"行结束，结果为: \" + sum); barrier.await(); //等待！只要超过3个(Barrier的构造参数)，就放行。 } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } } } class CalculateFinalResult implements Runnable { final int[] eachRowRes; int finalRes; public int getFinalResult() { return finalRes; } CalculateFinalResult(int[] eachRowRes) { this.eachRowRes = eachRowRes; } @Override public void run() { int sum = 0; for(int data : eachRowRes) { sum += data; } finalRes = sum; System.out.println(\"最终结果为: \" + finalRes); } } /** * * Thread-0: 计算第1行结束，结果为: 15 * Thread-2: 计算第3行结束，结果为: 65 * Thread-1: 计算第2行结束，结果为: 40 * 最终结果为: 120 * */ ","date":"2022-02-22","objectID":"/java11/:6:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"6.5 Phaser 允许执行并发多阶段任务，同步辅助类 在每一个阶段结束的位置对线程进行同步，当所有的线程都到达这步，再进行下一步 Phaser arrive() arriveAndAwaitAdvance() import java.util.concurrent.Phaser; public class PhaserExample { /** * 假设举行考试，总共三道大题，每次下发一道题目，等所有学生完成后再进行下一道 * * @param args */ public static void main(String[] args) { int studentsCnt = 5; Phaser phaser = new Phaser(studentsCnt); for (int i = 0; i \u003c studentsCnt; i++) { new Thread(new Student(phaser)).start(); } } } class Student implements Runnable { private final Phaser phaser; public Student(Phaser phaser) { this.phaser = phaser; } @Override public void run() { try { doTesting(1); phaser.arriveAndAwaitAdvance(); //等到5个线程都到了，才放行 doTesting(2); phaser.arriveAndAwaitAdvance(); doTesting(3); phaser.arriveAndAwaitAdvance(); } catch (InterruptedException e) { e.printStackTrace(); } } private void doTesting(int i) throws InterruptedException { String name = Thread.currentThread().getName(); System.out.println(name + \"开始答第\" + i + \"题\"); long thinkingTime = (long) (Math.random() * 1000); Thread.sleep(thinkingTime); System.out.println(name + \"第\" + i + \"道题答题结束\"); } } /** * * Thread-1开始答第1题 * Thread-3开始答第1题 * Thread-2开始答第1题 * Thread-4开始答第1题 * Thread-0开始答第1题 * Thread-4第1道题答题结束 * Thread-3第1道题答题结束 * Thread-0第1道题答题结束 * Thread-2第1道题答题结束 * Thread-1第1道题答题结束 * Thread-1开始答第2题 * Thread-4开始答第2题 * Thread-3开始答第2题 * Thread-2开始答第2题 * Thread-0开始答第2题 * Thread-2第2道题答题结束 * Thread-1第2道题答题结束 * Thread-4第2道题答题结束 * Thread-0第2道题答题结束 * Thread-3第2道题答题结束 * Thread-3开始答第3题 * Thread-0开始答第3题 * Thread-4开始答第3题 * Thread-1开始答第3题 * Thread-2开始答第3题 * Thread-0第3道题答题结束 * Thread-1第3道题答题结束 * Thread-4第3道题答题结束 * Thread-2第3道题答题结束 * Thread-3第3道题答题结束 * * */ ","date":"2022-02-22","objectID":"/java11/:6:5","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"6.6 Exchanger 允许在并发线程中互相交换消息 允许在2个线程中定义同步点，当两个线程都到达同步点，它们交换数据结构 Exchanger exchange(), 线程双方互相交互数据 交换数据是双向的 import java.util.Scanner; import java.util.concurrent.Exchanger; public class ExchangerExample { /** * 本例通过Exchanger实现学生成绩查询，简单线程间数据的交换 * @param args * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException { Exchanger\u003cString\u003e exchanger = new Exchanger\u003cString\u003e(); BackgroundWorker worker = new BackgroundWorker(exchanger); new Thread(worker).start(); Scanner scanner = new Scanner(System.in); while(true) { System.out.println(\"输入要查询的属性学生姓名：\"); String input = scanner.nextLine().trim(); exchanger.exchange(input); //把用户输入传递给线程 String value = exchanger.exchange(null); //拿到线程反馈结果 if (\"exit\".equals(value)) { break; } System.out.println(\"查询结果：\" + value); } scanner.close(); } } class BackgroundWorker implements Runnable { final Exchanger\u003cString\u003e exchanger; BackgroundWorker(Exchanger\u003cString\u003e exchanger) { this.exchanger = exchanger; } @Override public void run() { while (true) { try { String item = exchanger.exchange(null); switch (item) { case \"zhangsan\": exchanger.exchange(\"90\"); break; case \"lisi\": exchanger.exchange(\"80\"); break; case \"wangwu\": exchanger.exchange(\"70\"); break; case \"exit\": exchanger.exchange(\"exit\"); return; default: exchanger.exchange(\"查无此人\"); } } catch (InterruptedException e) { e.printStackTrace(); } } } } /** * * * 输入要查询的属性学生姓名： * lisi * 查询结果：80 * * */ ","date":"2022-02-22","objectID":"/java11/:6:6","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"7 Java定时任务执行 笔记 Thread/Executor/Fork-Join 多线程 立刻执行 框架调度 定时执行 固定某一个时间点运行 以某一个周期 ","date":"2022-02-22","objectID":"/java11/:7:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"7.1 简单定时器机制 设置计划任务，也就是在指定的时间开始执行某一个任务。 TimerTask 封装任务 Timer类 定时器 笔记 一个Timer对象可以执行多个计划任务，但是这些任务是串行执行的。如果有一个任务执行很慢，将会影响后续的任务准点运行。 package timer; import java.util.Calendar; import java.util.Date; import java.util.Timer; import java.util.TimerTask; public class TimerTest { public static void main(String[] args) throws InterruptedException { MyTask task = new MyTask(); Timer timer = new Timer(); System.out.println(\"当前时间：\"+new Date().toLocaleString()); //当前时间1秒后，每2秒执行一次 timer.schedule(task, 1000, 2000); Thread.sleep(10000); task.cancel(); //取消当前的任务 System.out.println(\"================================\"); Calendar now = Calendar.getInstance(); now.set(Calendar.SECOND,now.get(Calendar.SECOND)+3); Date runDate = now.getTime(); MyTask2 task2 = new MyTask2(); timer.scheduleAtFixedRate(task2,runDate,3000); //固定速率 Thread.sleep(20000); timer.cancel(); //取消定时器 } } class MyTask extends TimerTask { public void run() { System.out.println(\"运行了！时间为：\" + new Date()); } } class MyTask2 extends TimerTask { public void run() { System.out.println(\"运行了！时间为：\" + new Date()); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } } } /** * * 当前时间：2022-3-1 1:07:56 * 运行了！时间为：Tue Mar 01 01:07:57 CST 2022 * 运行了！时间为：Tue Mar 01 01:07:59 CST 2022 * 运行了！时间为：Tue Mar 01 01:08:01 CST 2022 * 运行了！时间为：Tue Mar 01 01:08:03 CST 2022 * 运行了！时间为：Tue Mar 01 01:08:05 CST 2022 * ================================ * 运行了！时间为：Tue Mar 01 01:08:09 CST 2022 * 运行了！时间为：Tue Mar 01 01:08:13 CST 2022 * 运行了！时间为：Tue Mar 01 01:08:17 CST 2022 * 运行了！时间为：Tue Mar 01 01:08:21 CST 2022 * 运行了！时间为：Tue Mar 01 01:08:25 CST 2022 * * * */ ","date":"2022-02-22","objectID":"/java11/:7:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"7.2 Executor +定时器机制 ScheduledExecutorService 定时任务 周期任务 package schedule; import java.util.Date; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class ScheduledExecutorTest { public static void main(String[] a) throws Exception { //executeAtFixTime(); //executeFixedRate(); //3s executeFixedDelay(); //4s } public static void executeAtFixTime() throws Exception { ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); executor.schedule( new MyTask(), 1, TimeUnit.SECONDS); Thread.sleep(20000); executor.shutdown(); } /** * 周期任务 固定速率 是以上一个任务开始的时间计时，period时间过去后，检测上一个任务是否执行完毕， * 如果上一个任务执行完毕，则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行。 * @throws Exception */ public static void executeFixedRate() throws Exception { ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); executor.scheduleAtFixedRate( new MyTask(), 1, 3000, TimeUnit.MILLISECONDS); Thread.sleep(20000); executor.shutdown(); } /** * 周期任务 固定延时 是以上一个任务结束时开始计时，period时间过去后，立即执行。 * @throws Exception */ public static void executeFixedDelay() throws Exception { ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); executor.scheduleWithFixedDelay( new MyTask(), 1, 3000, TimeUnit.MILLISECONDS); Thread.sleep(20000); executor.shutdown(); } } class MyTask implements Runnable { public void run() { System.out.println(\"时间为：\" + new Date()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //System.out.println(\"时间为：\" + new Date()); } } ","date":"2022-02-22","objectID":"/java11/:7:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"7.3 Quartz Quartz是一个较为完善的任务调度框架 解决程序中Timer零散管理的问题 功能更加强大 Timer执行周期任务，如果中间某一次有异常，整个任务终止执行 Quartz执行周期任务，如果中间某一次有异常，不影响下次任务执行 …… // quartz/QuartzTest.java package quartz; import org.quartz.JobDetail; import org.quartz.Scheduler; import org.quartz.Trigger; import org.quartz.impl.StdSchedulerFactory; import static org.quartz.JobBuilder.newJob; import static org.quartz.SimpleScheduleBuilder.simpleSchedule; import static org.quartz.TriggerBuilder.newTrigger; public class QuartzTest { public static void main(String[] args) { try { //创建scheduler Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); //定义一个Trigger Trigger trigger = newTrigger().withIdentity(\"trigger1\", \"group1\") //定义name/group .startNow()//一旦加入scheduler，立即生效 .withSchedule(simpleSchedule() //使用SimpleTrigger .withIntervalInSeconds(2) //每隔2秒执行一次 .repeatForever()) //一直执行 .build(); //定义一个JobDetail JobDetail job = newJob(HelloJob.class) //定义Job类为HelloQuartz类 .withIdentity(\"job1\", \"group1\") //定义name/group .usingJobData(\"name\", \"quartz\") //定义属性 .build(); //加入这个调度 scheduler.scheduleJob(job, trigger); //启动 scheduler.start(); //运行一段时间后关闭 Thread.sleep(10000); scheduler.shutdown(true); } catch (Exception e) { e.printStackTrace(); } } } // quartz/HelloJob.java package quartz; import org.quartz.Job; import org.quartz.JobDetail; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; import java.util.Date; public class HelloJob implements Job { public void execute(JobExecutionContext context) throws JobExecutionException { JobDetail detail = context.getJobDetail(); String name = detail.getJobDataMap().getString(\"name\"); System.out.println(\"hello from \" + name + \" at \" + new Date()); } } /** * * * hello from name at Tue Mar 01 01:34:57 CST 2022 * hello from name at Tue Mar 01 01:34:59 CST 2022 * hello from name at Tue Mar 01 01:35:01 CST 2022 * hello from name at Tue Mar 01 01:35:03 CST 2022 * hello from name at Tue Mar 01 01:35:05 CST 2022 * * */ ","date":"2022-02-22","objectID":"/java11/:7:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java并发编程","uri":"/java11/"},{"categories":["Java"],"content":"[Java核心技术] Java多线程","date":"2022-02-20","objectID":"/java10/","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"Java 核心技术读书笔记——Java多线程 ","date":"2022-02-20","objectID":"/java10/:0:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"1 多进程和多线程简介 简介 当前的操作系统都是多任务OS 每个独立执行的任务就是一个进程 OS将时间划分为多个时间片（时间很短） 每个时间片内将CPU分配给每一个任务，时间片结束，CPU将自动回收，再分配给另外的任务 ","date":"2022-02-20","objectID":"/java10/:1:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"1.1 多进程优点 可以同时运行多个任务 程序因为IO堵塞时，可以释放CPU，让CPU为其他程序服务 当系统有多个CPU时，可以为多个进程同时服务 当前CPU不再提高频率，而是提高核数 ","date":"2022-02-20","objectID":"/java10/:1:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"1.2 多进程缺点 太笨重，不好管理 太笨重，不好切换 ","date":"2022-02-20","objectID":"/java10/:1:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"1.3 多线程概念 一个程序可以包括多个子任务，可串/并行 每个子任务可以称为一个线程 如果一个子任务阻塞，程序可以将CPU调度另外一个子任务进行工作。这样CPU还是保留在本程序中，而不是调度到别的程序（进程）去。提高本程序所获得CPU时间和利用率。 ","date":"2022-02-20","objectID":"/java10/:1:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"1.4 多进程VS多线程 线程共享数据 线程通讯更高效 线程更轻量级，更容易切换 多个线程更容易管理 多进程实例 public class ProcessDemo1 { public static void main(String[] args) { while(true) { int a = (int) (Math.random() * 100); System.out.println(\" main thread is running \" + a); try { Thread.sleep(5000); //5000毫秒 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } 多线程实例 public class ThreadDemo1 { public static void main(String args[]) throws Exception { new TestThread1().start(); while(true) { System.out.println(\"main thread is running\"); Thread.sleep(1000); } } } class TestThread1 extends Thread { public void run() { while(true) { System.out.println(\" TestThread1 is running\"); try { Thread.sleep(1000); //1000毫秒 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } ","date":"2022-02-20","objectID":"/java10/:1:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"2 Java多线程实现 ","date":"2022-02-20","objectID":"/java10/:2:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"2.1 多线程创建 方法一 java.lang.Thread 线程继承Thread类，实现run方法 public class Thread1 extends Thread{ public void run() { System.out.println(\"hello\"); } public static void main(String[] a) { new Thread1().start(); } } 方法二 java.lang.Runnable接口 线程实现Runnable接口，实现run方法 public class Thread2 implements Runnable{ public void run() { System.out.println(\"hello\"); } public static void main(String[] a) { new Thread(new Thread2()).start(); } } Thread vs Runnable Thread占据了父类名额，不如Runnable方便 Thread类实现Runnable Runnable启动时需要Thread类的支持 Runnable更容易实现多线程中的资源共享 结论：建议实现Runnable接口来完成多线程 ","date":"2022-02-20","objectID":"/java10/:2:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"2.2 启动 start方法，会自动以新进程调用run方法，将会是并行运行（多线程运行） public class ThreadDemo1 { public static void main(String args[]) throws Exception { new TestThread1().start(); while(true) { System.out.println(\"main thread is running\"); Thread.sleep(1000); } } } class TestThread1 extends Thread { public void run() { while(true) { System.out.println(\" TestThread1 is running\"); try { Thread.sleep(1000); //1000毫秒 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } /** * * TestThread1 is running * main thread is running * TestThread1 is running * main thread is running * main thread is running * TestThread1 is running * ... * */ 直接调用run方法，将变成串行执行 public class ThreadDemo0 { public static void main(String args[]) throws Exception { new TestThread0().run(); while(true) { System.out.println(\"main thread is running\"); Thread.sleep(10); } } } class TestThread0 { public void run() { while(true) { System.out.println(\" TestThread1 is running\"); try { Thread.sleep(1000); //1000毫秒 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } /** * TestThread1 is running * TestThread1 is running * TestThread1 is running * ... * */ 同一个线程，多次start会报错，只执行第一次start方法，多个线程启动，其启动的先后顺序是随机的，由JVM/操作系统来主导 public class ThreadDemo4 { public static void main(String [] args) { TestThread4 t=new TestThread4(); t.start(); //t.start(); //t.start(); //t.start(); TestThread4 t1=new TestThread4(); t1.start(); } } class TestThread4 extends Thread { public void run() { while(true) { System.out.println(Thread.currentThread().getName() + \" is running\"); try { Thread.sleep(1000); //1000毫秒 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } /** * * Thread-1 is running * Thread-0 is running * Thread-1 is running * Thread-0 is running * Thread-1 is running * Thread-1 is running * Thread-0 is running * ... * */ 线程无需关闭，只要其run方法执行结束后，自动关闭 main函数（线程）可能早于新线程结束，整个程序并不终止，整个程序终止是等所有的线程都终止（包括main函数线程） public class ThreadDemo2 { public static void main(String args[]) throws InterruptedException { new TestThread2().start(); } } class TestThread2 extends Thread { public void run() { while(true) { System.out.println(\"TestThread2 is running\"); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } /** * TestThread2 is running * TestThread2 is running * TestThread2 is running * ... * */ 实现Runnable的对象必须包装在Thread类里面，才可以启动，不可以直接对Runnable的对象进行start方法 public class ThreadDemo3 { public static void main(String args[]) { //new TestThread3().start(); //Runnable对象必须放在一个Thread类中才能运行 TestThread3 tt= new TestThread3();//创建TestThread类的一个实例 Thread t= new Thread(tt);//创建一个Thread类的实例 t.start();//使线程进入Runnable状态 while(true) { System.out.println(\"main thread is running\"); try { Thread.sleep(1000); //1000毫秒 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } class TestThread3 implements Runnable //extends Thread { //线程的代码段，当执行start()时，线程从此出开始执行 public void run() { while(true) { System.out.println(Thread.currentThread().getName() + \" is running\"); try { Thread.sleep(1000); //1000毫秒 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } ","date":"2022-02-20","objectID":"/java10/:2:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"3 Java多线程信息共享 粗粒度：子线程与子线程之间、和main线程之间缺乏交流 细粒度：线程之间有信息交流通讯 通过共享变量达到信息共享 JDK原生库暂不支持发送消息 ","date":"2022-02-20","objectID":"/java10/:3:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"3.1 通过共享变量在多个线程中共享消息 static变量 同一个Runaable类的成员变量 public class ThreadDemo0 { public static void main(String [] args) { new TestThread0().start(); new TestThread0().start(); new TestThread0().start(); new TestThread0().start(); } } class TestThread0 extends Thread { //private int tickets=100; //每个线程卖100张，没有共享 private static int tickets=100; //static变量是共享的，所有的线程共享 public void run() { while(true) { if(tickets\u003e0) { System.out.println(Thread.currentThread().getName() + \" is selling ticket \" + tickets); tickets = tickets - 1; } else { break; } } } } /** * * * Thread-0 is selling ticket 100 * Thread-0 is selling ticket 99 * Thread-0 is selling ticket 98 * Thread-0 is selling ticket 97 * Thread-0 is selling ticket 96 * Thread-0 is selling ticket 95 * Thread-3 is selling ticket 100 * Thread-2 is selling ticket 100 * Thread-1 is selling ticket 100 * Thread-1 is selling ticket 91 * Thread-1 is selling ticket 90 * Thread-1 is selling ticket 89 * Thread-1 is selling ticket 88 * ... * */ ","date":"2022-02-20","objectID":"/java10/:3:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"3.2 多线程信息共享问题 工作缓存副本 关键步骤缺乏加锁限制 i++，并非原子性操作 读取 主存i（正本） 到 工作缓存（副本） 中 每个CPU执行 （副本） i+1操作 CPU将结果写入到 缓存（副本） 中 数据从 工作缓存（副本） 刷到 主存（正本） 中 Java多线程内存模型Java多线程内存模型 \" Java多线程内存模型 变量副本问题解决办法 采用volatile关键字修饰变量 保证不同线程对共享变量操作时的可见性 public class ThreadDemo2 { public static void main(String args[]) throws Exception { TestThread2 t = new TestThread2(); t.start(); Thread.sleep(2000); t.flag = false; System.out.println(\"main thread is exiting\"); } } class TestThread2 extends Thread { //boolean flag = true; //结果1：子线程不会停止 volatile boolean flag = true; //结果2：用volatile修饰的变量可以及时在各线程里面通知 public void run() { int i=0; while(flag) { i++; } System.out.println(\"test thread3 is exiting\"); } } /** * * 结果1： * main thread is exiting * * 结果2： * main thread is exiting * test thread3 is exiting * * */ 关键步骤加锁限制 关键步骤加锁限制 互斥：某一个线程运行一个代码段(关键区)，其他线程不能同时运行这个代码段 同步：多个线程的运行，必须按照某一种规定的先后顺序来运行 互斥是同步的一种特例 互斥的关键字是synchronized synchronized代码块/函数，只能一个线程进入 synchronized加大性能负担，但是使用简便 public class ThreadDemo3 { public static void main(String[] args) { TestThread3 t = new TestThread3(); new Thread(t, \"Thread-0\").start(); new Thread(t, \"Thread-1\").start(); new Thread(t, \"Thread-2\").start(); new Thread(t, \"Thread-3\").start(); } } class TestThread3 implements Runnable { private volatile int tickets = 100; // 多个 线程在共享的 String str = new String(\"\"); public void run() { while (true) { sale(); try { Thread.sleep(100); } catch (Exception e) { System.out.println(e.getMessage()); } if (tickets \u003c= 0) { break; } } } public synchronized void sale() { // 同步函数 if (tickets \u003e 0) { System.out.println(Thread.currentThread().getName() + \" is saling ticket \" + tickets--); } } } /** * * Thread-0 is saling ticket 100 * Thread-3 is saling ticket 99 * Thread-2 is saling ticket 98 * Thread-1 is saling ticket 97 * Thread-3 is saling ticket 96 * Thread-0 is saling ticket 95 * Thread-2 is saling ticket 94 * Thread-1 is saling ticket 93 * Thread-0 is saling ticket 92 * ... * * */ ","date":"2022-02-20","objectID":"/java10/:3:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"4 Java多线程管理 ","date":"2022-02-20","objectID":"/java10/:4:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"4.1 线程状态 NEW 刚创建(new) RUNNABLE 就绪态(start) RUNNING 运行中(run) BLOCK 阻塞(sleep) TERMINATED 结束 Java线程状态图Java线程状态图 \" Java线程状态图 ","date":"2022-02-20","objectID":"/java10/:4:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"4.2 线程的方法 Thread的部分API已经废弃（不建议使用） 暂停和恢复 suspend/resume 消亡 stop/destroy 线程阻塞/和唤醒 sleep，时间一到，自己会醒来 wait/notify/notifyAll，等待，需要别人来唤醒 join，等待另外一个线程结束 interrupt，向另外一个线程发送中断信号，该线程收到信号，会触发InterruptedException(可解除阻塞)，并进行下一步处理 // product/ProductTest.java package product; /** * 经典生产者与消费者问题 * 生产者不断的往仓库中存放产品，消费者从仓库中消费产品。 * 其中生产者和消费者都可以有若干个。 * 仓库规则：容量有限，库满时不能存放，库空时不能取产品 。 */ public class ProductTest { public static void main(String[] args) throws InterruptedException { Storage storage = new Storage(); Thread consumer1 = new Thread(new Consumer(storage)); consumer1.setName(\"消费者1\"); Thread consumer2 = new Thread(new Consumer(storage)); consumer2.setName(\"消费者2\"); Thread producer1 = new Thread(new Producer(storage)); producer1.setName(\"生产者1\"); Thread producer2 = new Thread(new Producer(storage)); producer2.setName(\"生产者2\"); producer1.start(); producer2.start(); Thread.sleep(1000); consumer1.start(); consumer2.start(); } } /** * * * 生产者2 生产了产品(产品ID：1 产品名称：电话51) * producer notifyAll * 生产者1 生产了产品(产品ID：1 产品名称：电话39) * producer notifyAll * 生产者2 生产了产品(产品ID：2 产品名称：电话59) * producer notifyAll * producer wait * producer wait * 消费者1 消费了产品(产品ID：2 产品名称：电话59) * comsumer notifyAll * 生产者1 生产了产品(产品ID：2 产品名称：电话58) * producer notifyAll * producer wait * producer wait * ... * * */ // product/Storage.java package product; /** *仓库 */ class Storage { // 仓库容量为3 private Product[] products = new Product[3]; private int top = 0; // 生产者往仓库中放入产品 public synchronized void push(Product product) { while (top == products.length) { try { System.out.println(\"producer wait\"); wait();//仓库已满，等待 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } //把产品放入仓库 products[top++] = product; System.out.println(Thread.currentThread().getName() + \" 生产了产品\" + product); System.out.println(\"producer notifyAll\"); notifyAll();//唤醒等待线程 } // 消费者从仓库中取出产品 public synchronized Product pop() { while (top == 0) { try { System.out.println(\"consumer wait\"); wait();//仓库空，等待 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } //从仓库中取产品 --top; Product p = new Product(products[top].getId(), products[top].getName()); products[top] = null; System.out.println(Thread.currentThread().getName() + \" 消费了产品\" + p); System.out.println(\"comsumer notifyAll\"); notifyAll();//唤醒等待线程 return p; } } // product/Producer.java package product; import java.util.Random; /** * 生产者 */ class Producer implements Runnable { private Storage storage; public Producer(Storage storage) { this.storage = storage; } @Override public void run() { int i = 0; Random r = new Random(); while(i\u003c10) { i++; Product product = new Product(i, \"电话\" + r.nextInt(100)); storage.push(product); } } } // product/Product.java package product; /** * 产品类 */ class Product { private int id;// 产品id private String name;// 产品名称 public Product(int id, String name) { this.id = id; this.name = name; } public String toString() { return \"(产品ID：\" + id + \" 产品名称：\" + name + \")\"; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } ","date":"2022-02-20","objectID":"/java10/:4:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"4.3 线程暂停和终止 线程被动暂停和终止 依靠别的线程来拯救自己 没有及时释放资源 package interrupt; public class InterruptTest { public static void main(String[] args) throws InterruptedException { TestThread1 t1 = new TestThread1(); t1.start(); // 让线程运行一会儿后中断 Thread.sleep(2000); t1.interrupt(); System.out.println(\"main thread is exiting\"); } } class TestThread1 extends Thread { public void run() { // 判断标志，当本线程被别人interrupt后，JVM会被本线程设置interrupted标记 while (!interrupted()) { System.out.println(\"test thread1 is running\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); break; } } System.out.println(\"test thread1 is exiting\"); } } /** * * test thread1 is running * test thread1 is running * test thread1 is running * main thread is exiting * test thread1 is exiting * java.lang.InterruptedException: sleep interrupted * at java.lang.Thread.sleep(Native Method) * at interupt.TestThread1.run(InterruptTest.java:24) * * * */ 线程主动暂停和终止 定期监测共享变量 如果需要暂停或者终止，先释放资源，再主动动作 暂停：Thread.sleep()，休眠 终止：run方法结束，线程终止 笔记 interrupted()是Tread类的方法，用来测试当前线程是否收到一个INTERRUPT的信号。收到返回true，否则返回false package interrupt; public class InterruptTest { public static void main(String[] args) throws InterruptedException { TestThread2 t2 = new TestThread2(); t2.start(); // 让线程运行一会儿后中断 Thread.sleep(2000); t2.flag = false; System.out.println(\"main thread is exiting\"); } } class TestThread2 extends Thread { public volatile boolean flag = true; public void run() { // 判断标志，当本线程被别人interrupt后，JVM会被本线程设置interrupted标记 while (flag) { System.out.println(\"test thread2 is running\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"test thread2 is exiting\"); } } /** * * main thread is exiting * test thread2 is exiting * * */ ","date":"2022-02-20","objectID":"/java10/:4:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"4.4 多线程死锁 每个线程互相持有别人需要的锁(哲学家吃面问题) 预防死锁，对资源进行等级排序 笔记 TimeUnit是 JDK5 引入的新类，位于java.util.concurrent包中。 它提供了单位时间粒度和一些时间转换、计时和延迟等函数 线程查看工具 jvisualvm ThreadDemo5程序死锁图示01jvisualvm \" ThreadDemo5程序死锁图示01 ThreadDemo5程序死锁图示02jvisualvm \" ThreadDemo5程序死锁图示02 package deadlock; import java.util.concurrent.TimeUnit; public class ThreadDemo5 { public static Integer r1 = 1; public static Integer r2 = 2; public static void main(String args[]) throws InterruptedException { TestThread51 t1 = new TestThread51(); t1.start(); TestThread52 t2 = new TestThread52(); t2.start(); } } class TestThread51 extends Thread { public void run() { //先要r1,再要r2 synchronized(ThreadDemo5.r1) //程序卡在此句，希望取得r1 { try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } synchronized(ThreadDemo5.r2) { System.out.println(\"TestThread51 is running\"); } } } } class TestThread52 extends Thread { public void run() { //先要r2,再要r1 synchronized(ThreadDemo5.r2) //程序卡在此句，希望取得r2 { try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } synchronized(ThreadDemo5.r1) { System.out.println(\"TestThread52 is running\"); } } } } ","date":"2022-02-20","objectID":"/java10/:4:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"4.5 守护(后台)线程 普通线程的结束，是run方法运行结束 守护线程的结束，是run方法运行结束或 main函数结束 守护线程永远不要访问资源，如文件或数据库等 package daemon; public class ThreadDemo4 { public static void main(String args[]) throws InterruptedException { TestThread4 t = new TestThread4(); t.setDaemon(true); t.start(); Thread.sleep(2000); System.out.println(\"main thread is exiting\"); } } class TestThread4 extends Thread { public void run() { while(true) { System.out.println(\"TestThread4\" + \"　is running\"); try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } /** * * TestThread4 is running * TestThread4 is running * TestThread4 is running * main thread is exiting * */ ","date":"2022-02-20","objectID":"/java10/:4:5","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java多线程","uri":"/java10/"},{"categories":["Java"],"content":"[Java核心技术] Java数据结构","date":"2022-02-17","objectID":"/java08/","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"Java 核心技术读书笔记——Java数据结构 ","date":"2022-02-17","objectID":"/java08/:0:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"1 数组 数组是一个存放多个数据的容器 数据是同一种类型 所有的数据是线性规则排列 可通过位置索引来快速定位访问数据 需明确容器长度 ","date":"2022-02-17","objectID":"/java08/:1:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"1.1 定义和初始化 public class ArrayTest { public static void main(String[] args) { int a[]; //a 还没有new操作 实际上是null，也不知道内存位置 int[] b; //b 还没有new操作 实际上是null，也不知道内存位置 int[] c = new int[2]; //c有2个元素，都是0 c[0] = 10; c[1] = 20; //逐个初始化 int d[] = new int[]{0,2,4};//d有3个元素, 0,2,4，同时定义和初始化 int d1[] = {1,3,5}; //d1有3个元素, 1,3,5 同时定义和初始化 //注意声明变量时候没有分配内存，不需要指定大小，以下是错误示例 //int e[5]; //int[5] f; //int[5] g = new int[5]; //int h[5] = new int[5]; } } ","date":"2022-02-17","objectID":"/java08/:1:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"1.2 数组索引 数组的length属性标识数组的长度 从0开始，到length-1 数组不能越界访问，否则会报ArrayIndexOutBoundsException异常 ","date":"2022-02-17","objectID":"/java08/:1:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"1.3 数组遍历 需要自己控制索引位置 //需要自己控制索引位置 for(int i=0;i\u003cd.length;i++) { System.out.println(d[i]); } 无需控制索引位置 //无需控制索引位置 for(int e : d) { System.out.println(e); } ","date":"2022-02-17","objectID":"/java08/:1:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"1.4 多维数组 数组的数组 存储是按照行存储原则 规则数组 int a[][] = new int[2][3]; 不规则数组 int b[][]; b = new int[3][]; b[0]=new int[3]; b[1]=new int[4]; b[2]=new int[5]; 遍历 int k = 0; for(int i=0;i\u003ca.length;i++) { for(int j=0;j\u003ca[i].length;j++) { a[i][j] = ++k; } } for(int[] items : a) { for(int item : items) { System.out.print(item + \", \"); } System.out.println(); } ","date":"2022-02-17","objectID":"/java08/:1:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"2 JCF(Java Collection Framework) 容器：能够存放数据的空间结构 数组/多维数组，只能线性存放 列表/散列集/树/…… 容器框架：为表示和操作容器而规定的一种标准体系结构 对外的接口：容器中所能存放的抽象数据类型 接口的实现：可复用的数据结构 算法：对数据的查找和排序 容器框架的优点：提高数据存取效率，避免程序员重复劳动 JCF的集合接口是Collection add 增加； contains 包含； remove 删除； size 数据元素个数； iterator 迭代器； JCF的迭代器接口Iterator hasNext 判断是否有下一个元素； next 获取下一个元素； remove 删除某一个元素； JCF主要的数据结构实现类 列表（List，ArrayList，LinkedList） 集合（Set，HashSet，TreeSet，LinkedHashSet） 映射（Map，HashMap，TreeMap，LinkedHashMap） JCF主要的算法类 Arrays：对数组进行查找和排序等操作 Collections：对Collection及其子类进行排序和查找操作 ","date":"2022-02-17","objectID":"/java08/:2:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"3 List List：列表 有序的Collection 允许重复元素 {1,2,4,{5,2},1,3} List主要实现 ArrayList（非同步的） LinkedList（非同步） Vector（同步） ","date":"2022-02-17","objectID":"/java08/:3:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"3.1 ArrayList 以数组实现的列表，不支持同步 利用索引位置可以快速定位访问 不适合指定位置的插入、删除操作 适合变动不大，主要用于查询的数据 和Java数组相比，其容量是可动态调整的 ArrayList在元素填满容器时会自动扩充容器大小的50% ArrayList只能装对象，当add(3)时，会自动将普通int变量3自动装箱为Integer(3)的对象，然后放入ArrayList容器中。 声明和初始化 import java.util.ArrayList; ArrayList\u003cInteger\u003e al = new ArrayList\u003cInteger\u003e(); add al.add(3); al.add(new Integer(6)); al.add(2, 9); //将9插入到第4个元素，后面元素往后挪动 remove al.remove(3); //删除第四个元素，后面元素往前挪动 遍历 import java.util.ArrayList; import java.util.Iterator; public static void traverseByIterator(ArrayList\u003cInteger\u003e al) { System.out.println(\"============迭代器遍历==============\"); //慢 Iterator\u003cInteger\u003e iter1 = al.iterator(); while(iter1.hasNext()){ System.out.println(iter1.next()); } } public static void traverseByIndex(ArrayList\u003cInteger\u003e al) { System.out.println(\"============随机索引值遍历==============\"); //中 for(int i=0;i\u003cal.size();i++) { System.out.println(al.get(i)); } } public static void traverseByFor(ArrayList\u003cInteger\u003e al) { System.out.println(\"============for循环遍历==============\"); //快 for(Integer item : al) { System.out.println(item); } } ","date":"2022-02-17","objectID":"/java08/:3:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"3.2 LinkedList 以双向链表实现的列表，不支持同步 可被当作堆栈、队列、和双端队列进行操作 顺序访问高效，随机访问较差，中间插入和删除高效 适用于经常变化的数据 声明和初始化 import java.util.LinkedList; LinkedList\u003cInteger\u003e ll = new LinkedList\u003cInteger\u003e(); add ll.add(3); ll.add(2); ll.add(5); ll.add(6); ll.add(6); ll.addFirst(9); //在头部增加9 ll.add(3, 10); //将10插入到第四个元素，四以及后续的元素往后挪动 remove ll.remove(3); //将第四个元素删除 遍历 import java.util.ArrayList; import java.util.Iterator; import java.util.LinkedList; public static void traverseByIterator(LinkedList\u003cInteger\u003e list) { System.out.println(\"============迭代器遍历==============\"); //中 Iterator\u003cInteger\u003e iter1 = list.iterator(); while(iter1.hasNext()){ System.out.println(iter1.next()); } } public static void traverseByIndex(LinkedList\u003cInteger\u003e list) { System.out.println(\"============随机索引值遍历==============\"); //慢 for(int i=0;i\u003clist.size();i++) { System.out.println(list.get(i)); } } public static void traverseByFor(LinkedList\u003cInteger\u003e list) { System.out.println(\"============for循环遍历==============\"); //快 for(Integer item : list) { System.out.println(item); } } ","date":"2022-02-17","objectID":"/java08/:3:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"ArrayList与LinkedList对比 import java.util.ArrayList; import java.util.LinkedList; public class ListCompareTest { public static void main(String[] args) { int times = 10 * 1000; // times = 100 * 1000; // times = 1000 * 1000; ArrayList\u003cInteger\u003e arrayList = new ArrayList\u003cInteger\u003e(); LinkedList\u003cInteger\u003e linkedList = new LinkedList\u003cInteger\u003e(); System.out.println(\"Test times = \" + times); System.out.println(\"-------------------------\"); // ArrayList add long startTime = System.nanoTime(); for (int i = 0; i \u003c times; i++) { arrayList.add(0,i); } long endTime = System.nanoTime(); long duration = endTime - startTime; System.out.println(duration + \" \u003c--ArrayList add\"); // LinkedList add startTime = System.nanoTime(); for (int i = 0; i \u003c times; i++) { linkedList.add(0,i); } endTime = System.nanoTime(); duration = endTime - startTime; System.out.println(duration + \" \u003c--LinkedList add\"); System.out.println(\"-------------------------\"); // ArrayList get startTime = System.nanoTime(); for (int i = 0; i \u003c times; i++) { arrayList.get(i); } endTime = System.nanoTime(); duration = endTime - startTime; System.out.println(duration + \" \u003c--ArrayList get\"); // LinkedList get startTime = System.nanoTime(); for (int i = 0; i \u003c times; i++) { linkedList.get(i); } endTime = System.nanoTime(); duration = endTime - startTime; System.out.println(duration + \" \u003c--LinkedList get\"); System.out.println(\"-------------------------\"); // ArrayList remove startTime = System.nanoTime(); for (int i = 0; i \u003c times; i++) { arrayList.remove(0); } endTime = System.nanoTime(); duration = endTime - startTime; System.out.println(duration + \" \u003c--ArrayList remove\"); // LinkedList remove startTime = System.nanoTime(); for (int i = 0; i \u003c times; i++) { linkedList.remove(0); } endTime = System.nanoTime(); duration = endTime - startTime; System.out.println(duration + \" \u003c--LinkedList remove\"); } } /** * * 输出结果 * Test times = 10000 * ------------------------- * 3857300 \u003c--ArrayList add * 848700 \u003c--LinkedList add * ------------------------- * 363100 \u003c--ArrayList get * 32779501 \u003c--LinkedList get * ------------------------- * 3671900 \u003c--ArrayList remove * 495300 \u003c--LinkedList remove * * */ 由以上代码可知 LinkedList 使用于频繁增删的数据 ArrayList适用于查询的（静态）数据 ","date":"2022-02-17","objectID":"/java08/:3:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"3.3 Vector 和ArrayList一样，可变数组实现的列表 Vector同步，适合在多线程下使用 官方文档建议，在非同步情况下，优先采用ArrayList 声明和初始化 import java.util.Vector; Vector\u003cInteger\u003e v = new Vector\u003cInteger\u003e(); add v.add(1); v.add(2); v.add(3); v.add(1, 5); remove v.remove(2); 遍历 import java.util.Iterator; import java.util.Vector; public static void traverseByIterator(Vector\u003cInteger\u003e v) { System.out.println(\"============迭代器遍历==============\"); //最慢 Iterator\u003cInteger\u003e iter1 = v.iterator(); while (iter1.hasNext()) { System.out.println(iter1.next()); } } public static void traverseByIndex(Vector\u003cInteger\u003e v) { System.out.println(\"============随机索引值遍历==============\"); //较快 for (int i = 0; i \u003c v.size(); i++) { System.out.println(v.get(i)); } } public static void traverseByFor(Vector\u003cInteger\u003e v) { System.out.println(\"============for循环遍历==============\"); //最快 for (Integer item : v) { System.out.println(item); } } public static void traverseByEnumeration(Vector\u003cInteger\u003e v) { System.out.println(\"============Enumeration遍历==============\");//较慢 for (Enumeration\u003cInteger\u003e enu = v.elements(); enu.hasMoreElements();) { enu.nextElement(); } } ","date":"2022-02-17","objectID":"/java08/:3:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"4 集合Set 确定性：对任意对象都能判定其是否属于某一个集合 互异性：集合内每个元素都是不相同的，注意是内同互异 无序性：集合内的顺序无关 ","date":"2022-02-17","objectID":"/java08/:4:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"4.1 Java中的集合接口Set HashSet：基于散列函数的集合，无序，不支持同步 TreeSet：基于树结构的集合，可排序的，不支持同步 LinkedHashSet：基于散列函数和双向链表的集合，可排序的，不支持同步 ","date":"2022-02-17","objectID":"/java08/:4:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"4.2 HashSet 基于HashMap实现的，可以容纳null元素，不支持同步 将不同步的HashSet变为同步的HashSet Set s = Collections.synchronizedSet(new HashSet(...)); 声明和初始化 import java.util.HashSet; HashSet\u003cInteger\u003e hs = new HashSet\u003cInteger\u003e(); add 添加一个元素 hs.add(null); hs.add(1000); hs.add(20); hs.add(3); hs.add(40000); hs.add(5000000); hs.add(3); //3 重复 hs.add(null); clear 清除整个HashSet hs.clear(); contains 判定是否包含一个元素 if(!hs.contains(6)) { hs.add(6); } remove 删除一个元素 hs.remove(4); size 大小 hs.size(); retainAll 计算两个集合交集 System.out.println(\"============测试集合交集==============\"); HashSet\u003cString\u003e set1 = new HashSet\u003cString\u003e(); HashSet\u003cString\u003e set2 = new HashSet\u003cString\u003e(); set1.add(\"a\"); set1.add(\"b\"); set1.add(\"c\"); set2.add(\"c\"); set2.add(\"d\"); set2.add(\"e\"); //交集 set1.retainAll(set2); System.out.println(\"交集是 \"+set1); 遍历 import java.util.ArrayList; import java.util.HashSet; import java.util.Iterator; public static void traverseByIterator(HashSet\u003cInteger\u003e hs) { System.out.println(\"============迭代器遍历==============\"); Iterator\u003cInteger\u003e iter1 = hs.iterator(); while(iter1.hasNext()){ System.out.println(iter1.next()); } } public static void traverseByFor(HashSet\u003cInteger\u003e hs) { System.out.println(\"============for循环遍历==============\"); for(Integer item : hs) { System.out.println(item); } } ","date":"2022-02-17","objectID":"/java08/:4:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"4.3 TreeSet 基于TreeMap实现，不可以容纳null元素，不支持同步 将不同步的TreeSet变为同步的TreeSet SortedSet s = Collections.synchronizedSortrfSet(new TreeSet(...)); 根据CompareTo方法或指定Comparator排序 声明和初始化 import java.util.TreeSet; TreeSet\u003cInteger\u003e ts = new TreeSet\u003cInteger\u003e(); add 添加一个元素 // ts.add(null); 错误，不支持null ts.add(1000); ts.add(20); ts.add(3); ts.add(40000); ts.add(5000000); ts.add(3); //3 重复 clear 清除整个TreeSet ts.clear(); contains 判定是否包含一个元素 if(!ts.contains(6)) { ts.add(6); } remove 删除一个元素 ts.remove(4); size 大小 ts.size(); 遍历 import java.util.Iterator; import java.util.TreeSet; public static void traverseByIterator(TreeSet\u003cInteger\u003e hs) { System.out.println(\"============迭代器遍历==============\"); Iterator\u003cInteger\u003e iter1 = hs.iterator(); while(iter1.hasNext()){ System.out.println(iter1.next()); } } public static void traverseByFor(TreeSet\u003cInteger\u003e hs) { System.out.println(\"============for循环遍历==============\"); for(Integer item : hs) { System.out.println(item); } } ","date":"2022-02-17","objectID":"/java08/:4:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"4.4 LinkedHashSet 基于HashMap实现的，可以容纳null元素，不支持同步 将不同步的LinkedHashSet变为同步的LinkedHashSet Set s = Collections.synchronizedSet(new LinkedHashSet(...)); 方法和HashSet基本一致 通过一个双向链表维护插入顺序 声明和初始化 import java.util.LinkedHashSet; LinkedHashSet\u003cInteger\u003e lhs = new LinkedHashSet\u003cInteger\u003e(); add lhs.add(null); lhs.add(1000); lhs.add(20); lhs.add(3); lhs.add(40000); lhs.add(5000000); lhs.add(3); //3 重复 lhs.add(null); //null 重复 remove lhs.remove(4); clear lhs.clear(); contains if(!lhs.contains(6)) { lhs.add(6); } size lhs.size(); 遍历 import java.util.Iterator; import java.util.LinkedHashSet; public static void traverseByIterator(LinkedHashSet\u003cInteger\u003e hs) { System.out.println(\"============迭代器遍历==============\"); Iterator\u003cInteger\u003e iter1 = hs.iterator(); while(iter1.hasNext()){ System.out.println(iter1.next()); } } public static void traverseByFor(LinkedHashSet\u003cInteger\u003e hs) { System.out.println(\"============for循环遍历==============\"); for(Integer item : hs) { System.out.println(item); } } ","date":"2022-02-17","objectID":"/java08/:4:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"4.5 异同点 HashSet，LinkedHashSet，TreeSet的元素都只能是对象 HashSet和LinkedHashSet判定元素重复的原则 判定两个元素的hashCode返回值是否相同，若不同，返回false 若两者hashCode相同，判定equals方法，若不同，返回false；否则返回true hashCode和equals方法是所有类都有的，因为Object类有 // Cat.java class Cat { private int size; public Cat(int size) { this.size = size; } } // Dog.java class Dog { private int size; public Dog(int s) { size = s; } public int getSize() { return size; } /** * * 这三个方法三位一体， * equals()是相同的； * hashCode()是相同的； * toString()也应该相同； * */ public boolean equals(Object obj2) { System.out.println(\"Dog equals()~~~~~~~~~~~\"); if(0==size - ((Dog) obj2).getSize()) { return true; } else { return false; } } public int hashCode() { System.out.println(\"Dog hashCode()~~~~~~~~~~~\"); return size; } public String toString() { System.out.print(\"Dog toString()~~~~~~~~~~~\"); return size + \"\"; } } //Tiger.java public class Tiger implements Comparable{ private int size; public Tiger(int s) { size = s; } public int getSize() { return size; } public int compareTo(Object o) { System.out.println(\"Tiger compareTo()~~~~~~~~~~~\"); return size - ((Tiger) o).getSize(); } } // ObjectHashSetTest.java import java.util.HashSet; import java.util.Iterator; import java.util.LinkedHashSet; import java.util.TreeSet; public class ObjectHashSetTest { public static void main(String[] args) { /** * * Cat类本身没有hashCode(),而是继承Object类的， * 而Object类的hashCode()会返回对象信息和内存地址经过运算的一个int值 * 两个Cat(4)对象，它们的hashCode()返回值是不同的。 * */ System.out.println(\"==========Cat HashSet ==============\"); HashSet\u003cCat\u003e hs = new HashSet\u003cCat\u003e(); hs.add(new Cat(2)); hs.add(new Cat(1)); hs.add(new Cat(3)); hs.add(new Cat(5)); hs.add(new Cat(4)); hs.add(new Cat(4)); System.out.println(hs.size()); //6 System.out.println(\"========================\"); LinkedHashSet\u003cCat\u003e lhs= new LinkedHashSet\u003cCat\u003e(); lhs.add(new Cat(2)); lhs.add(new Cat(1)); lhs.add(new Cat(3)); lhs.add(new Cat(5)); lhs.add(new Cat(4)); lhs.add(new Cat(4)); System.out.println(lhs.size()); //6 /** * * Dog类本身改写了hashCode()方法，子返回值是具体的size。 * 所以两个不同Dog(4)，它们的hashCode()返回值是相同的。 * */ System.out.println(\"==========Dog HashSet ==============\"); HashSet\u003cDog\u003e hs2 = new HashSet\u003cDog\u003e(); hs2.add(new Dog(2)); hs2.add(new Dog(1)); hs2.add(new Dog(3)); hs2.add(new Dog(5)); hs2.add(new Dog(4)); hs2.add(new Dog(4)); System.out.println(hs2.size()); //5 System.out.println(\"========================\"); LinkedHashSet\u003cDog\u003e lhs2= new LinkedHashSet\u003cDog\u003e(); lhs2.add(new Dog(2)); lhs2.add(new Dog(1)); lhs2.add(new Dog(3)); lhs2.add(new Dog(5)); lhs2.add(new Dog(4)); lhs2.add(new Dog(4)); System.out.println(lhs2.size()); //5 /** * * Java四个重要接口： * Comparable：可比较的； * Clonable：可克隆的； * Runnable：可线程化的； * Serializable：可序列化的； * * Tiger实现Comparable接口，所以必须实现compareTo方法比较大小 * compareTo方法具体规则如下： * int a = obj1.comparaTo(obj2); * 如果 a \u003e 0，则obj1 \u003e obj2； * 如果 a == 0，则obj1 == obj2； * 如果 a \u003c 0，则obj1 \u003c obj2； * * * HashSet元素判定规则和comparaTo方法无关 * */ System.out.println(\"==========Tiger HashSet ==============\"); HashSet\u003cTiger\u003e hs3 = new HashSet\u003cTiger\u003e(); hs3.add(new Tiger(2)); hs3.add(new Tiger(1)); hs3.add(new Tiger(3)); hs3.add(new Tiger(5)); hs3.add(new Tiger(4)); hs3.add(new Tiger(4)); System.out.println(hs3.size()); //6 System.out.println(\"========================\"); LinkedHashSet\u003cTiger\u003e lhs3= new LinkedHashSet\u003cTiger\u003e(); lhs3.add(new Tiger(2)); lhs3.add(new Tiger(1)); lhs3.add(new Tiger(3)); lhs3.add(new Tiger(5)); lhs3.add(new Tiger(4)); lhs3.add(new Tiger(4)); System.out.println(lhs3.size()); //6 } } TreeSet判定元素重复的原则 需要元素继承自Comparable接口 比较两个元素的compareTo方法 //Tiger.java public class Tiger implements Comparable{ private int size; public Tiger(int s) { size = s; } public int getSize() { return size; } public int compareTo(Object o) { System.out.println(\"Tiger compareTo()~~~~~~~~~~~\"); return size - ((Tiger) o).getSize(); } } // ObjectTreeSetTest.java import java.util.TreeSet; public class ObjectTreeSetTest { public static void main(String[] args) { //添加到TreeSet的，需要实现Comparable接口，即实现compareTo方法 System.out.println(\"==========Tiger TreeSet ==============\"); TreeSet","date":"2022-02-17","objectID":"/java08/:4:5","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"5 映射Map Map映射 数学定义：两个集合之间的元素对应关系 一个输入对应到一个输出 {Key,Value}，键值对，K-V对 Java中Map Hashtable（同步，慢，数据量小） HashMap（不支持同步，快，数据量大） Properties（同步，文件形式，数据量小） ","date":"2022-02-17","objectID":"/java08/:5:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"5.1 Hashtable K-V对，K和V都不允许为null 同步，多线程安全 无序的 适合小数据量 定义和初始化 import java.util.Hashtable; Hashtable\u003cInteger,String\u003e ht =new Hashtable\u003cInteger,String\u003e(); clear 清空数据 ht.clear(); contains/containsValue 是否包含某一个值 ht.contains(\"aaa\"); ht.containsValue(\"aaa\"); containsKey 是否包含某一个Key ht.containsKey(30000); get 根据Key获取相应的值 ht.get(30000); put 增加新的K-V对 //ht.put(1, null); 编译不报错 运行报错 //ht.put(null,1); 编译报错 ht.put(1000, \"aaa\"); ht.put(2, \"bbb\"); ht.put(30000, \"ccc\"); ht.put(30000, \"ddd\"); //更新覆盖ccc remove 删除某一个K-V对 ht.remove(2); size 返回数据大小 ht.size(); 遍历 public static void traverseByEntry(Hashtable\u003cInteger,String\u003e ht) { System.out.println(\"============Entry迭代器遍历==============\"); Integer key; String value; Iterator\u003cEntry\u003cInteger, String\u003e\u003e iter = ht.entrySet().iterator(); while(iter.hasNext()) { Map.Entry\u003cInteger, String\u003e entry = iter.next(); // 获取key key = entry.getKey(); // 获取value value = entry.getValue(); //System.out.println(\"Key:\" + key + \", Value:\" + value); } } public static void traverseByKeySet(Hashtable\u003cInteger,String\u003e ht) { System.out.println(\"============KeySet迭代器遍历==============\"); Integer key; String value; Iterator\u003cInteger\u003e iter = ht.keySet().iterator(); while(iter.hasNext()) { key = iter.next(); // 获取value value = ht.get(key); //System.out.println(\"Key:\" + key + \", Value:\" + value); } } public static void traverseByKeyEnumeration(Hashtable\u003cInteger,String\u003e ht) { System.out.println(\"============KeyEnumeration迭代器遍历==============\"); Integer key; String value; Enumeration\u003cInteger\u003e keys = ht.keys(); while(keys.hasMoreElements()) { key = keys.nextElement(); // 获取value value = ht.get(key); //System.out.println(\"Key:\" + key + \", Value:\" + value); } } ","date":"2022-02-17","objectID":"/java08/:5:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"5.2 HashMap K-V对，K和V都允许为null 无序的 不同步，多线程不安全 将不同步的HashMap变为同步的HashMap Map m = Collections.synchronizedMap(new HashMap(...)); 定义和初始化 import java.util.HashMap; HashMap\u003cInteger,String\u003e hm =new HashMap\u003cInteger,String\u003e(); clear 清空数据 hm.clear(); containsValue 是否包含某一个值 hm.containsValue(\"aaa\") containsKey 是否包含某一个Key hm.containsKey(30000) get 根据Key获取相应的值 hm.get(30000) put 增加新的K-V对 hm.put(1, null); hm.put(null, \"abc\"); hm.put(1000, \"aaa\"); hm.put(2, \"bbb\"); hm.put(30000, \"ccc\"); hm.put(30000, \"ddd\"); //更新覆盖ccc remove 删除某一个K-V对 hm.remove(2); size 返回数据大小 hm.size() 遍历 public static void traverseByEntry(HashMap\u003cInteger,String\u003e hm) { System.out.println(\"============Entry迭代器遍历==============\"); Integer key; String value; Iterator\u003cEntry\u003cInteger, String\u003e\u003e iter = hm.entrySet().iterator(); while(iter.hasNext()) { Map.Entry\u003cInteger, String\u003e entry = iter.next(); // 获取key key = entry.getKey(); // 获取value value = entry.getValue(); //System.out.println(\"Key:\" + key + \", Value:\" + value); } } public static void traverseByKeySet(HashMap\u003cInteger,String\u003e hm) { System.out.println(\"============KeySet迭代器遍历==============\"); Integer key; String value; Iterator\u003cInteger\u003e iter = hm.keySet().iterator(); while(iter.hasNext()) { key = iter.next(); // 获取value value = hm.get(key); //System.out.println(\"Key:\" + key + \", Value:\" + value); } } ","date":"2022-02-17","objectID":"/java08/:5:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"5.3 LinkedHashMap 基于双向链表的维持插入顺序的HashMap 遍历顺序和它的插入顺序保持一致 定义和初始化 import java.util.LinkedHashMap; LinkedHashMap\u003cInteger,String\u003e lhm =new LinkedHashMap\u003cInteger,String\u003e(); clear 清空数据 lhm.clear(); containsValue 是否包含某一个值 lhm.containsValue(\"aaa\") containsKey 是否包含某一个Key lhm.containsKey(30000) get 根据Key获取相应的值 lhm.get(30000) put 增加新的K-V对 lhm.put(1, null); lhm.put(null, \"abc\"); lhm.put(1000, \"aaa\"); lhm.put(2, \"bbb\"); lhm.put(30000, \"ccc\"); lhm.put(30000, \"ddd\"); //更新覆盖ccc remove 删除某一个K-V对 lhm.remove(2); size 返回数据大小 lhm.size() 遍历 public static void traverseByEntry(LinkedHashMap\u003cInteger,String\u003e lhm) { System.out.println(\"============Entry迭代器遍历==============\"); Integer key; String value; Iterator\u003cEntry\u003cInteger, String\u003e\u003e iter = lhm.entrySet().iterator(); while(iter.hasNext()) { Map.Entry\u003cInteger, String\u003e entry = iter.next(); // 获取key key = entry.getKey(); // 获取value value = entry.getValue(); //System.out.println(\"Key:\" + key + \", Value:\" + value); } } public static void traverseByKeySet(LinkedHashMap\u003cInteger,String\u003e lhm) { System.out.println(\"============KeySet迭代器遍历==============\"); Integer key; String value; Iterator\u003cInteger\u003e iter = lhm.keySet().iterator(); while(iter.hasNext()) { key = iter.next(); // 获取value value = lhm.get(key); //System.out.println(\"Key:\" + key + \", Value:\" + value); } } ","date":"2022-02-17","objectID":"/java08/:5:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"5.4 TreeMap 基于红黑树的Map 可以根据key的自然排序或者compareTo方法进行排序输出 定义和初始化 import java.util.TreeMap; TreeMap\u003cInteger,String\u003e tm =new TreeMap\u003cInteger,String\u003e(); clear 清空数据 tm.clear(); containsValue 是否包含某一个值 tm.containsValue(\"aaa\") containsKey 是否包含某一个Key tm.containsKey(30000) get 根据Key获取相应的值 tm.get(30000) put 增加新的K-V对 tm.put(1, null); //tm.put(null, \"abc\"); 编译没错，运行报空指针异常 tm.put(1000, \"aaa\"); tm.put(2, \"bbb\"); tm.put(30000, \"ccc\"); tm.put(30000, \"ddd\"); //更新覆盖ccc remove 删除某一个K-V对 tm.remove(2); size 返回数据大小 tm.size() 遍历 public static void traverseByEntry(TreeMap\u003cInteger,String\u003e tm) { System.out.println(\"============Entry迭代器遍历==============\"); Integer key; String value; Iterator\u003cEntry\u003cInteger, String\u003e\u003e iter = tm.entrySet().iterator(); while(iter.hasNext()) { Map.Entry\u003cInteger, String\u003e entry = iter.next(); // 获取key key = entry.getKey(); // 获取value value = entry.getValue(); //System.out.println(\"Key:\" + key + \", Value:\" + value); } } public static void traverseByKeySet(TreeMap\u003cInteger,String\u003e tm) { System.out.println(\"============KeySet迭代器遍历==============\"); Integer key; String value; Iterator\u003cInteger\u003e iter = tm.keySet().iterator(); while(iter.hasNext()) { key = iter.next(); // 获取value value = tm.get(key); //System.out.println(\"Key:\" + key + \", Value:\" + value); } } ","date":"2022-02-17","objectID":"/java08/:5:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"5.5 Properties 继承自Hashtable 可以将K-V对保存在文件中 适用于数据量少的配置文件 load：加载原文件中所有的K-V对 store：将所有的K-V对写入到文件中 getProperty：获取某一个Key所对应的Value setProperty：写入一个K-V对 import java.io.BufferedInputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.Enumeration; import java.util.Properties; //关于Properties类常用的操作 public class PropertiesTest { //根据Key读取Value public static String GetValueByKey(String filePath, String key) { Properties pps = new Properties(); try { InputStream in = new BufferedInputStream (new FileInputStream(filePath)); pps.load(in); //所有的K-V对都加载了 String value = pps.getProperty(key); //System.out.println(key + \" = \" + value); return value; }catch (IOException e) { e.printStackTrace(); return null; } } //读取Properties的全部信息 public static void GetAllProperties(String filePath) throws IOException { Properties pps = new Properties(); InputStream in = new BufferedInputStream(new FileInputStream(filePath)); pps.load(in); //所有的K-V对都加载了 Enumeration en = pps.propertyNames(); //得到配置文件的名字 while(en.hasMoreElements()) { String strKey = (String) en.nextElement(); String strValue = pps.getProperty(strKey); //System.out.println(strKey + \"=\" + strValue); } } //写入Properties信息 public static void WriteProperties (String filePath, String pKey, String pValue) throws IOException { File file = new File(filePath); if(!file.exists()) { file.createNewFile(); } Properties pps = new Properties(); InputStream in = new FileInputStream(filePath); //从输入流中读取属性列表（键和元素对） pps.load(in); //调用 Hashtable 的方法 put。使用 getProperty 方法提供并行性。 //强制要求为属性的键和值使用字符串。返回值是 Hashtable 调用 put 的结果。 OutputStream out = new FileOutputStream(filePath); pps.setProperty(pKey, pValue); //以适合使用 load 方法加载到 Properties 表中的格式， //将此 Properties 表中的属性列表（键和元素对）写入输出流 pps.store(out, \"Update \" + pKey + \" name\"); out.close(); } public static void main(String [] args) throws IOException{ System.out.println(\"写入Test.properties================\"); WriteProperties(\"Test.properties\",\"name\", \"12345\"); System.out.println(\"加载Test.properties================\"); GetAllProperties(\"Test.properties\"); System.out.println(\"从Test.properties加载================\"); String value = GetValueByKey(\"Test.properties\", \"name\"); System.out.println(\"name is \" + value); } } /** * * 运行结果： * 写入Test.properties================ * 加载Test.properties================ * 从Test.properties加载================ * name is 12345 * */ ","date":"2022-02-17","objectID":"/java08/:5:5","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"6 工具类 ","date":"2022-02-17","objectID":"/java08/:6:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"6.1 Arrays 排序 sort/parallelSort 对数组排序 public static void testSort() { Random r = new Random(); int[] a = new int[10]; for(int i=0;i\u003ca.length;i++) { a[i] = r.nextInt(); } System.out.println(\"===============测试排序================\"); System.out.println(\"排序前\"); for(int i=0;i\u003ca.length;i++) { System.out.print(a[i] + \",\"); } System.out.println(); System.out.println(\"排序后\"); Arrays.sort(a); for(int i=0;i\u003ca.length;i++) { System.out.print(a[i] + \",\"); } System.out.println(); } /** * * ===============测试排序================ * 排序前 * -1132207311,138314395,-1589844698,21086905,-1280289820,-1685791626,-680547355,572504069,1029156267,1833937878, * 排序后 * -1685791626,-1589844698,-1280289820,-1132207311,-680547355,21086905,138314395,572504069,1029156267,1833937878, * */ 查找 binarySearch 从数组中查找一个元素 public static void testSearch() { Random r = new Random(); int[] a = new int[10]; for(int i=0;i\u003ca.length;i++) { a[i] = r.nextInt(); } a[a.length-1] = 10000; System.out.println(\"===========测试查找============\"); System.out.println(\"10000 的位置是\" + Arrays.binarySearch(a, 10000)); } /** * * ===========测试查找============ * 10000 的位置是9 * * */ 批量拷贝 copyOf 从源数组批量复制元素到目标数组 public static void testCopy() { Random r = new Random(); int[] a = new int[10]; for(int i=0;i\u003ca.length;i++) { a[i] = r.nextInt(); } int[] b = Arrays.copyOf(a, 5); System.out.println(\"===========测试拷贝前五个元素============\"); System.out.print(\"源数组：\"); for(int i=0;i\u003ca.length;i++) { System.out.print(a[i] + \",\"); } System.out.println(); System.out.print(\"目标数组：\"); for(int i=0;i\u003cb.length;i++) { System.out.print(b[i] + \",\"); } System.out.println(); } /** * * ===========测试拷贝前五个元素============ * 源数组：670811887,1566520826,-514867056,-1186107665,129679533,149113219,-956323326,89906597,-1450389055,944799102, * 目标数组：670811887,1566520826,-514867056,-1186107665,129679533, * * * * */ 批量赋值 fill 对数组进行批量赋值， public static void testFill() { int[] a = new int[10]; Arrays.fill(a, 100); Arrays.fill(a, 2, 8, 200); System.out.println(\"===========测试批量赋值============\"); System.out.print(\"数组赋值后：\"); for(int i=0;i\u003ca.length;i++) { System.out.print(a[i] + \",\"); } System.out.println(); } /** * * ===========测试批量赋值============ * 数组赋值后：100,100,200,200,200,200,200,200,100,100, * * */ 等价性比较 equals 判定两个数组内容是否相同 public static void testEquality() { int[] a = new int[10]; Arrays.fill(a, 100); int[] b = new int[10]; Arrays.fill(b, 100); System.out.println(Arrays.equals(a, b)); //true b[9] = 200; System.out.println(Arrays.equals(a, b)); //false } ","date":"2022-02-17","objectID":"/java08/:6:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"6.2 Collections 处理对象是Collection及其子类 排序：对List进行排序，sort // 排序 Collections.sort(list); 搜索 binarySearch 从List中搜索元素 Collections.binarySearch(list, 12); 批量赋值 fill 对List批量赋值 Collections.fill(list, 100); //全部赋值为100 最大 max、最小 min 查找集合中最大/最小值 //最大值 Collections.max(list); //最小值 Collections.min(list); 反序 reverse 将List反序排列 Collections.reverse(list); //翻转不需要用到排序 ","date":"2022-02-17","objectID":"/java08/:6:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"6.3 对象比较 对象排序需要遵循一定的规则。Integer对象可以自然按数值大小进行排序。而普通的自定义对象无法排序。因此，普通自定义对象需要实现Comparable接口，按照CompareTo方法所规定的原则进行排序。 对象实现Comparable接口（需要修改对象类） compareTo方法 ： \u003e 返回 1，== 返回 0，\u003c 返回 -1 Arrays和Collections在进行对象sort时，自动调用该方法。 新建Comparator（适用于对象类不可更改的情况） compare方法 ： \u003e 返回 1，== 返回 0，\u003c 返回 -1 Comparator比较器将作为参数提交给工具类的sort方法 //Person.java import java.util.Arrays; public class Person implements Comparable\u003cPerson\u003e { String name; int age; public String getName() { return name; } public int getAge() { return age; } public Person(String name, int age) { this.name = name; this.age = age; } public int compareTo(Person another) { int i = 0; i = name.compareTo(another.name); // 使用字符串的比较 if (i == 0) { // 如果名字一样,比较年龄, 返回比较年龄结果 return age - another.age; } else { return i; // 名字不一样, 返回比较名字的结果. } } public static void main(String... a) { Person[] ps = new Person[3]; ps[0] = new Person(\"Tom\", 20); ps[1] = new Person(\"Mike\", 18); ps[2] = new Person(\"Mike\", 20); Arrays.sort(ps); for (Person p : ps) { System.out.println(p.getName() + \",\" + p.getAge()); } } } /** * * 输出结果： * Mike,18 * Mike,20 * Tom,20 * */ //Person2Comparator.java import java.util.Arrays; import java.util.Comparator; public class Person2Comparator implements Comparator\u003cPerson2\u003e { public int compare(Person2 one, Person2 another) { int i = 0; i = one.getName().compareTo(another.getName()); if (i == 0) { // 如果名字一样,比较年龄,返回比较年龄结果 return one.getAge() - another.getAge(); } else { return i; // 名字不一样, 返回比较名字的结果. } } public static void main(String[] args) { // TODO Auto-generated method stub Person2[] ps = new Person2[3]; ps[0] = new Person2(\"Tom\", 20); ps[1] = new Person2(\"Mike\", 18); ps[2] = new Person2(\"Mike\", 20); Arrays.sort(ps, new Person2Comparator()); for (Person2 p : ps) { System.out.println(p.getName() + \",\" + p.getAge()); } } } //Person2.java public class Person2 { private String name; private int age; public String getName() { return name; } public int getAge() { return age; } public Person2(String name, int age) { this.name = name; this.age = age; } } /** * * 输出结果： * Mike,18 * Mike,20 * Tom,20 * */ ","date":"2022-02-17","objectID":"/java08/:6:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java数据结构","uri":"/java08/"},{"categories":["Java"],"content":"[Java核心技术] Java异常和异常处理","date":"2022-02-16","objectID":"/java07/","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java异常和异常处理","uri":"/java07/"},{"categories":["Java"],"content":"Java 核心技术读书笔记——Java异常和异常处理 ","date":"2022-02-16","objectID":"/java07/:0:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java异常和异常处理","uri":"/java07/"},{"categories":["Java"],"content":"1 Java异常分类 异常：程序不正常的行为或者状态 ","date":"2022-02-16","objectID":"/java07/:1:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java异常和异常处理","uri":"/java07/"},{"categories":["Java"],"content":"Throwable 所有错误的祖先 ","date":"2022-02-16","objectID":"/java07/:1:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java异常和异常处理","uri":"/java07/"},{"categories":["Java"],"content":"Error 系统内部错误或者资源耗尽，可以不用处理。 ","date":"2022-02-16","objectID":"/java07/:1:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java异常和异常处理","uri":"/java07/"},{"categories":["Java"],"content":"Exception 程序有关异常，重点关注。 RuntimeException：程序自身的错误 5/0，空指针，数组越界… 非RuntimeException：外界相关的错误 打开一个不存在文件 加载一个不存在的类 Unchecked Exception：（编译器不会辅助检查的，需要程序员自己管的）异常，包括Error子类和RuntimeException子类。 非RuntimeException的Exception的子类：（编译器会辅助检查的）异常，checked exception。 注意：编译器会检查程序是否为checked exception配置了处理。如果没有处理，会报错。 ","date":"2022-02-16","objectID":"/java07/:1:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java异常和异常处理","uri":"/java07/"},{"categories":["Java"],"content":"2 Java异常处理 允许用户及时保存结果 抓住异常，分析异常内容 控制程序返回到安全状态 ","date":"2022-02-16","objectID":"/java07/:2:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java异常和异常处理","uri":"/java07/"},{"categories":["Java"],"content":"try-catch-finally 一种保护代码正常运行的机制 try：正常业务逻辑代码。 catch：当try发生异常，将执行catch代码。若无异常，则绕之。 finally：当try或catch执行结束后，必须要执行finally。 异常结构 try...catch（catch可以有多个，下同） try...catch...finally try...finally try必须有，catch和finally至少要有一个 catch块可以有多个，每个有不同的入口形参。当已发生的异常和某一个catch块中的形参类型一致，那么将执行该catch块中的代码。如果没有一个匹配，catch也不会被触发。最后都进入finally块。 进入catch块后，并不会返回到try发生异常的位置，也不会执行后续的catch块，一个异常只能进入一个catch块。 catch块的异常匹配是从上而下进行匹配，所以一般是将小的异常写在前面，而一些大（宽泛）的异常则写在末尾。 try-catch-finally每个模块里面也会发生异常，所以也可以在内部继续写一个完整的try结构。 ","date":"2022-02-16","objectID":"/java07/:2:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java异常和异常处理","uri":"/java07/"},{"categories":["Java"],"content":"throws 方法存在可能异常的语句，但不处理，那么可以使用throws来声明异常。 调用带有throws异常（checked exception）的方法，要么处理这些异常，或者再次向外throws，直到main函数为止。 public class ThrowsDemo { public static void main(String [] args) { try { int result = new Test().divide( 3, 1 ); System.out.println(\"the 1st result is\" + result ); } catch(ArithmeticException ex) { ex.printStackTrace(); } int result = new Test().divide( 3, 0 ); System.out.println(\"the 2nd result is\" + result ); } } class Test { //ArithmeticException is a RuntimeException, not checked exception public int divide(int x, int y) throws ArithmeticException { int result = x/y; return x/y; } } ","date":"2022-02-16","objectID":"/java07/:2:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java异常和异常处理","uri":"/java07/"},{"categories":["Java"],"content":"覆盖/继承 一个方法被覆盖，覆盖它的所有方法必须抛出相同的异常，或者异常的子类。 如果父类的方法抛出多个异常，那么重写的子类方法必须抛出那些异常的子集，也就是不能抛出新的异常。 // Father.java public class Father { public void f1() throws ArithmeticException { } } // Son.java public class Son extends Father { public void f1() throws IOException // error { //子类重写方法， //所抛出的异常不能超出父类规定的范围 } } ","date":"2022-02-16","objectID":"/java07/:2:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java异常和异常处理","uri":"/java07/"},{"categories":["Java"],"content":"3 自定义异常 自定义异常，需要继承Exception类或者子类 继承自Exception，就变成Checked Exception 继承自RuntimeException，就变成UncheckedException 自定义重点在构造函数 调用父类Exception的message构造函数 可以自定义自己的成员变量 在程序中采用throw主动抛出异常 // MyException.java public class MyException extends Exception { private String returnCode ; //异常对应的返回码 private String returnMsg; //异常对应的描述信息 public MyException() { super(); } public MyException(String returnMsg) { super(returnMsg); this.returnMsg = returnMsg; } public MyException(String returnCode, String returnMsg) { super(); this.returnCode = returnCode; this.returnMsg = returnMsg; } public String getReturnCode() { return returnCode; } public String getreturnMsg() { return returnMsg; } } //MyExceptionTest.java public class MyExceptionTest { public static void testException() throws MyException { throw new MyException(\"10001\", \"The reason of myException\"); } public static void main(String[] args) { MyExceptionTest.testException(); //error 需要使用try-catch-finally // try { // MyExceptionTest.testException(); // } catch (MyException e) { // e.printStackTrace(); // System.out.println(\"returnCode:\"+e.getReturnCode()); // System.out.println(\"returnMsg:\"+e.getreturnMsg()); // } } } ","date":"2022-02-16","objectID":"/java07/:3:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java异常和异常处理","uri":"/java07/"},{"categories":["Java"],"content":"[Java核心技术] Java常用类","date":"2022-02-15","objectID":"/java06/","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"Java 核心技术读书笔记——Java常用类 ","date":"2022-02-15","objectID":"/java06/:0:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"1 Java类库概述 Java类库文档 https://docs.oracle.com/javase/8/docs/api/ 包名以java开始的包是Java核心包（Java Core Package) 包名以javax开始的包是java扩展包（Java Extension Package） java.lang包是每个类都默认调用的，可以不用import ","date":"2022-02-15","objectID":"/java06/:1:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"2 数字相关类 ","date":"2022-02-15","objectID":"/java06/:2:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"2.1 Java数字类 整数 Short，Int，Long 浮点数 Float，Double 大数类 BigInteger（大整数），BigDecimal（大浮点数） BigInteger 支持无限大的整数运算 import java.math.BigInteger; public class BigIntegerTest { public static void main(String[] args) { BigInteger b1 = new BigInteger(\"123456789\"); // 声明BigInteger对象 BigInteger b2 = new BigInteger(\"987654321\"); // 声明BigInteger对象 System.out.println(\"b1: \" + b1 + \", b2:\" + b2); System.out.println(\"加法操作：\" + b2.add(b1)); // 加法操作 System.out.println(\"减法操作：\" + b2.subtract(b1)); // 减法操作 System.out.println(\"乘法操作：\" + b2.multiply(b1)); // 乘法操作 System.out.println(\"除法操作：\" + b2.divide(b1)); // 除法操作 System.out.println(\"最大数：\" + b2.max(b1)); // 求出最大数 System.out.println(\"最小数：\" + b2.min(b1)); // 求出最小数 BigInteger result[] = b2.divideAndRemainder(b1); // 求出余数的除法操作 System.out.println(\"商是：\" + result[0] + \"；余数是：\" + result[1]); System.out.println(\"等价性是：\" + b1.equals(b2)); int flag = b1.compareTo(b2); if (flag == -1) System.out.println(\"比较操作: b1\u003cb2\"); else if (flag == 0) System.out.println(\"比较操作: b1==b2\"); else System.out.println(\"比较操作: b1\u003eb2\"); } } BigDecimal支持无线大的小数运算 import java.math.BigDecimal; import java.math.BigInteger; public class BigDecimalTest { public static void main(String[] args) { BigDecimal b1 = new BigDecimal(\"123456789.987654321\"); // 声明BigDecimal对象 BigDecimal b2 = new BigDecimal(\"987654321.123456789\"); // 声明BigDecimal对象 System.out.println(\"b1: \" + b1 + \", b2:\" + b2); System.out.println(\"加法操作：\" + b2.add(b1)); // 加法操作 System.out.println(\"减法操作：\" + b2.subtract(b1)); // 减法操作 System.out.println(\"乘法操作：\" + b2.multiply(b1)); // 乘法操作 //需要指定位数，防止无限循环，或者包含在try-catch中 System.out.println(\"除法操作：\" + b2.divide(b1,10,BigDecimal.ROUND_HALF_UP)); // 除法操作 System.out.println(\"最大数：\" + b2.max(b1)); // 求出最大数 System.out.println(\"最小数：\" + b2.min(b1)); // 求出最小数 int flag = b1.compareTo(b2); if (flag == -1) System.out.println(\"比较操作: b1\u003cb2\"); else if (flag == 0) System.out.println(\"比较操作: b1==b2\"); else System.out.println(\"比较操作: b1\u003eb2\"); System.out.println(\"===================\"); //尽量采用字符串赋值 System.out.println(new BigDecimal(\"2.3\")); System.out.println(new BigDecimal(2.3)); System.out.println(\"===================\"); BigDecimal num1 = new BigDecimal(\"10\"); BigDecimal num2 = new BigDecimal(\"3\"); //需要指定位数，防止无限循环，或者包含在try-catch中 BigDecimal num3 = num1.divide(num2, 3, BigDecimal.ROUND_HALF_UP); System.out.println(num3); } } 随机数类 Random nextInt() 返回一个随机int nextInt(int a) 返回一个[0,a)之间的随机int nextDouble() 返回一个[0.0,1.0]之间double ints方法批量返回随机数数组 import java.util.Random; public class RandomTest { public static void main(String[] args) { //第一种办法，采用Random类 随机生成在int范围内的随机数 Random rd = new Random(); System.out.println(rd.nextInt()); System.out.println(rd.nextInt(100)); //0--100的随机数 System.out.println(rd.nextLong()); System.out.println(rd.nextDouble()); System.out.println(\"=========================\"); //第二种，生成一个范围内的随机数 例如0到时10之间的随机数 //Math.random[0,1) System.out.println(Math.round(Math.random()*10)); System.out.println(\"=========================\"); //JDK 8 新增方法 rd.ints(); //返回无限个int类型范围内的数据 int[] arr = rd.ints(10).toArray(); //生成10个int范围类的个数。 for (int i = 0; i \u003c arr.length; i++) { System.out.println(arr[i]); } System.out.println(\"=========================\"); arr = rd.ints(5, 10, 100).toArray(); for (int i = 0; i \u003c arr.length; i++) { System.out.println(arr[i]); } System.out.println(\"=========================\"); arr = rd.ints(10).limit(5).toArray(); for (int i = 0; i \u003c arr.length; i++) { System.out.println(arr[i]); } } } ","date":"2022-02-15","objectID":"/java06/:2:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"2.2 工具类 Math 绝对值函数abs 对数函数log 比较函数max、min 幂函数pow 四舍五入函数round等 向下取整floor 向上取整ceil public class MathTest { public static void main(String[] args) { System.out.println(Math.abs(-5)); //绝对值 System.out.println(Math.max(-5,-8)); //最大值 System.out.println(Math.pow(-5,2)); //求幂 System.out.println(Math.round(3.5)); //四舍五入 System.out.println(Math.ceil(3.5)); //向上取整 System.out.println(Math.floor(3.5)); //向下取整 } } ","date":"2022-02-15","objectID":"/java06/:2:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"3 字符串相关类 ","date":"2022-02-15","objectID":"/java06/:3:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"3.1 String public class StringTest { public static void main(String[] args) { String a = \"123;456;789;123 \"; System.out.println(a.charAt(0)); // 返回第0个元素 System.out.println(a.indexOf(\";\")); // 返回第一个;的位置 System.out.println(a.concat(\";000\")); // 连接一个新字符串并返回，a不变 System.out.println(a.contains(\"000\")); // 判断a是否包含000 System.out.println(a.endsWith(\"000\")); // 判断a是否以000结尾 System.out.println(a.equals(\"000\")); // 判断是否等于000 System.out.println(a.equalsIgnoreCase(\"000\"));// 判断在忽略大小写情况下是否等于000 System.out.println(a.length()); // 返回a长度 System.out.println(a.trim()); // 返回a去除前后空格后的字符串，a不变 String[] b = a.split(\";\"); // 将a字符串按照;分割成数组 for (int i = 0; i \u003c b.length; i++) { System.out.println(b[i]); } System.out.println(\"===================\"); System.out.println(a.substring(2, 5)); // 截取a的第2个到第5个字符 a不变 System.out.println(a.replace(\"1\", \"a\")); System.out.println(a.replaceAll(\"1\", \"a\")); // replaceAll第一个参数是正则表达式 System.out.println(\"===================\"); String s1 = \"12345?6789\"; String s2 = s1.replace(\"?\", \"a\"); String s3 = s1.replaceAll(\"[?]\", \"a\"); // 这里的[?] 才表示字符问号，这样才能正常替换。不然在正则中会有特殊的意义就会报异常 System.out.println(s2); System.out.println(s3); System.out.println(s1.replaceAll(\"[\\\\d]\", \"a\")); //将s1内所有数字替换为a并输出，s1的值未改变。 } } ","date":"2022-02-15","objectID":"/java06/:3:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"3.2 可变字符串 StringBuffer 字符串加减，同步，性能好 StringBuilder 字符串加减，不同步，性能更好 public class StringBufferReferenceTest { public static void main(String[] args) { StringBuffer sb1 = new StringBuffer(\"123\"); StringBuffer sb2 = sb1; sb1.append(\"12345678901234567890123456789012345678901234567890\"); System.out.println(sb2); //sb1 和 sb2还是指向同一个内存的 } } StringBuffer/StringBuilder 方法一样，区别在同步 append/insert/delete/replace/substring length字符串实际大小 capacity 字符串占用空间大小 public class StringBufferCapacityTest { public static void main(String[] args) { //StringBuffer的的初始大小为（16+初始字符串长度）即capacity=16+初始字符串长度 //length 实际长度 capacity 存储空间大小 StringBuffer sb1 = new StringBuffer(); System.out.println(\"sb1 length: \" + sb1.length()); System.out.println(\"sb1 capacity: \" + sb1.capacity()); System.out.println(\"=====================\"); StringBuffer sb2 = new StringBuffer(\"123\"); sb2.append(\"456\"); System.out.println(\"sb2 length: \" + sb2.length()); System.out.println(\"sb2 capacity: \" + sb2.capacity()); System.out.println(\"=====================\"); sb2.append(\"7890123456789\"); System.out.println(\"sb2 length: \" + sb2.length()); System.out.println(\"sb2 capacity: \" + sb2.capacity()); System.out.println(\"=====================\"); sb2.append(\"0\"); System.out.println(\"sb2 length: \" + sb2.length()); System.out.println(\"sb2 capacity: \" + sb2.capacity()); //一旦length大于capacity时，capacity便在前一次的基础上加1后翻倍； System.out.println(\"=====================\"); //当前sb2length 20 capacity 40， 再append 70个字符 超过(加1再2倍数额) sb2.append(\"1234567890123456789012345678901234567890123456789012345678901234567890\"); System.out.println(\"sb2 length: \" + sb2.length()); System.out.println(\"sb2 capacity: \" + sb2.capacity()); //如果append的对象很长，超过(加1再2倍数额)，将以最新的长度更换 System.out.println(\"=====================\"); sb2.append(\"0\"); System.out.println(\"sb2 length: \" + sb2.length()); System.out.println(\"sb2 capacity: \" + sb2.capacity()); sb2.trimToSize(); System.out.println(\"=====after trime================\"); System.out.println(\"sb2 length: \" + sb2.length()); System.out.println(\"sb2 capacity: \" + sb2.capacity()); } } trimToSize() 去除空隙，将字符串压缩到实际大小 ","date":"2022-02-15","objectID":"/java06/:3:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"4 时间相关类 ","date":"2022-02-15","objectID":"/java06/:4:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"java.util.Date 基本废弃，Deprecated getTime()，返回自1970.1.1以来的毫秒数 ","date":"2022-02-15","objectID":"/java06/:4:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"java.sql.Date 和数据库对应的时间类 ","date":"2022-02-15","objectID":"/java06/:4:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"Calendar 目前程序中最常用，但是是抽象类 import java.util.Calendar; import java.util.GregorianCalendar; public class CalendarClassTest { public static void main(String[] args) { Calendar gc = Calendar.getInstance(); System.out.println(gc.getClass().getName()); //java.util.GregorianCalendar //Calendar.getInstance();返回的是GregorianCalendar对象 GregorianCalendar gc2 = new GregorianCalendar(); System.out.println(gc2.getClass().getName()); //java.util.GregorianCalendar } } get(Field) 获取时间中每个属性的值 // 获取年 int year = calendar.get(Calendar.YEAR); // 获取月，这里需要需要月份的范围为0~11，因此获取月份的时候需要+1才是当前月份值 int month = calendar.get(Calendar.MONTH) + 1; // 获取日 int day = calendar.get(Calendar.DAY_OF_MONTH); // 获取时 int hour = calendar.get(Calendar.HOUR); // int hour = calendar.get(Calendar.HOUR_OF_DAY); // 24小时表示 // 获取分 int minute = calendar.get(Calendar.MINUTE); // 获取秒 int second = calendar.get(Calendar.SECOND); // 星期，英语国家星期从星期日开始计算 int weekday = calendar.get(Calendar.DAY_OF_WEEK); getTime() 返回相应的Date对象 getTimeInMillis() 返回自1970.1.1以来毫秒数 set(Field) 设置时间字段 calendar.set(Calendar.YEAR, 2022); System.out.println(\"现在是\" + calendar.get(Calendar.YEAR) + \"年\"); //现在是2022年 calendar.set(2022, 0, 1); // 获取年 int year = calendar.get(Calendar.YEAR); // 获取月 int month = calendar.get(Calendar.MONTH)+1; // 获取日 int day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(\"现在是\" + year + \"年\" + month + \"月\" + day + \"日\"); //现在是2022年2月1日 add(field,amount) 根据指定字段增加/减少时间 // 同理换成下个月的今天calendar.add(Calendar.MONTH, 1); calendar.add(Calendar.YEAR, 1); // 获取年 int year = calendar.get(Calendar.YEAR); // 获取月 int month = calendar.get(Calendar.MONTH) + 1; // 获取日 int day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(\"一年后的今天：\" + year + \"年\" + month + \"月\" + day + \"日\"); roll(field,amount) 根据指定字段增加/减少时间，只影响当前字段，不影响进位。 //add和roll的区别 public void test() { calendar.set(2022, 0, 1); calendar.add(Calendar.DAY_OF_MONTH, -1); // 获取年 int year = calendar.get(Calendar.YEAR); // 获取月 int month = calendar.get(Calendar.MONTH)+1; // 获取日 int day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(\"2022.1.1, 用add减少1天，现在是\" + year + \".\" + month + \".\" + day); //2022.1.1, 用add减少1天，现在是2021.12.31 calendar.set(2022, 0, 1); calendar.roll(Calendar.DAY_OF_MONTH, -1); // 获取年 year = calendar.get(Calendar.YEAR); // 获取月 month = calendar.get(Calendar.MONTH)+1; // 获取日 day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(\"2022.1.1, 用roll减少1天，现在是\" + year + \".\" + month + \".\" + day); //2022.1.1, 用roll减少1天，现在是2022.1.31 } ","date":"2022-02-15","objectID":"/java06/:4:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"java8 新推出的时间API java.time包（新的Java日期/时间API的基础包） 旧的设计不好（重名的类、线程不安全等） 新版本优点 不变性，在多线程环境下 遵循设计模式，设计得更好，可扩展性强 java.time.chrono 为非ISO的日历系统定义了一些泛化的API java.time.format 格式化和解析日期时间对象的类 java.time.temporal 包含一些时态对象，可以用其找出相关日期/时间对象的某个特定日期或时间 java.time.zone 包含支持不同时区以及相关规则的类 java.time.LocalDate import java.time.LocalDate; import java.time.Month; import java.time.ZoneId; public class LocalDateExample { public static void main(String[] args) { //当前时间 LocalDate today = LocalDate.now(); System.out.println(\"Current Date=\"+today); //根据指定时间创建LocalDate LocalDate firstDay_2022 = LocalDate.of(2022, Month.JANUARY, 1); System.out.println(\"Specific Date=\"+firstDay_2022); //给定错误时间参数，将报异常java.time.DateTimeException //LocalDate feb29_2014 = LocalDate.of(2014, Month.FEBRUARY, 29); //可以更改时区 LocalDate todayBeijing = LocalDate.now(ZoneId.of(\"Asia/Shanghai\")); System.out.println(\"Current Date in Shanghai=\"+todayBeijing); //从纪元日01/01/1970开始365天 LocalDate dateFromBase = LocalDate.ofEpochDay(365); System.out.println(\"365th day from base date= \"+dateFromBase); //2022年的第100天 LocalDate hundredDay2022 = LocalDate.ofYearDay(20122, 100); System.out.println(\"100th day of 2022=\"+hundredDay2022); } } java.time.LocalTime import java.time.LocalTime; import java.time.ZoneId; public class LocalTimeExample { public static void main(String[] args) { //当前时间 时分秒 纳秒 LocalTime time = LocalTime.now(); System.out.println(\"Current Time=\"+time); //根据时分秒 LocalTime specificTime = LocalTime.of(12,20,25,40); System.out.println(\"Specific Time of Day=\"+specificTime); //错误的时间参数 将报DateTimeException //LocalTime invalidTime = LocalTime.of(25,20); //上海时间 LocalTime timeSH = LocalTime.now(ZoneId.of(\"Asia/Shanghai\")); System.out.println(\"Current Time in SH=\"+timeSH); //一天当中第几秒 LocalTime specificSecondTime = LocalTime.ofSecondOfDay(10000); System.out.println(\"10000th second time= \"+specificSecondTime); } } java.time.LocalDateTime import java.time.LocalDate; import java.time.LocalDateTime; import java.time.LocalTime; import java.time.Month; import java.time.ZoneId; import java.time.ZoneOffset; public class LocalDateTimeExample { public static void main(String[] args) { //当前日期 时分秒 LocalDateTime today = LocalDateTime.now(); System.out.println(\"Current DateTime=\"+today); //根据日期， 时分秒来创建对象 today = LocalDateTime.of(LocalDate.now(), LocalTime.now()); System.out.println(\"Current DateTime=\"+today); //指定具体时间来创建对象 LocalDateTime specificDate = LocalDateTime.of(2022, Month.JANUARY, 1, 10, 10, 30); System.out.println(\"Specific Date=\"+specificDate); //如时间不对，将报异常DateTimeException //LocalDateTime feb29_2022 = LocalDateTime.of(2022, Month.FEBRUARY, 28, 25,1,1); //上海时区 LocalDateTime todayShanghai = LocalDateTime.now(ZoneId.of(\"Asia/Shanghai\")); System.out.println(\"Current Date in Shanghai=\"+todayShanghai); //从01/01/1970 10000秒 LocalDateTime dateFromBase = LocalDateTime.ofEpochSecond(10000, 0, ZoneOffset.UTC); System.out.println(\"10000th second time from 01/01/1970= \"+dateFromBase); } } java.time.Instant import java.time.Duration; import java.time.Instant; import java.util.Date; public class InstantExample { public static void main(String[] args) { //当前时间戳 Instant timestamp = Instant.now(); System.out.println(\"Current Timestamp = \"+timestamp); //从毫秒数来创建时间戳 Instant specificTime = Instant.ofEpochMilli(timestamp.toEpochMilli()); System.out.println(\"Specific Time = \"+specificTime); Date date = Date.from(timestamp); System.out.println(\"current date = \" + date); } } ","date":"2022-02-15","objectID":"/java06/:4:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"5 格式化相关类 ","date":"2022-02-15","objectID":"/java06/:5:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"java.text包java.text.Format的子类 NumberFormat：数字格式化，抽象类 DecimalFormat DecimalFormat df1,df2; System.out.println(\"整数部分为0的情况，0/#的区别\"); // 整数部分为0 ， #认为整数不存在，可不写； 0认为没有，但至少写一位，写0 df1 = new DecimalFormat(\"#.00\"); df2 = new DecimalFormat(\"0.00\"); System.out.println(df1.format(0.1)); // .10 System.out.println(df2.format(0.1)); // 0.10 System.out.println(\"小数部分0/#的区别\"); //#代表最多有几位，0代表必须有且只能有几位 df1 = new DecimalFormat(\"0.00\"); df2 = new DecimalFormat(\"0.##\"); System.out.println(df1.format(0.1)); // 0.10 System.out.println(df2.format(0.1)); // 0.1 System.out.println(df1.format(0.006)); // 0.01 System.out.println(df2.format(0.006)); // 0.01 System.out.println(\"整数部分有多位\"); //0和#对整数部分多位时的处理是一致的 就是有几位写多少位 df1 = new DecimalFormat(\"0.00\"); df2 = new DecimalFormat(\"#.00\"); System.out.println(df1.format(2)); // 2.00 System.out.println(df2.format(2)); // 2.00 System.out.println(df1.format(20)); // 20.00 System.out.println(df2.format(20)); // 20.00 System.out.println(df1.format(200)); // 200.00 System.out.println(df2.format(200)); // 200.00 MessageFOrmat：字符串格式化 支持多个参数-值对位复制文本 支持变量的自定义格式 import java.text.MessageFormat; public class MessageFormatTest { public static void main(String[] args) { String message = \"{0}{1}{2}{3}{4}{5}{6}{7}{8}{9}{10}{11}{12}{13}{14}{15}{16}\"; Object[] array = new Object[]{\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\"}; String value = MessageFormat.format(message, array); System.out.println(value); //ABCDEFGHIJKLMNOPQ message = \"oh, {0,number,#.##} is a good number\"; array = new Object[]{new Double(3.1415)}; value = MessageFormat.format(message, array); System.out.println(value); //oh, 3.14 is a good number } } DateFormat：日期/时间格式化，抽象类 SimpleDateFormat 工厂模式 parse 将字符串格式化为时间对象 format 将时间对象格式化为字符串 String strDate = \"2022-01-01 10:11:30.345\" ; // 准备第一个模板，从字符串中提取出日期数字 String pat1 = \"yyyy-MM-dd HH:mm:ss.SSS\" ; // 准备第二个模板，将提取后的日期数字变为指定的格式 String pat2 = \"yyyy年MM月dd日 HH时mm分ss秒SSS毫秒\" ; SimpleDateFormat sdf1 = new SimpleDateFormat(pat1) ; // 实例化模板对象 SimpleDateFormat sdf2 = new SimpleDateFormat(pat2) ; // 实例化模板对象 Date d = null ; try{ d = sdf1.parse(strDate) ; // 将给定的字符串中的日期提取出来 }catch(Exception e){ // 如果提供的字符串格式有错误，则进行异常处理 e.printStackTrace() ; // 打印异常信息 } System.out.println(sdf2.format(d)) ; // 将日期变为新的格式 ","date":"2022-02-15","objectID":"/java06/:5:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"java.time.format包下 DateTimeFormatter JDK8发布，线程安全（SimpleDateFormat线程不安全） ofPattern：设定时间格式 parse 将字符串格式化为时间对象 format 将时间对象格式化为字符串 //将字符串转化为时间 String dateStr= \"2022年01月01日\"; DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\"); LocalDate date= LocalDate.parse(dateStr, formatter); System.out.println(date.getYear() + \"-\" + date.getMonthValue() + \"-\" + date.getDayOfMonth()); System.out.println(\"==========================\"); //将日期转换为字符串输出 LocalDateTime now = LocalDateTime.now(); DateTimeFormatter format = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 hh:mm:ss\"); String nowStr = now.format(format); System.out.println(nowStr); ","date":"2022-02-15","objectID":"/java06/:5:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] Java常用类","uri":"/java06/"},{"categories":["Java"],"content":"[Java核心技术] package,import和classpath","date":"2022-02-14","objectID":"/java05/","tags":["Java","JavaVolume"],"title":"[Java核心技术] package,import和classpath","uri":"/java05/"},{"categories":["Java"],"content":"Java 核心技术读书笔记——Java package,import和classpath ","date":"2022-02-14","objectID":"/java05/:0:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] package,import和classpath","uri":"/java05/"},{"categories":["Java"],"content":"1 package和import ","date":"2022-02-14","objectID":"/java05/:1:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] package,import和classpath","uri":"/java05/"},{"categories":["Java"],"content":"1.1 package 所有的Java类都放置在同一个目录下，因此类之间的相互调用无显式声明调用。 同一个目录下，两个类的名字不能相同 文件过多，查找和修改都不易，且容易出错 Java支持多个目录放置Java，并且通过package/import/classpath/jar等机制配合使用，可以支持跨目录放置和特别调用Java类。 package包，类似于C++中的namespace 在Java类文件的第一句话给出包的名称 package cn.edu.zzu; public class PackageExample{ } 引用类的时候，必须采用全称引用；程序正文可以用短名称 PackageExample.java必须严格放置在cn/edu/zzu目录下 包名尽量唯一，常用域名逆序 ","date":"2022-02-14","objectID":"/java05/:1:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] package,import和classpath","uri":"/java05/"},{"categories":["Java"],"content":"1.2 import 在PackageExampleTest.java中，使用import关键字来引入PackageExample类 也可以采用import cn.edu.zzu.*;，*代表这个目录下所有文件，但不包括子文件夹和子文件夹内的文件 // cn/edu/zzu/PackageExampleTest.java package cn.edu.zzu; public class PackageExample { } // cn/edu/zzu/PackageExampleTest.java package cn.edu.zzu; import cn.edu.zzu.PackageExample; //如果PackageExample和当前类在同一个目录，可以省略上句import public class PackageExampleTest { public static void main(String[] args) { PackageExample obj = new PackageExample(); //此处可以用类的短名称来引用 } } import规则 import必须全部放在package之后，类定义之前。 多个import的顺序无关 可以用*来引入一个目录下的所有类，比如import java.lang.*;，此意思是引入java.lang下面所有的类文件，但不包括java.lang下面所有的子目录文件，即并不包括java.lang.reflect.*; import尽量精确，不推荐使用*，以免新增的同名程序会使得老程序报错，面临着调用类指代不清的风险 // a/Main.java package a; public class Man { } // b/Main.java package b; public class Man { } // c/Main.java package c; import a.Man; public class Test { public static void main(String[] args) { Man m = new Man(); b.Man m2 = new b.Man(); } } ","date":"2022-02-14","objectID":"/java05/:1:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] package,import和classpath","uri":"/java05/"},{"categories":["Java"],"content":"2 jar文件 jar文件，一种扩展名为jar的文件，是Java所特有的一种文件格式，用于可执行文件的传播。 jar文件实际上是一组class文件的压缩包 项目中引入一个jar文件，就可以使用jar文件中所有类（.class文件），无需类的源码（.java文件）。 ","date":"2022-02-14","objectID":"/java05/:2:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] package,import和classpath","uri":"/java05/"},{"categories":["Java"],"content":"2.1 jar文件优势 jar文件可以包括多个class,比多层目录更加中、简洁实用 jar文件经过压缩，只有一个文件，在网络下载和传播方面，更具有优势 jar文件只包括class，没有包含java文件，在保护源码文件知识版权方面，能够起到更好的作用 将多个class文件压缩成jar文件，可以规定给一个版本号，更容易进行版本控制 ","date":"2022-02-14","objectID":"/java05/:2:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] package,import和classpath","uri":"/java05/"},{"categories":["Java"],"content":"2.2 命令行 手动在c:\\temp创建cn.com.test.Man.java 2.2.1 编译 javac c:\\temp\\cn\\com\\test\\Man.java 2.2.2 运行 java -classpath .;c:\\temp cn.com.test.Man java -cp .;c:temp cn.com.test.Man 第一部分：java，执行命令，是java.exe的简写。 第二部分：-classpath 固定格式参数，可以简写成-cp 第三部分： 是一个（Windows分号，Linux/Mac冒号连接起来的）字符串。按分隔符隔开，得到一个个子路径。 第四部分：主执行类的全称（含包名） 2.2.3 编译和运行规则 编译一个类，需要java文件的全路径，包括扩展名。 运行一个类，需写类名全称（非文件路径），无须写扩展名。 编译类的时候，需要给出这个类的所有依赖（包括依赖的类再次依赖的所有其他类）所在路径。 运行类的时候，需要给出这个类，以及被依赖类的路径总和。 classpath参数也可以包含jar包。如果路径内有空格，请将classpath参数整体加双引号。 classpath写在前面优先级更高。 java -classpath \".;c:\\test.jar;c:\\temp;c:\\a bc\" cn.com.test.Man Java运行时会将classpath按照分隔符裁开，在每个子路径下一次寻找所需要的类。如果子路径是jar文件，那就将jar临时解压，在里面寻找。 ","date":"2022-02-14","objectID":"/java05/:2:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] package,import和classpath","uri":"/java05/"},{"categories":["Java"],"content":"3 Java访问权限 ","date":"2022-02-14","objectID":"/java05/:3:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] package,import和classpath","uri":"/java05/"},{"categories":["Java"],"content":"3.1 四种访问权限 private：私有的，只能本类访问 default：（通常忽略不写）：同一个包内访问 protected：同一个包，子类均可访问 public：公开的，所有类都可以访问 同一个类 同一个包 不同包的子类 不同包的非子类 private √ default √ √ protected √ √ √ public √ √ √ √ ","date":"2022-02-14","objectID":"/java05/:3:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] package,import和classpath","uri":"/java05/"},{"categories":["Java"],"content":"3.2 使用范围 四种都可以用来修饰成员变量、成员方法、构造函数 default 和 public可以修饰类 建议成员变量都是private 建议成员方法都是public ","date":"2022-02-14","objectID":"/java05/:3:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] package,import和classpath","uri":"/java05/"},{"categories":["Java"],"content":"3.3 实例 /* test1/A.java */ package test1; public class A { private int v1 = 1; int v2 = 2; protected int v3 = 3; public int v4 = 4; private void showV1() { System.out.println(v1); } void showV2() { System.out.println(v2); } protected void showV3() { System.out.println(v3); } public void showV4() { System.out.println(v4); } } /* test1/B.java */ package test1; //B and A are in the same package public class B { public void show() { //B is not subclass of A // System.out.println(v1); //error // System.out.println(v2); //error // System.out.println(v3); //error // System.out.println(v4); //error // showV1(); //error // showV2(); //error // showV3(); //error // showV4(); //error A obj = new A(); //System.out.println(obj.v1); error, private System.out.println(obj.v2); System.out.println(obj.v3); System.out.println(obj.v4); //obj.showV1(); error, private obj.showV2(); obj.showV3(); obj.showV4(); } } /* test1/C.java */ package test1; //C is a subclass of A, and in the same package of A. public class C extends A { public void show() { //System.out.println(v1); error, private System.out.println(v2); System.out.println(v3); System.out.println(v4); //showV1(); error, private showV2(); showV3(); showV4(); A obj = new A(); //System.out.println(obj.v1); error, private System.out.println(obj.v2); System.out.println(obj.v3); System.out.println(obj.v4); //obj.showV1(); error, private obj.showV2(); obj.showV3(); obj.showV4(); } } /* test2/D.java */ package test2; import test1.A; public class D extends A{ public void show() { //System.out.println(v1); error, private //System.out.println(v2); error, default System.out.println(v3); System.out.println(v4); //showV1(); error, private //showV2(); error, default showV3(); showV4(); A obj = new A(); //System.out.println(obj.v1); error, private //System.out.println(obj.v2); error, default //System.out.println(obj.v3); error, protected 只能作为子类才能访问 System.out.println(obj.v4); //obj.showV1(); error, private //obj.showV2(); error, default //obj.showV3(); error protected 只能作为子类才能访问 obj.showV4(); } } /* test2/E.java */ package test2; import test1.A; public class E { public void show() { //E is not a subclass of A. And E is not in the same package of A. //System.out.println(v1); error, private //System.out.println(v2); error, default //System.out.println(v3); //System.out.println(v4); //showV1(); error, private //showV2(); error, default //showV3(); //showV4(); A obj = new A(); //System.out.println(obj.v1); error, private //System.out.println(obj.v2); error, default //System.out.println(obj.v3); error, protected 只能作为子类才能访问 System.out.println(obj.v4); //obj.showV1(); error, private //obj.showV2(); error, default //obj.showV3(); error protected 只能作为子类才能访问 obj.showV4(); } } ","date":"2022-02-14","objectID":"/java05/:3:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] package,import和classpath","uri":"/java05/"},{"categories":["MiniProgram"],"content":"微信小程序实现长按触发某一事件","date":"2022-01-19","objectID":"/miniprogram08/","tags":["MiniProgram"],"title":"微信小程序实现长按触发某一事件","uri":"/miniprogram08/"},{"categories":["MiniProgram"],"content":"1 实现代码 ","date":"2022-01-19","objectID":"/miniprogram08/:1:0","tags":["MiniProgram"],"title":"微信小程序实现长按触发某一事件","uri":"/miniprogram08/"},{"categories":["MiniProgram"],"content":"1.1 message/message.js /** * 消息长按部分代码 */ //touch start handleTouchStart: function (e) { this.startTime = e.timeStamp; }, //touch end handleTouchEnd: function (e) { this.endTime = e.timeStamp; }, handleLongPress: function (e) { var that = this; var id = e.currentTarget.dataset.id; wx.showModal({ title: '提示', content: '是否删除这条消息？', success: function (res) { if (res.confirm) { wx.request({ url: app.buildUrl(\"/message/delMess\"), header: app.getRequestHeader(), data: { id: id, }, success: function (res) { if (res.data.code == 200) { that.onLoad(); app.showSuccess(\"消息删除成功！\"); }else{ app.showFail(\"消息删除失败！\"); } } }) } } }) }, ","date":"2022-01-19","objectID":"/miniprogram08/:1:1","tags":["MiniProgram"],"title":"微信小程序实现长按触发某一事件","uri":"/miniprogram08/"},{"categories":["MiniProgram"],"content":"1.2 message/message.wxml \u003cview class=\"message-right-text-box\" bindtouchstart=\"handleTouchStart\" bindtouchend=\"handleTouchEnd\" bindlongpress=\"handleLongPress\" data-id=\"{{item.id}}\"\u003e \u003ctext class=\"message-right-text\"\u003e{{item.message}}\u003c/text\u003e \u003c/view\u003e ","date":"2022-01-19","objectID":"/miniprogram08/:1:2","tags":["MiniProgram"],"title":"微信小程序实现长按触发某一事件","uri":"/miniprogram08/"},{"categories":["MiniProgram"],"content":"2 效果展示 ","date":"2022-01-19","objectID":"/miniprogram08/:2:0","tags":["MiniProgram"],"title":"微信小程序实现长按触发某一事件","uri":"/miniprogram08/"},{"categories":["MiniProgram"],"content":"微信小程序实现左右滑动切换页面","date":"2022-01-18","objectID":"/miniprogram07/","tags":["MiniProgram"],"title":"微信小程序实现左右滑动切换页面","uri":"/miniprogram07/"},{"categories":["MiniProgram"],"content":"概述 很多用户已经有了滑动切换页面的习惯，滑动切页比点击更容易进行操作 看了网上很多相关博客，这个方案在我本人亲测后达到了不错的效果 ","date":"2022-01-18","objectID":"/miniprogram07/:0:0","tags":["MiniProgram"],"title":"微信小程序实现左右滑动切换页面","uri":"/miniprogram07/"},{"categories":["MiniProgram"],"content":"1 实现代码 ","date":"2022-01-18","objectID":"/miniprogram07/:1:0","tags":["MiniProgram"],"title":"微信小程序实现左右滑动切换页面","uri":"/miniprogram07/"},{"categories":["MiniProgram"],"content":"1.1 message/message.js // pages/message/message.js var startX, endX; var moveFlag = true;// 判断执行滑动事件 Page({ //滑动 touchStart: function (e) { startX = e.touches[0].pageX; // 获取触摸时的原点 moveFlag = true; }, // 触摸移动事件 touchMove: function (e) { endX = e.touches[0].pageX; // 获取触摸时的原点 if (moveFlag) { if (endX - startX \u003e 100) { this.moveleft(); moveFlag = false; } if (startX - endX \u003e 100) { this.moveright(); moveFlag = false; } } }, // 触摸结束事件 touchEnd: function (e) { moveFlag = true; // 回复滑动事件 }, // 响应向左滑动 moveleft() { wx.switchTab({ //由于我配置了tabBar，需要tab之间切换，所以使用了swithTab url: '/pages/index/index', }); }, // 响应向右滑动 moveright() { wx.switchTab({ url: '/pages/goal/goal', }); }, }) ","date":"2022-01-18","objectID":"/miniprogram07/:1:1","tags":["MiniProgram"],"title":"微信小程序实现左右滑动切换页面","uri":"/miniprogram07/"},{"categories":["MiniProgram"],"content":"1.2 message/message.wxml \u003cview bindtouchstart=\"touchStart\" bindtouchmove=\"touchMove\" bindtouchend=\"touchEnd\"\u003e \u003c/view\u003e ","date":"2022-01-18","objectID":"/miniprogram07/:1:2","tags":["MiniProgram"],"title":"微信小程序实现左右滑动切换页面","uri":"/miniprogram07/"},{"categories":["MiniProgram"],"content":"2 效果展示 ","date":"2022-01-18","objectID":"/miniprogram07/:2:0","tags":["MiniProgram"],"title":"微信小程序实现左右滑动切换页面","uri":"/miniprogram07/"},{"categories":["MiniProgram"],"content":"微信小程序实现聊天输入框随键盘弹起，内容不被顶起","date":"2022-01-18","objectID":"/miniprogram06/","tags":["MiniProgram"],"title":"微信小程序实现聊天输入框随键盘弹起，内容不被顶起","uri":"/miniprogram06/"},{"categories":["MiniProgram"],"content":"思路 弹出键盘后，不把内容顶起来，监听键盘高度变化，自动设置输入框和内容的高度 ","date":"2022-01-18","objectID":"/miniprogram06/:0:0","tags":["MiniProgram"],"title":"微信小程序实现聊天输入框随键盘弹起，内容不被顶起","uri":"/miniprogram06/"},{"categories":["MiniProgram"],"content":"1 实现代码 ","date":"2022-01-18","objectID":"/miniprogram06/:1:0","tags":["MiniProgram"],"title":"微信小程序实现聊天输入框随键盘弹起，内容不被顶起","uri":"/miniprogram06/"},{"categories":["MiniProgram"],"content":"1.1 message/message.js // pages/message/message.js data: { statsuBarHeight: app.globalData.statsuBarHeight, headHeight: 40, chatListHeight: 0, keyboardHeight: 0, inutPanelHeight: 50, curMessage: \"\", }, //设置聊天窗高度 setChatListHeight() { this.setData({ chatListHeight: app.globalData.sysHeight - app.globalData.statsuBarHeight - this.data.headHeight - this.data.keyboardHeight - this.data.inutPanelHeight }) }, //隐藏键盘 hideKeyboard() { wx.hideKeyboard(); //this.hideMediaPanel(); }, onLoad: function (options) { var that = this; that.getMessage(); this.setChatListHeight(); wx.onKeyboardHeightChange(res =\u003e { //监听键盘高度变化 this.setData({ keyboardHeight: res.height }); this.setChatListHeight(); //this.scroll2Bottom(); }); }, /** * 消息获取 */ inputMessage: function (e) { this.setData({ inputMessage: e.detail.value, }) }, /** * 消息发送 */ setMessage: function () { var that = this; var curMessage = that.data.inputMessage; if (curMessage.trim() === \"\") { app.showFail(\"不可以发送空消息\") return; } wx.request({ url: app.buildUrl(\"/message/setMess\"), header: app.getRequestHeader(), data: { message: this.data.inputMessage, }, success: function (res) { if (res.data.code == 200) { //清空输入框 that.setData({ inputMessage: '' }) app.showSuccess(\"发送成功！\") that.onLoad(); }else{ app.showFail(\"发送失败！\") } } }) }, ","date":"2022-01-18","objectID":"/miniprogram06/:1:1","tags":["MiniProgram"],"title":"微信小程序实现聊天输入框随键盘弹起，内容不被顶起","uri":"/miniprogram06/"},{"categories":["MiniProgram"],"content":"1.2 message/message.json \"usingComponents\": {}, \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTitleText\": \"💌\", \"navigationBarTextStyle\": \"black\" } ","date":"2022-01-18","objectID":"/miniprogram06/:1:2","tags":["MiniProgram"],"title":"微信小程序实现聊天输入框随键盘弹起，内容不被顶起","uri":"/miniprogram06/"},{"categories":["MiniProgram"],"content":"1.3 message/message.wxml \u003cview class=\"input-panel\" style=\"bottom:{{keyboardHeight}}px\"\u003e \u003cinput adjust-position=\"{{false}}\" hold-keyboard=\"{{true}}\" bindinput=\"inputMessage\" value=\"{{inputMessage}}\"/\u003e \u003cview class=\"send-btn\" bindtap=\"setMessage\"\u003e发送\u003c/view\u003e \u003c/view\u003e ","date":"2022-01-18","objectID":"/miniprogram06/:1:3","tags":["MiniProgram"],"title":"微信小程序实现聊天输入框随键盘弹起，内容不被顶起","uri":"/miniprogram06/"},{"categories":["MiniProgram"],"content":"1.4 message/message.wxss .input-panel { display: flex; background: #FBF2F4; height: 100rpx; position: fixed; width:100%; padding:0rpx 20rpx; align-items: center; box-sizing: border-box; } .input-panel input { flex: 1; width: 100%; background: #ffffff; height: 60rpx; line-height: 60rpx; box-sizing: border-box; padding:0px 5px; border-radius: 3px; } .send-btn { display: inline-block; padding: 0rpx 20rpx; color: #fff; background: #c97587; border-radius: 6rpx; line-height:60rpx; margin-left:10rpx; } ","date":"2022-01-18","objectID":"/miniprogram06/:1:4","tags":["MiniProgram"],"title":"微信小程序实现聊天输入框随键盘弹起，内容不被顶起","uri":"/miniprogram06/"},{"categories":["MiniProgram"],"content":"1.5 app.js onLaunch() { const res = wx.getSystemInfoSync() var statusbarH = res.statusBarHeight this.globalData.statsuBarHeight=statusbarH; this.globalData.sysWidth = res.screenWidth; this.globalData.sysHeight = res.screenHeight; }, globalData: { //键盘 statsuBarHeight:0, sysWidth:0, sysHeight:0, }, ","date":"2022-01-18","objectID":"/miniprogram06/:1:5","tags":["MiniProgram"],"title":"微信小程序实现聊天输入框随键盘弹起，内容不被顶起","uri":"/miniprogram06/"},{"categories":["MiniProgram"],"content":"2 效果展示 ","date":"2022-01-18","objectID":"/miniprogram06/:2:0","tags":["MiniProgram"],"title":"微信小程序实现聊天输入框随键盘弹起，内容不被顶起","uri":"/miniprogram06/"},{"categories":["MiniProgram"],"content":"微信小程序之tabBar（官方原生与官方自定义）","date":"2022-01-17","objectID":"/miniprogram05/","tags":["MiniProgram"],"title":"微信小程序之tabBar（官方原生与官方自定义）","uri":"/miniprogram05/"},{"categories":["MiniProgram"],"content":"概述 微信小程序分为tabBar页面与应用内页面，tabBar页面从表面来说就是页面中含有tabBar切换组件的页面，从小程序代码里讲就是在app.json里配置了tarBar选项的页面。 目前有原生tabBar，还有官方的自定义tabBar。 原生tabBar只需要在app.json里配置好相关tab选项就可以了。 官方的自定义tabBar需要在根目录定义一个自定义组件。 ","date":"2022-01-17","objectID":"/miniprogram05/:0:0","tags":["MiniProgram"],"title":"微信小程序之tabBar（官方原生与官方自定义）","uri":"/miniprogram05/"},{"categories":["MiniProgram"],"content":"1 官方原生 tabBar 只需要在app.json中进行配置即可 \"tabBar\": { \"color\": \"#ff0000\", //颜色 \"selectedColor\": \"#ffff00\", //选中时的颜色 \"backgroundColor\": \"#1697eb\", //tab背景色 \"borderStyle\": \"black\", //tabBar盒子上面的border颜色，只支持black 与 white \"list\": [ { \"pagePath\": \"pages/tabOne/tabOne\", //此处路径要写不带 ‘/’的 \"text\": \"tabOne\", //tab名字 \"iconPath\": \"image/icon_API.png\", //tab图标 \"selectedIconPath\": \"image/icon_API_HL.png\" //选中时的tab图标 }, { \"pagePath\": \"pages/tabTwo/tabTwo\", \"text\": \"tabTwo\", \"iconPath\": \"image/icon_API.png\", \"selectedIconPath\": \"image/icon_API_HL.png\" }, { \"pagePath\": \"pages/tabThree/tabThree\", \"text\": \"tabThree\", \"iconPath\": \"image/icon_API.png\", \"selectedIconPath\": \"image/icon_API_HL.png\" }, ], \"position\": \"bottom\", //tabBar的位置 top 或 bottom \"custom\": false //自定义tabBar时为true } ","date":"2022-01-17","objectID":"/miniprogram05/:1:0","tags":["MiniProgram"],"title":"微信小程序之tabBar（官方原生与官方自定义）","uri":"/miniprogram05/"},{"categories":["MiniProgram"],"content":"2 官方自定义tabBar 将app.json中的custom改为true \"tabBar\": { \"custom\": true, \"position\": \"top\", \"list\": [ { \"pagePath\": \"pages/index/index\" }, { \"pagePath\": \"pages/message/message\" }, { \"pagePath\": \"pages/goal/goal\" } ] }, 在根目录新建一个自定义组件 custom-tab-bar cunsom-tab-bar/index.js Component({ data: { selected: 0, color: \"#ffffff\", selectedColor: \"#c97587\", \"list\": [ { \"pagePath\": \"/pages/index/index\", \"text\": \"❤️\", \"iconPath\": \"\", \"selectedIconPath\": \"\" }, { \"pagePath\": \"/pages/message/message\", \"text\": \"💌\", \"iconPath\": \"\", \"selectedIconPath\": \"\" }, { \"pagePath\": \"/pages/goal/goal\", \"text\": \"📝\", \"iconPath\": \"\", \"selectedIconPath\": \"\" }, ], }, attached() { }, methods: { switchTab(e) { const data = e.currentTarget.dataset const url = data.path //切换tab时，改变路由地址 wx.switchTab({url}) this.setData({ //切换tab时，改变当前激活的序号，改变tab颜色图标等样式 selected: data.index }) } } }) custom-tab-bar/index.json { \"component\": true } custom-tab-bar/index.wxml \u003c!--custom-tab-bar/index.wxml--\u003e \u003ccover-view class=\"tab-bar\"\u003e \u003ccover-view class=\"tab-bar-border\"\u003e\u003c/cover-view\u003e \u003ccover-view wx:for=\"{{list}}\" wx:key=\"index\" class=\"tab-bar-item\" style=\"background-color: {{selected === index ? selectedColor : color}}\" data-path=\"{{item.pagePath}}\" data-index=\"{{index}}\" bindtap=\"switchTab\"\u003e \u003c!--\u003ccover-image src=\"{{selected === index ? item.selectedIconPath : item.iconPath}}\"\u003e\u003c/cover-image\u003e--\u003e \u003ccover-view\u003e{{item.text}}\u003c/cover-view\u003e \u003c/cover-view\u003e \u003c/cover-view\u003e custom-tab-bar/index.css .tab-bar { position: fixed; top: 0; left: 0; right: 0; height: 60rpx; background: white; display: flex; padding-bottom: env(safe-area-inset-bottom); } .tab-bar-border { background-color: white; position: absolute; left: 0; top: 0; width: 100%; height: 1px; transform: scaleY(0.5); } .tab-bar-item { flex: 1; text-align: center; display: flex; justify-content: center; align-items: center; flex-direction: column; } .tab-bar-item cover-image { width: 27px; height: 27px; } .tab-bar-item cover-view { font-size: 30rpx; } 在每个tab页面里的tab.json配置usingComponents选项 { \"usingComponents\": {}, \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTitleText\": \"📝\", \"navigationBarTextStyle\": \"black\" } 在每个tab页面的onShow生命周期函数里加上以下代码 onShow: function () { if (typeof this.getTabBar === 'function' \u0026\u0026 this.getTabBar()) { this.getTabBar().setData({ //就是页面显示出来后，让相应的tab改变颜色 图标等样式 selected: 3 // 根据tab的索引值设置 }) } }, ","date":"2022-01-17","objectID":"/miniprogram05/:2:0","tags":["MiniProgram"],"title":"微信小程序之tabBar（官方原生与官方自定义）","uri":"/miniprogram05/"},{"categories":["MiniProgram"],"content":"3 效果展示 ","date":"2022-01-17","objectID":"/miniprogram05/:3:0","tags":["MiniProgram"],"title":"微信小程序之tabBar（官方原生与官方自定义）","uri":"/miniprogram05/"},{"categories":["MiniProgram"],"content":"4 参考资料 参考资料 微信小程序官方文档 微信小程序之tabBar（官方原生与官方自定义） 小程序（三）配置tabbar及自定义tabbar样式 ","date":"2022-01-17","objectID":"/miniprogram05/:4:0","tags":["MiniProgram"],"title":"微信小程序之tabBar（官方原生与官方自定义）","uri":"/miniprogram05/"},{"categories":["MiniProgram"],"content":"微信小程序给图片添加阴影效果","date":"2022-01-16","objectID":"/miniprogram04/","tags":["MiniProgram"],"title":"微信小程序给图片添加阴影效果","uri":"/miniprogram04/"},{"categories":["MiniProgram"],"content":"1 实现方法 实现方法 box-shadow: h-shadow v-shadow blur spread color inset; h-shadow：必需设置的值，定义水平阴影的位置。允许负值。 v-shadow：必需设置的值，定义垂直阴影的位置。允许负值。 blur：可选设置的值，定义模糊距离。 spread：可选设置的值，定义阴影的尺寸。 color ：可选设置的值，定义阴影的颜色。如果没有设置值，颜色值基于浏览器显示，建议设置。 inset：可选设置的值，设置后可将外部阴影 (outset) 改为内部阴影。 ","date":"2022-01-16","objectID":"/miniprogram04/:1:0","tags":["MiniProgram"],"title":"微信小程序给图片添加阴影效果","uri":"/miniprogram04/"},{"categories":["MiniProgram"],"content":"2 代码实例 \u003c!-- pages/index/index.wxml --\u003e \u003cview class=\"couple-box\"\u003e \u003cimage src=\"../../images/w1.jpg\" class=\"couple-image\"\u003e\u003c/image\u003e \u003c/view\u003e /* pages/index/index.wxss */ .couple-image{ width:70%; height:50%; margin-top:60rpx; box-shadow: 15rpx 15rpx 15rpx rgba(10,10,10,.5); } 实现效果如下图所示: ","date":"2022-01-16","objectID":"/miniprogram04/:2:0","tags":["MiniProgram"],"title":"微信小程序给图片添加阴影效果","uri":"/miniprogram04/"},{"categories":["MiniProgram"],"content":"4 参考资料 参考资料 css怎么给图片添加阴影效果？图片添加阴影的两种方法（代码实例） ","date":"2022-01-16","objectID":"/miniprogram04/:3:0","tags":["MiniProgram"],"title":"微信小程序给图片添加阴影效果","uri":"/miniprogram04/"},{"categories":["BugFixes"],"content":"解决 ModuleNotFoundError: No module named 'MySQLdb' 的报错","date":"2022-01-15","objectID":"/bug04/","tags":["BugFixes","Flask","Mysql"],"title":"解决 ModuleNotFoundError: No module named 'MySQLdb' 的报错","uri":"/bug04/"},{"categories":["BugFixes"],"content":"解决 ModuleNotFoundError: No module named ‘MySQLdb’ 的报错 ","date":"2022-01-15","objectID":"/bug04/:0:0","tags":["BugFixes","Flask","Mysql"],"title":"解决 ModuleNotFoundError: No module named 'MySQLdb' 的报错","uri":"/bug04/"},{"categories":["BugFixes"],"content":"系统配置 系统配置 windows 11 python 3.8 Pycharm 2021.3.1 ","date":"2022-01-15","objectID":"/bug04/:0:1","tags":["BugFixes","Flask","Mysql"],"title":"解决 ModuleNotFoundError: No module named 'MySQLdb' 的报错","uri":"/bug04/"},{"categories":["BugFixes"],"content":"报错信息 报错信息 ModuleNotFoundError: No module named ‘MySQLdb’ ","date":"2022-01-15","objectID":"/bug04/:0:2","tags":["BugFixes","Flask","Mysql"],"title":"解决 ModuleNotFoundError: No module named 'MySQLdb' 的报错","uri":"/bug04/"},{"categories":["BugFixes"],"content":"问题分析 问题分析 因为 SQLAlchemy 连接 Mysql 默认驱动是 MySQLdb ，MySQLdb 仅支持 Python2.x ,不支持 Python3 的版本 如果使用 Python3.x 版本时，需要安装并使用额外的库 pymysql ","date":"2022-01-15","objectID":"/bug04/:0:3","tags":["BugFixes","Flask","Mysql"],"title":"解决 ModuleNotFoundError: No module named 'MySQLdb' 的报错","uri":"/bug04/"},{"categories":["BugFixes"],"content":"修复方法 修复方法 安装 pymysql pip install pymysql 引入 pymysql 包 import pymysql pymysql.install_as_MySQLdb() 将 mysql://user:YourPassword@1127.0.0.1:3306/database 改为 mysql+pymysql://user:YourPassword@127.0.0.1:3306/database ","date":"2022-01-15","objectID":"/bug04/:0:4","tags":["BugFixes","Flask","Mysql"],"title":"解决 ModuleNotFoundError: No module named 'MySQLdb' 的报错","uri":"/bug04/"},{"categories":["BugFixes"],"content":"解决 ModuleNotFoundError: No module named 'flask._compat'的报错","date":"2022-01-15","objectID":"/bug03/","tags":["BugFixes","Flask"],"title":"解决 ModuleNotFoundError: No module named 'flask._compat'的报错","uri":"/bug03/"},{"categories":["BugFixes"],"content":"解决 ModuleNotFoundError: No module named ‘flask._compat’ 的报错 ","date":"2022-01-15","objectID":"/bug03/:0:0","tags":["BugFixes","Flask"],"title":"解决 ModuleNotFoundError: No module named 'flask._compat'的报错","uri":"/bug03/"},{"categories":["BugFixes"],"content":"系统配置 系统配置 windows 11 python 3.8 Pycharm 2021.3.1 ","date":"2022-01-15","objectID":"/bug03/:0:1","tags":["BugFixes","Flask"],"title":"解决 ModuleNotFoundError: No module named 'flask._compat'的报错","uri":"/bug03/"},{"categories":["BugFixes"],"content":"报错信息 报错信息 ModuleNotFoundError: No module named ‘flask._compat’ ","date":"2022-01-15","objectID":"/bug03/:0:2","tags":["BugFixes","Flask"],"title":"解决 ModuleNotFoundError: No module named 'flask._compat'的报错","uri":"/bug03/"},{"categories":["BugFixes"],"content":"问题分析 问题分析 系统默认下载了最新版本的 Flask Flask扩展升级到 2.0 后删除了一些文件，导致出现问题 ","date":"2022-01-15","objectID":"/bug03/:0:3","tags":["BugFixes","Flask"],"title":"解决 ModuleNotFoundError: No module named 'flask._compat'的报错","uri":"/bug03/"},{"categories":["BugFixes"],"content":"修复方法 修复方法 降低Flask的版本为1.1.4 pip uninstall flask pip install Flask==1.1.4 ","date":"2022-01-15","objectID":"/bug03/:0:4","tags":["BugFixes","Flask"],"title":"解决 ModuleNotFoundError: No module named 'flask._compat'的报错","uri":"/bug03/"},{"categories":["Java"],"content":"[Java核心技术] static、final和常量设计","date":"2022-01-12","objectID":"/java04/","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"Java 核心技术读书笔记——Java static、final和常量设计 ","date":"2022-01-12","objectID":"/java04/:0:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"1 static static 静态的，Java中特殊的关键字，可作用在变量、方法、类、匿名方法块 ","date":"2022-01-12","objectID":"/java04/:1:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"1.2 静态变量 静态变量，类共有成员 public class Potato { static int price = 5; String content = \"\"; public Potato(int price, String content) { this.price = price; this.content = content; } public static void main(String[] a) { System.out.println(Potato.price); //Potato.content wrong System.out.println(\"----------------------------------\"); Potato obj1 = new Potato(10,\"青椒土豆丝\"); // 以下两行都输出10，Potato.price 和 obj1.price 在内存中是同一个东西 System.out.println(Potato.price); System.out.println(obj1.price); System.out.println(\"----------------------------------\"); Potato obj2 = new Potato(20,\"酸辣土豆丝\"); System.out.println(Potato.price); System.out.println(obj2.price); } } /** * * 输出结果： * 5 * ---------------------------------- * 10 * 10 * ---------------------------------- * 20 * 20 * */ static变量只依赖于类存在（通过类访问即可），不依赖于对象实例存在。即可以用过Potato.price即可访问 所有的对象实例，如上例中的obj1和obj2关于price变量的值共享存储在一个共同的空间（栈） ","date":"2022-01-12","objectID":"/java04/:1:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"1.2 静态方法 静态方法也无需通过对象来引用，而通过类名可以直接引用。 静态方法中，只能使用静态变量，不能使用非静态变量。 静态方法不能调用非静态方法。 public class StaticMethodTest { int a = 111111; static int b = 222222; public static void hello() { System.out.println(\"000000\"); System.out.println(b); //System.out.println(a); //error, cannot call non-static variables //hi() //error, cannot call non-static method } public void hi() { System.out.println(\"333333\"); hello(); //ok, call static methods System.out.println(a); //ok, call non-static variables System.out.println(b); //ok, call static variables } public static void main(String[] a) { StaticMethodTest.hello(); //StaticMethodTest.hi(); //error, 不能使用类名来引用非静态方法 StaticMethodTest foo = new StaticMethodTest(); foo.hello(); //warning, but it is ok foo.hi(); //right } } ","date":"2022-01-12","objectID":"/java04/:1:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"1.3 static修饰类（内部类） 使用机会较少 ","date":"2022-01-12","objectID":"/java04/:1:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"1.4 static块 static块只在类第一次被加载时调用，即程序运行期间，这段代码只运行一次 执行顺序：static块 \u003e 匿名块 \u003e 构造函数 不建议编写块代码，块代码会给程序带来混淆。建议将块代码封装成函数再调用。 // StaticBlock.java class StaticBlock { //staticl block \u003e anonymous block \u003e constructor function // 静态代码块 static { System.out.println(\"22222222222222222222\"); } // 匿名代码块 { System.out.println(\"11111111111111111111\"); } // 构造函数 public StaticBlock() { System.out.println(\"33333333333333333333\"); } // 匿名代码块 { System.out.println(\"44444444444444444444\"); } } //StaticBlockTest.java public class StaticBlockTest { public static void main(String[] args) { System.out.println(\"000000000000000\"); // TODO Auto-generated method stub StaticBlock obj1 = new StaticBlock(); StaticBlock obj2 = new StaticBlock(); } } /** * * 运行结果： * 000000000000000 * 22222222222222222222 * 11111111111111111111 * 44444444444444444444 * 33333333333333333333 * 11111111111111111111 * 44444444444444444444 * 33333333333333333333 * */ ","date":"2022-01-12","objectID":"/java04/:1:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"2 单例模式（Singleton） 单例模式（单态模式，Singleton），保证一个类有且只有一个对象 采用 static 来共享对象实例 采用 private 构造函数，防止外界 new 操作 限定某一个类在整个程序运行过程中，只能保留一个实例对象在内存空间 public class Singleton { private static Singleton obj = new Singleton(); //共享同一个对象 private String content; private Singleton() //确保只能在类内部调用构造函数 { this.content = \"abc\"; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public static Singleton getInstance() { //静态方法使用静态变量 //另外可以使用方法内的临时变量，但是不能引用非静态的成员变量 return obj; } public static void main(String[] args) { Singleton obj1 = Singleton.getInstance(); System.out.println(obj1.getContent()); // abc Singleton obj2 = Singleton.getInstance(); System.out.println(obj2.getContent()); // abc obj2.setContent(\"def\"); System.out.println(obj1.getContent()); System.out.println(obj2.getContent()); System.out.println(obj1 == obj2); // true, obj1和obj2指向同一个对象 } } 单例模式是GoF的23种设计模式（Design Pattern）中经典的一种，属于创造型模型类型。 笔记 设计模式：在软件开发过程中，经过验证的，用于解决在特定环境下的、重复出现的、特定问题的结局方案。 ","date":"2022-01-12","objectID":"/java04/:2:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"3 final Java 的 final关键字可以用来修饰类、方法、字段 final的类，不能被继承 final public class FinalFather { } class Son1 extends FinalFather { } 父类中如果有final的方法，子类中不能改写此方法 // FinalMethodFather.java public class FinalMethodFather { public final void f1() { } } //FinalMethodSon.java public class FinalMethodSon extends FinalMethodFather{ public void f1() // error Cannot override the final method from FinalMethodFather { } } final的变量，不能再次赋值 如果是基本型的变量，不能修改其值 public class FinalPrimitiveType { public static void main(String[] args) { // TODO Auto-generated method stub final int a = 5; a=10; // error The final local vaiable a cannot be assigned. It must be blank and not using a compound assignment } } 如果是实例对象，那么不能修改其指针（但是可以修改对象内的值） class FinalObject { int a = 10; } public class FinalObjectTest { public static void main(String[] args) { final FinalObject obj1 = new FinalObject(); System.out.println(obj1.a); obj1.a = 20; System.out.println(obj1.a); obj1 = new FinalObject(); //final对象不能变更指针 } } ","date":"2022-01-12","objectID":"/java04/:3:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"4 常量设计和常量池 ","date":"2022-01-12","objectID":"/java04/:4:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"4.1 常量 常量：一种不会修改的变量 不能修改，final 不会修改/只读/只要一份，static 方便访问 public final和static可以颠倒顺序 常量的定义 public static final String = DEFAULT_COUNTRY = \"China\"; //建议变量名字全大写，以字符相连，如 DEFAULT_COUNTRY 一种特殊的常量：接口内定义的变量默认为常量 ","date":"2022-01-12","objectID":"/java04/:4:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"4.2 常量池 Java为很多基本类型的包装类/字符串都建立常量池 常量池：相同的值只存储一份，节省内存，共享访问 基本类型的包装类 Boolean: true,false Byte, Character: \\u00000 —— \\u007f (0 —— 127) Short, Int, Long: -128 ~ 127 Float, Double: 没有缓存（常量池） public class CacheTest { public static void main(String[] args) { Boolean b1 = true; //true,false Boolean b2 = true; System.out.println(\"Boolean Test: \" + String.valueOf(b1 == b2)); //true Byte b3 = 127; //\\u0000-\\u007f Byte b4 = 127; System.out.println(\"Byte Test: \" + String.valueOf(b3 == b4)); //true Character c1 = 127; //\\u0000-\\u007f Character c2 = 127; System.out.println(\"Character Test: \" + String.valueOf(c1 == c2)); //true Short s1 = -128; //-128~127 Short s2 = -128; System.out.println(\"Short Test: \" + String.valueOf(s1 == s2)); //true Integer i1 = -128; //-128~127 Integer i2 = -128; System.out.println(\"Integer Test: \" + String.valueOf(i1 == i2)); //true Long l1 = -128L; //-128~127 Long l2 = -128L; System.out.println(\"Long Test: \" + String.valueOf(l1 == l2)); //true Float f1 = 0.5f; Float f2 = 0.5f; System.out.println(\"Float Test: \" + String.valueOf(f1 == f2)); //false Double d1 = 0.5; Double d2 = 0.5; System.out.println(\"Double Test: \" + String.valueOf(d1 == d2)); //false } } Java 为常量字符串都建立常量池缓存机制 字符串常量 public class StringConstantTest { public static void main(String[] args) { String s1 = \"abc\"; String s2 = \"abc\"; String s3 = \"ab\" + \"c\"; //都是常量，编译器将优化，下同 String s4 = \"a\" + \"b\" + \"c\"; System.out.println(s1 == s2); //true System.out.println(s1 == s3); //true System.out.println(s1 == s4); //true } } 基本类型的包装类和字符串有两种创建方式 常量式（字面量）赋值创建，放在栈内存（将被常量化） Integer a = 10; Strign b = \"abc\"; new 对象进行创建，放在堆内存（不会常量化） Integer c = new Integer(10); String d = new String(\"abc\"); 这两种创建方式导致创建的对象存放的位置不同。 栈内存读取速度快但容量小，堆内存读取速度慢但容量大。 查看 BoxClassTest.java 分析 Integer类 /** * * 基本类型和包装类比较，将对包装类自动拆箱 * 对象比较，比较地址 * 加法（+）会自动拆箱 * */ public class BoxClassTest { public static void main(String[] args) { int i1 = 10; Integer i2 = 10; // 自动装箱 System.out.println(i1 == i2); //true // 自动拆箱 基本类型和包装类进行比较，包装类自动拆箱 Integer i3 = new Integer(10); System.out.println(i1 == i3); //true // 自动拆箱 基本类型和包装类进行比较，包装类自动拆箱 System.out.println(i2 == i3); //false // 两个对象比较，比较其地址。 // i2是常量，放在栈内存常量池中，i3是new出对象，放在堆内存中 Integer i4 = new Integer(5); Integer i5 = new Integer(5); System.out.println(i1 == (i4+i5)); //true System.out.println(i2 == (i4+i5)); //true System.out.println(i3 == (i4+i5)); //true // i4+i5 操作将会使得i4,i5自动拆箱为基本类型并运算得到10. // 基础类型10和对象比较, 将会使对象自动拆箱，做基本类型比较 Integer i6 = i4 + i5; // +操作使得i4,i5自动拆箱，得到10，因此i6 == i2. System.out.println(i1 == i6); //true System.out.println(i2 == i6); //true System.out.println(i3 == i6); //false } } 查看 StringNewTest.java 分析 String类 /** * * 常量赋值（堆内存）和 new 创建（栈内存）不是同一个对象 * 编译器只会优化确定的字符串，并缓存 * */ public class StringNewTest { public static void main(String[] args) { String s0 = \"abcdef\"; String s1 = \"abc\"; String s2 = \"abc\"; String s3 = new String(\"abc\"); String s4 = new String(\"abc\"); System.out.println(s1 == s2); //true 常量池 System.out.println(s1 == s3); //false 一个栈内存，一个堆内存 System.out.println(s3 == s4); //false 两个都是堆内存 System.out.println(\"=========================\"); String s5 = s1 + \"def\"; //涉及到变量，故编译器不优化 String s6 = \"abc\" + \"def\"; //都是常量 编译器会自动优化成abcdef String s7 = \"abc\" + new String (\"def\");//涉及到new对象，编译器不优化 System.out.println(s5 == s6); //false System.out.println(s5 == s7); //false System.out.println(s6 == s7); //false System.out.println(s0 == s6); //true System.out.println(\"=========================\"); String s8 = s3 + \"def\";//涉及到new对象，编译器不优化 String s9 = s4 + \"def\";//涉及到new对象，编译器不优化 String s10 = s3 + new String(\"def\");//涉及到new对象，编译器不优化 System.out.println(s8 == s9); //false System.out.println(s8 == s10); //false System.out.println(s9 == s10); //false } } ","date":"2022-01-12","objectID":"/java04/:4:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"5 不可变对象和字符串 ","date":"2022-01-12","objectID":"/java04/:5:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"5.1 不可变对象（Immutable Object） 一旦创建，这个对象（状态/值）不能被更改 其内在的成员变量的值就不能再次修改 八个基本类型的包装类 String, BigInteger和BigDecimal等 不可变对象也是传指针（引用） 由于不可变，临时变量指向新内存，外部实参指针不改动 //示例一: String a = new String(\"abc\"); // a -\u003e abc String b = a; // b -\u003e abc System.out.println(b); a = \"def\"; // a -\u003e def b -\u003e abc System.out.println(b); // abc //示例二: public static void change(String b) { b = \"def\"; } a = new String(\"abc\"); // a -\u003e abc change(a); // a -\u003e abc,b -\u003e abc 函数体内部 b -\u003e def System.out.println(a); //abc 5.1.1 如何创建不可变对象 immutable 对象是不可改变的，有改变，需clone/new一个对象进行修改 所有的属性都是final 和 private的 不提供setter方法 类是final的，或者所有的方法都是final的 类中包含mutable对象，那么返回拷贝需要深度clone 5.1.2 优点 只读，线程安全 并发读，提高性能 可以重复使用 5.1.3 缺点 制造垃圾，浪费空间 对不可变对象进行修改时，会新开辟空间，旧对象则被搁置，知道垃圾回收 ","date":"2022-01-12","objectID":"/java04/:5:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"5.2 字符串 字符串是Java使用最多的类，是一种典型的不可变对象 String定义 String a = \"abd\"; //常量赋值，栈内存分配 String b = new String(\"abc\"); //new对象，堆内存分配 字符串内容比较：equals方法 是否指向同一个对象：指针比较 == Java 常量池 保存在编译期间就已经确定的内存 是一块特殊的内存 相同的常量字符串只存储一份，节省内存，共享访问 5.2.1 字符串加法 String a = \"abc\"; a = a + \"def\"; //由于String不可修改，效率差 使用StringBuffer/StringBuilder类的append方法进行修改 StringBuffer/StringBuilder的对象都是可变对象 StringBuffer 同步，线程安全，修改快速 StringBuilder 不同步，线程不安全，修改更快 import java.util.Calendar; public class StringAppendTest { public static void main(String[] args) { int n = 50000; Calendar t1 = Calendar.getInstance(); String a = new String(); for(int i=0;i\u003cn;i++) { a = a + i + \",\"; } System.out.println(Calendar.getInstance().getTimeInMillis() - t1.getTimeInMillis()); Calendar t2 = Calendar.getInstance(); StringBuffer b = new StringBuffer(\"\"); for(int i=0;i\u003cn;i++) { b.append(i); b.append(\",\"); } System.out.println(Calendar.getInstance().getTimeInMillis() - t2.getTimeInMillis()); Calendar t3 = Calendar.getInstance(); StringBuilder c = new StringBuilder(\"\"); for(int i=0;i\u003cn;i++) { b.append(i); b.append(\",\"); } System.out.println(Calendar.getInstance().getTimeInMillis() - t3.getTimeInMillis()); } } /** * * 输出结果： * 8829 * 19 * 5 * */ ","date":"2022-01-12","objectID":"/java04/:5:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] static、final和常量设计","uri":"/java04/"},{"categories":["Java"],"content":"[Java核心技术] 继承、接口和抽象类","date":"2022-01-11","objectID":"/java03/","tags":["Java","JavaVolume"],"title":"[Java核心技术] 继承、接口和抽象类","uri":"/java03/"},{"categories":["Java"],"content":"Java 核心技术读书笔记——Java 继承、接口和抽象类 ","date":"2022-01-11","objectID":"/java03/:0:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 继承、接口和抽象类","uri":"/java03/"},{"categories":["Java"],"content":"1 继承 面向对象编程语言和面向过程的编程语言最突出的特点就是变量类型的继承 面向过程编程语言没有继承，出现很多类型重复定义 对象可以分成若干类别，类别内的对象属性和方法具有一定的共同点 将共同点提取出来，及形成了父类/基类/超类 其他类则自动成为子类/派生类 笔记 public class Human{ int height; int weight; public void eat(){} } public class Man{ int height; int weight; public void eat(){}; public void plough(){}; //耕田 } public class Woman{ int height; int weight; public void eat(){}; public void weave(){}; //织布 } public class Man extends Human{ public void plough(){}; //耕田 } public class Woman extends Human{ public void weave(){}; //织布 } 子类继承父类所有的属性和方法（但不能直接访问private成员） 根据信息隐藏原则：子类会继承父类所有方法。可以直接使用。 子类也会继承父类的父类的所有属性和方法（但不能直接访问private成员） 在同样方法名和参数情况下，本类的方法会比父类的方法优先级高。 单根继承原则：每个类都只能继承一个类 如果不写extends，Java类都默认继承java.lang.Object类 Java所有类从java.lang.Object开始，构建出一个类型继承树 Object类里面默认就有clone、equals、finalize、getClass、hashCode、toString等方法 ","date":"2022-01-11","objectID":"/java03/:1:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 继承、接口和抽象类","uri":"/java03/"},{"categories":["Java"],"content":"2 抽象类和接口 ","date":"2022-01-11","objectID":"/java03/:2:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 继承、接口和抽象类","uri":"/java03/"},{"categories":["Java"],"content":"2.1 抽象类 类：属性（0或多个）+ 方法（0或多个） 一个完整（健康）的类：所有的方法都有实现（方法体） 类可以没有方法，但是有方法就肯定要实现，这才是个完整的类 一个完整（健康）的类才可以被实例化，被new出来 如果一个类暂时有方法未实现，需要被定义为抽象类 抽象类关键字abstract声明 抽象类组成： 成员变量，个数不限 具体方法，方法有实现，个数不限 抽象方法，加abstract关键字，个数不限 public abstract class Shape{ int area; // 当图形未知时，无法给胡calArea的具体实现，因此此方法被定义为abstract // calArea() 是一个不完整/不健康的方法，因为它没有方法体。 public abstract void calArea(); } 抽象类也是类。一个类继承于抽象类，就不能继承于其他的（抽象）类。 子类可以继承于抽象类，但是一定要实现父类们所有abstract方法。如果不能完全实现，那么子类也必须被定义为抽象类。 只有实现父类（们）的所有抽象方法，才能变成完整类。 ","date":"2022-01-11","objectID":"/java03/:2:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] 继承、接口和抽象类","uri":"/java03/"},{"categories":["Java"],"content":"2.2 接口 如果类的所有方法都没有实现，那么这个类就算是接口（interface） public interface Animal{ public void eat(); public void move(); } 类只可以继承（extends）一个类（可以是抽象类也可以是普通类），但是可以实现（implements）多个接口，继承和实现可以同时发生。 继承抽象类，必须实现所有abstract的方法； 实现多个接口，必须实现接口中所定义的所有方法； 一个类的方法，只会在当前类或者父类中定义，肯定不会在所实现的父类接口中定义 接口不算类，或者说是“特殊”的类 接口可以继承多个接口，没有实现的方法将会叠加 类实现接口，就必须实现所有未实现的方法，如果没有全部实现，那么只能成为一个抽象类 接口里可以定义变量，但是一般是常量 extends 必须写在 implements 前面 //Animal.java public interface Animal { public void eat(); public void move(); } //LandAnimal.java public abstract class LandAnimal implements Animal { public abstract void eat() ; public void move() { System.out.println(\"I can walk by feet\"); } } //ClimbTree.java public interface ClimbTree { public void climb(); } //Rabbit.java public class Rabbit extends LandAnimal implements ClimbTree { public void climb() { System.out.println(\"Rabbit: I can climb\"); } public void eat() { System.out.println(\"Rabbit: I can eat\"); } } 抽象类和接口的相同点：两者都不能被实例化，不能new操作 抽象类和接口的不同点： 抽象类abstradt，接口interface 抽象类可以有部分方法实现，接口所有方法不能有实现 一个类只能继承（extends）一个（抽象）类，实现（implements）多个接口 接口可以继承（extends）多个接口 抽象类有构造函数，接口没有构造函数 抽象类可以有main，也能运行，接口没有main函数 抽象类方法可以有private/protected，接口方法都是public ","date":"2022-01-11","objectID":"/java03/:2:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] 继承、接口和抽象类","uri":"/java03/"},{"categories":["Java"],"content":"3 转型、多态和契约设计 ","date":"2022-01-11","objectID":"/java03/:3:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 继承、接口和抽象类","uri":"/java03/"},{"categories":["Java"],"content":"3.1 类转型 变量支持相互转化，比如 int a = (int)3.5; 类型可以相互转型，但是只限制于有继承关系的类。 子类可以转换成父类（向上转型），而父类不可以转换为子类（向下转型）。 Human obj1 = new Man(); // Ok, Man extends Human Man obj2 = new Human(); // illegal, Man is a derived class Human 父类转子类，有一种特殊情况例外，即父类本身就是从子类转化而来的。 Human obj1 = new Man(); // Ok, Man extends Human Man obj2 = (Man) obj1; // Ok, because obj1 is born from Man class ","date":"2022-01-11","objectID":"/java03/:3:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] 继承、接口和抽象类","uri":"/java03/"},{"categories":["Java"],"content":"3.2 多态 类型转换，带来的作用就是多态。 子类继承父类的所有方法，但子类可以定义一个名字、参数和父类一样的方法，这种行为就是重写（覆盖，覆写） 子类的方法优先级高于父类。 // Human.java public class Human { int height; int weight; public void eat() { System.out.println(\"I can eat!\"); } } // Man.java public class Man extends Human { public void eat() { System.out.println(\"I can eat more\"); } public void plough() { } public static void main(String[] a) { Man obj1 = new Man(); obj1.eat(); // call Man.eat() Human obj2 = (Human) obj1; // 类转型 obj1 -\u003e obj2 obj2.eat(); // call Man.eat() Man obj3 = (Man) obj2; obj3.eat(); // call Man.eat() } } 多态的作用 以统一的接口来操纵某一类中不同对象的动态行为 对象之间的解耦 // Animal.java public interface Animal { public void eat(); public void move(); } // Cat.java public class Cat implements Animal { public void eat() { System.out.println(\"Cat: I can eat\"); } public void move(){ System.out.println(\"Cat: I can move\"); } } // Dog.java public class Dog implements Animal { public void eat() { System.out.println(\"Dog: I can eat\"); } public void move() { System.out.println(\"Dog: I can move\"); } } // AnimalTest.java public class AnimalTest { public static void haveLunch(Animal a) { a.eat(); } public static void main(String[] args) { Animal[] as = new Animal[4]; as[0] = new Cat(); as[1] = new Dog(); as[2] = new Cat(); as[3] = new Dog(); for(int i=0;i\u003cas.length;i++) { as[i].move(); //调用每个元素的自身的move方法 } for(int i=0;i\u003cas.length;i++) { haveLunch(as[i]); } haveLunch(new Cat()); //Animal a = new Cat(); haveLunch(a); haveLunch(new Dog()); haveLunch( new Animal() { public void eat() { System.out.println(\"I can eat from an anonymous class\"); } public void move() { System.out.println(\"I can move from an anonymous class\"); } }); } public static void huveLunch(Animal a){ a.eat(); } } /** * * 运行结果： * Dog: I can move * Cat: I can move * Dog: I can move * Cat: I can eat * Dog: I can eat * Cat: I can eat * Dog: I can eat * Cat: I can eat * Dog: I can eat * I can eat from an anonymous class * */ ","date":"2022-01-11","objectID":"/java03/:3:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] 继承、接口和抽象类","uri":"/java03/"},{"categories":["Java"],"content":"3.3 契约设计 契约：规定规范了对象应该包含的行为方法 接口定义了方法的名称、参数和返回值，规范了派生类的行为 基于接口，利用转型和多态，不影响真正方法的调用，成功地将调用类和被调用类解耦 被调用类（haveLunch只和Animal有联系） // Animal 是一个接口，里面所有的方法都是空的，没有方法体。 public static void huveLunch(Animal a){ a.eat(); } 调用类 haveLunch(new Cat()); //Animal a = new Cat(); haveLunch(a); haveLunch(new Dog()); haveLunch( // 匿名类只在此句用一次就结束了， // 只需要传进来一个实现Animal接口的对象，就可以运行haveLunch方法。 new Animal() { public void eat() { System.out.println(\"I can eat from an anonymous class\"); } public void move() { System.out.println(\"I can move from an anonymous class\"); } }); ","date":"2022-01-11","objectID":"/java03/:3:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] 继承、接口和抽象类","uri":"/java03/"},{"categories":["DB"],"content":"实体-联系模型","date":"2021-03-08","objectID":"/db02/","tags":["Database"],"title":"实体-联系模型","uri":"/db02/"},{"categories":["DB"],"content":"实体-联系模型 ","date":"2021-03-08","objectID":"/db02/:0:0","tags":["Database"],"title":"实体-联系模型","uri":"/db02/"},{"categories":["DB"],"content":"1 相关概念 实体： 是客观存在并且可以相互区分的任何事物。 实体集： 是具有相同属性的实体的集合。 联系： 是多个实体之间的相互关联。 联系集： 是相同类型联系的集合。形式地说，设$E_1, E_2, …, E_n$是 $n（n \\ge 2）$个实体集，它们不必互不相同。联系集$R$是${(e_1, e_2, …, e_n) | e_1 \\in E_1, e_2 \\in E_2, …, e_n \\in E_n}$的一个子集，其中$(e1, e2, …, en) \\in R$是一个联系，并称$ei（1 \\le i \\le n）$是该联系的参与者，n 是联系的度（元）。 简单属性： 是不能划分成更小的部分的属性。 复合属性： 是可以划分成更小部分的属性（即可以分成一些其他属性）。 单值属性： 是一个特定的实体在该属性上只能取单个值的属性。 多值属性： 是特定的实体在该属性上可以取多个值的属性。 基本属性： 是其值不能通过其他属性的值推导出来的属性。 派生属性： 又称计算属性，是其值可以从其他相关属性或实体计算得到的属性。 码： 是主码或候选码的简称。 主码： 是指数据库的设计者选中的，用来区分同一实体集中不同实体的候选码。 候选码： 其真子集都不是超码的极小超码称为候选码。 超码： 其值可以惟一确定实体集中每个实体的属性集称为该实体集的超码。 一对一联系： 如果E1中的每个实体最多与E2中的一个实体相关联，并且E2中的每个实体也最多与E1中的一个实体相关联，则称E1和E2之间联系为一对一联系。 一对多联系： 如果E1中的每个实体都可以与E2中任意多个实体相关联，而E2中的每个实体最多与E1中一个实体相关联，则称这种联系为E1到E2的一对多联系。 多对一联系： 如果E1中的每个实体最多与E2中的一个实体相关联，而E2中的每个实体都可以与E1中任意多个实体相关联，则称这种联系为E1到E2的多对一联系。 多对多联系： 如果E1中的每个实体都可以与E2中任意多个实体相关联，并且E2中的每个实体也可以与E1中任意多个实体相关联，则称E1和E2之间联系为多对多联系。 ","date":"2021-03-08","objectID":"/db02/:1:0","tags":["Database"],"title":"实体-联系模型","uri":"/db02/"},{"categories":["DB"],"content":"数据库系统概述","date":"2021-03-08","objectID":"/db01/","tags":["Database"],"title":"数据库系统概述","uri":"/db01/"},{"categories":["DB"],"content":"数据库系统概述 ","date":"2021-03-08","objectID":"/db01/:0:0","tags":["Database"],"title":"数据库系统概述","uri":"/db01/"},{"categories":["DB"],"content":"1 相关概念 ","date":"2021-03-08","objectID":"/db01/:1:0","tags":["Database"],"title":"数据库系统概述","uri":"/db01/"},{"categories":["DB"],"content":"1.1 DD 分布式数据库系统 分布式数据库系统（Distributed DataBase，DD）通常使用较小的计算机系统，每台计算机可单独放在一个地方，都有DBMS的一份完整拷贝副本，都有自己局部的数据库。位于不同地点的许多计算机通过网络互相连接，共同组成一个完整的、全局的大型数据库。 ","date":"2021-03-08","objectID":"/db01/:1:1","tags":["Database"],"title":"数据库系统概述","uri":"/db01/"},{"categories":["DB"],"content":"1.2 DB 数据库 数据库（Database，简称DB）是持久储存在计算机中、有组织的、可共享的大量数据的集合 数据库中的数据按一定的数据模型组织、描述和存储可以被各种用户共享 具有较小的冗余度 较高的数据独立性 易于扩展 ","date":"2021-03-08","objectID":"/db01/:1:2","tags":["Database"],"title":"数据库系统概述","uri":"/db01/"},{"categories":["DB"],"content":"1.3 DBS 数据库系统 数据库系统（Database System，DBS）由数据库、DBMS（及其开发工具）、应用系统和数据库管理员组成。 ","date":"2021-03-08","objectID":"/db01/:1:3","tags":["Database"],"title":"数据库系统概述","uri":"/db01/"},{"categories":["DB"],"content":"1.4 DBMS 数据库管理系统 数据库管理系统（Database Management System，DBMS）是一种重要的程序设计系统，它由一个相互关联的数据集合和一组访问这些数据的程序组成。这个数据集合称为数据库，它包含了一个企业、政府部门或一个单位的全部信息。DBMS的基本目标是提供一个方便、有效地访问这些信息的环境。 ","date":"2021-03-08","objectID":"/db01/:1:4","tags":["Database"],"title":"数据库系统概述","uri":"/db01/"},{"categories":["DB"],"content":"1.5 DDL 数据定义语言（Data Definition Language，DDL）是用于描述数据库中要存储的现实世界实体的语言。 ","date":"2021-03-08","objectID":"/db01/:1:5","tags":["Database"],"title":"数据库系统概述","uri":"/db01/"},{"categories":["DB"],"content":"1.6 DML 数据操纵语言 用户可以使用数据操纵语言（Data Manipulation Language，DML），表达对按照某种数据模式组织起来的数据的访问 ","date":"2021-03-08","objectID":"/db01/:1:6","tags":["Database"],"title":"数据库系统概述","uri":"/db01/"},{"categories":["DB"],"content":"1.7 DCL 数据控制语言 数据控制语言（Data Control Language，DCL）用于定义用户对数据对象的访问权限和审计 DCL提供授权语句保证数据的安全性 DCL还提供了回收授权和建立审计的语句 ","date":"2021-03-08","objectID":"/db01/:1:7","tags":["Database"],"title":"数据库系统概述","uri":"/db01/"},{"categories":["DB"],"content":"1.8 DBA 数据库管理员 负责管理数据库，实施数据的集中控制的人称为数据库管理员（Database Administrator，DBA） ","date":"2021-03-08","objectID":"/db01/:1:8","tags":["Database"],"title":"数据库系统概述","uri":"/db01/"},{"categories":["DB"],"content":"2 数据模型的三要素及其作用 数据模型的三个基本要素是： 数据结构：描述数据库的对象和对象之间的联系，是对数据的静态描述。 数据操作：数据库中各种对象允许的操作和操作规则，使对系统的动态描述。 完整性约束：一组完整性规则，用以限定符合数据模型的数据库状态和状态的变化，保证数据的正确、有效和相容。 对于关系数据库而言，关系模型只有一种数据结构——关系。现实世界中的对象和对象之间的联系都用关系表示。关系是元组的集合。从用户角度来看，关系是一张二维表。 在关系模型中，定义数据操作的方法有两种：关系代数和关系演算。关系代数显式地定义了一些关系运算，而关系演算的基础是一阶谓词逻辑，它用逻辑公式表示查询结果必须满足的条件。 关系模型的完整性约束包括实体完整性、参照完整性和用户定义的完整性。其中实体完整性和参照完整性是通用完整性约束，由关系模型明确定义。 ","date":"2021-03-08","objectID":"/db01/:2:0","tags":["Database"],"title":"数据库系统概述","uri":"/db01/"},{"categories":["DB"],"content":"3 简要说明数据库的三级模式结构。 数据库系统的三级模式是指外模式、模式和内模式。 外模式是特定数据库用户的数据视图，是与某一具体应用相关的数据局部逻辑结构的描述。 模式是数据库中全体数据的总体逻辑结构描述，是所有用户的公共数据视图。 内模式是数据物理结构和存储方式的描述，定义数据在数据库内部的表示方式。 数据库系统的三级模式提供了三个层次的数据抽象。这样做的一个优点是可以隐蔽数据存储细节，从而隐蔽系统内部的复杂性，简化系统的用户界面。另一个优点是可以带来数据的独立性。 ","date":"2021-03-08","objectID":"/db01/:3:0","tags":["Database"],"title":"数据库系统概述","uri":"/db01/"},{"categories":["DB"],"content":"4 数据库系统的三级模式结构中是如何实现数据的物理独立性、逻辑独立性的 所谓数据独立性是指数据独立于应用程序，分数据的逻辑独立性和数据的物理独立性两种。 数据的逻辑独立性是指应用程序与数据库的逻辑结构之间的相互独立性。当数据的逻辑结构改变时，通过修改外模式-模式映像，保持外模式不变，从而使得建立在外模式上的应用程序也可以不变。 数据的物理独立性是指应用程序与存储在磁盘上的数据库中数据之间的相互独立性。 当数据的物理存储结构改变时，通过修改模式-内模式映像，保持模式不变。由于外模式是定义在模式上的，模式不变，则外模式不需要改变，从而使得建立在外模式上的应用程序也可以不变。 数据的逻辑独立性是指数据的逻辑结构改变不影响应用程序，而数据的物理独立性是指数据的物理组织（存储结构）改变不影响应用程序。 ","date":"2021-03-08","objectID":"/db01/:4:0","tags":["Database"],"title":"数据库系统概述","uri":"/db01/"},{"categories":["LeetCode"],"content":"58. 最后一个单词的长度","date":"2021-03-07","objectID":"/58/","tags":["LeetCode","Java"],"title":"58. 最后一个单词的长度","uri":"/58/"},{"categories":["LeetCode"],"content":"给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。 单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。 简单 给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。 单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。  示例 1： 输入：s = \"Hello World\" 输出：5 示例 2： 输入：s = \" \" 输出：0  提示： 1 \u003c= s.length \u003c= 104 s 仅有英文字母和空格 ' ' 组成 ","date":"2021-03-07","objectID":"/58/:0:0","tags":["LeetCode","Java"],"title":"58. 最后一个单词的长度","uri":"/58/"},{"categories":["LeetCode"],"content":"1 解题思路 方法一：使用split()函数对所给字符串进行“空格分割”，取出最后一项并求长度 方法二：利用for循环，对所给字符串从后往前遍历，每循环一次length加一，当遇到' '时停止遍历 ","date":"2021-03-07","objectID":"/58/:1:0","tags":["LeetCode","Java"],"title":"58. 最后一个单词的长度","uri":"/58/"},{"categories":["LeetCode"],"content":"2 代码实现 //方法一： class Solution { public int lengthOfLastWord(String s) { s = s.trim(); if (s == null || s.isEmpty()) { return 0; } String[] strs = s.split(\" \"); return strs[strs.length-1].length(); } } //方法二： class Solution { public int lengthOfLastWord(String s) { int length = 0; for (int i = s.length() - 1; i \u003e= 0; i--) { if (s.charAt(i) != ' ') { length++; } else if (length != 0) { return length; } } return length; } } ","date":"2021-03-07","objectID":"/58/:2:0","tags":["LeetCode","Java"],"title":"58. 最后一个单词的长度","uri":"/58/"},{"categories":["LeetCode"],"content":"3 题目链接 https://leetcode-cn.com/problems/length-of-last-word/ ","date":"2021-03-07","objectID":"/58/:3:0","tags":["LeetCode","Java"],"title":"58. 最后一个单词的长度","uri":"/58/"},{"categories":["LeetCode"],"content":"53. 最大子序和","date":"2021-03-07","objectID":"/53/","tags":["LeetCode","Java"],"title":"53. 最大子序和","uri":"/53/"},{"categories":["LeetCode"],"content":"给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 简单 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1] 输出：1 示例 3： 输入：nums = [0] 输出：0 示例 4： 输入：nums = [-1] 输出：-1 示例 5： 输入：nums = [-100000] 输出：-100000  提示： 1 \u003c= nums.length \u003c= 3 * 104 -105 \u003c= nums[i] \u003c= 105 ","date":"2021-03-07","objectID":"/53/:0:0","tags":["LeetCode","Java"],"title":"53. 最大子序和","uri":"/53/"},{"categories":["LeetCode"],"content":"1 解题思路 对于含有正数的序列而言，最大子序列肯定是正数，所以头尾肯定都是正数。我们可以从第一个正数开始算起，每往后加一个数便更新一次和的最大值；当当前和成为负数时，则表明此前序列无法为后面提供最大子序列和，因此必须重新确定序列首项。 示例 以 示例 1 为例： num sum res begin 0 -2 -2 -2 -2 1 1 1 -3 -2 1 4 4 4 -1 3 4 2 5 5 1 6 6 -5 1 6 4 5 6 end 输出 res ","date":"2021-03-07","objectID":"/53/:1:0","tags":["LeetCode","Java"],"title":"53. 最大子序和","uri":"/53/"},{"categories":["LeetCode"],"content":"2 代码实现 class Solution { public int maxSubArray(int[] nums) { int res = nums[0]; int sum = 0; for (int num : nums) { if (sum \u003e 0){ sum += num; } else { sum = num; } res = Math.max(res, sum); } return res; } } ","date":"2021-03-07","objectID":"/53/:2:0","tags":["LeetCode","Java"],"title":"53. 最大子序和","uri":"/53/"},{"categories":["LeetCode"],"content":"3 题目链接 https://leetcode-cn.com/problems/maximum-subarray/ ","date":"2021-03-07","objectID":"/53/:3:0","tags":["LeetCode","Java"],"title":"53. 最大子序和","uri":"/53/"},{"categories":["LeetCode"],"content":"38. 外观数列","date":"2021-03-04","objectID":"/38/","tags":["LeetCode","Java"],"title":"38. 外观数列","uri":"/38/"},{"categories":["LeetCode"],"content":"给定一个正整数 n ，输出外观数列的第 n 项。 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。 简单 给定一个正整数 n ，输出外观数列的第 n 项。 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。 你可以将其视作是由递归公式定义的数字字符串序列： countAndSay(1) = “1” countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。 前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 111221 第一项是数字 1 描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 \"11\" 描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 \"21\" 描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 \"1211\" 描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 \"111221\" 要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。 例如，数字字符串 “3322251” 的描述如下图： 示例 1： 输入：n = 1 输出：\"1\" 解释：这是一个基本样例。 示例 2： 输入：n = 4 输出：\"1211\" 解释： countAndSay(1) = \"1\" countAndSay(2) = 读 \"1\" = 一 个 1 = \"11\" countAndSay(3) = 读 \"11\" = 二 个 1 = \"21\" countAndSay(4) = 读 \"21\" = 一 个 2 + 一 个 1 = \"12\" + \"11\" = \"1211\"  提示： 1 \u003c= n \u003c= 30 ","date":"2021-03-04","objectID":"/38/:0:0","tags":["LeetCode","Java"],"title":"38. 外观数列","uri":"/38/"},{"categories":["LeetCode"],"content":"1 解题思路 利用递归求出countAndSay(n-1) 对 countAndSay(n-1)进行解析的流程图如图1.1所示： 图1.1 流程图流程图 \" 图1.1 流程图 ","date":"2021-03-04","objectID":"/38/:1:0","tags":["LeetCode","Java"],"title":"38. 外观数列","uri":"/38/"},{"categories":["LeetCode"],"content":"2 代码实现 class Solution { public String countAndSay(int n) { if( n == 1) return \"1\"; String num = countAndSay(n - 1); StringBuilder s = new StringBuilder(); for(int i = 0; i \u003c num.length(); i++){ int count = 1; while(i \u003c num.length()-1 \u0026\u0026 num.charAt(i) == num.charAt(i+1)){ count++; i++; } s.append(count); s.append(num.charAt(i)); } return s.toString(); } } ","date":"2021-03-04","objectID":"/38/:2:0","tags":["LeetCode","Java"],"title":"38. 外观数列","uri":"/38/"},{"categories":["LeetCode"],"content":"3 题目链接 https://leetcode-cn.com/problems/count-and-say ","date":"2021-03-04","objectID":"/38/:3:0","tags":["LeetCode","Java"],"title":"38. 外观数列","uri":"/38/"},{"categories":["LeetCode"],"content":"35. 搜索插入位置","date":"2021-03-04","objectID":"/35/","tags":["LeetCode","Java"],"title":"35. 搜索插入位置","uri":"/35/"},{"categories":["LeetCode"],"content":"给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 简单 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 ","date":"2021-03-04","objectID":"/35/:0:0","tags":["LeetCode","Java"],"title":"35. 搜索插入位置","uri":"/35/"},{"categories":["LeetCode"],"content":"1 解题思路 使用二分查找即可解决 示例 以 示例 1 为例： left right mid nums[mid] 0 3 1 3 2 3 2 5 查找成功，返回 left ，即 2 ","date":"2021-03-04","objectID":"/35/:1:0","tags":["LeetCode","Java"],"title":"35. 搜索插入位置","uri":"/35/"},{"categories":["LeetCode"],"content":"2 代码实现 class Solution { public int searchInsert(int[] nums, int target) { int right = nums.length-1; int left = 0; while(left\u003c=right){ int mid = (left+right)/2; if(target == nums[mid]){ return mid; } if(target \u003e nums[mid]){ left = mid+1; } if(target \u003c nums[mid]){ right = mid-1; } } return left; } } ","date":"2021-03-04","objectID":"/35/:2:0","tags":["LeetCode","Java"],"title":"35. 搜索插入位置","uri":"/35/"},{"categories":["LeetCode"],"content":"3 题目链接 https://leetcode-cn.com/problems/search-insert-position/ ","date":"2021-03-04","objectID":"/35/:3:0","tags":["LeetCode","Java"],"title":"35. 搜索插入位置","uri":"/35/"},{"categories":["LeetCode"],"content":"28. 实现 strStr()","date":"2021-02-27","objectID":"/28/","tags":["LeetCode","Java"],"title":"28. 实现 strStr()","uri":"/28/"},{"categories":["LeetCode"],"content":"实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 简单 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = \"hello\", needle = \"ll\" 输出: 2 示例 2: 输入: haystack = \"aaaaa\", needle = \"bba\" 输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 ","date":"2021-02-27","objectID":"/28/:0:0","tags":["LeetCode","Java"],"title":"28. 实现 strStr()","uri":"/28/"},{"categories":["LeetCode"],"content":"1 解题思路 使用 j 进行统计haystack与needle连续相同的数量 利用 i 对haystack字符串数组进行遍历 如果 i 所指字符与 j 所指字符相等，j 加 1 如果 j 的长度等于needle的长度，则查找成功，返回i-j 如果 i 所指字符与 j 所指字符不相等，j 置 0，从i-j处重新开始查找 如果haystack剩余的长度小于needle，直接返回 -1 遍历结束，查找失败，返回 -1 示例 以 示例 1 为例： j i needle.charAt(j) haystack.charAt(i) 0 0 l h 0 1 l e 0 2 l l 1 3 l l 查找成功，返回 i-j ，即2 ","date":"2021-02-27","objectID":"/28/:1:0","tags":["LeetCode","Java"],"title":"28. 实现 strStr()","uri":"/28/"},{"categories":["LeetCode"],"content":"2 代码实现 class Solution { public int strStr(String haystack, String needle) { if (needle.length() == 0) return 0; int len = needle.length(); int j = 0; for(int i =0; i \u003c haystack.length(); i++ ){ if(haystack.charAt(i)==needle.charAt(j)){ if (j == len - 1) { return i - j; } j++; } else { i = i - j; j = 0; if (haystack.length() - i \u003c len) { return -1; } } } return -1; } } ","date":"2021-02-27","objectID":"/28/:2:0","tags":["LeetCode","Java"],"title":"28. 实现 strStr()","uri":"/28/"},{"categories":["LeetCode"],"content":"3 题目链接 https://leetcode-cn.com/problems/implement-strstr/ ","date":"2021-02-27","objectID":"/28/:3:0","tags":["LeetCode","Java"],"title":"28. 实现 strStr()","uri":"/28/"},{"categories":["LeetCode"],"content":"27. 移除元素","date":"2021-02-26","objectID":"/27/","tags":["LeetCode","Java"],"title":"27. 移除元素","uri":"/27/"},{"categories":["LeetCode"],"content":"给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 简单 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 va 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。  说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u003c len; i++) { print(nums[i]); } 示例 1： 输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 50 0 \u003c= val \u003c= 100 ","date":"2021-02-26","objectID":"/27/:0:0","tags":["LeetCode","Java"],"title":"27. 移除元素","uri":"/27/"},{"categories":["LeetCode"],"content":"1 解题思路 利用双指针的思想，用 i 去找有没有和 val 相同的元素； 如果有，需要将 i 右移； 如果没有，需要将 i 所指元素赋值给 j 所指元素； 只有这样才能将前 j 项中与 val 相同的元素覆盖； 最后返回 j 即可。 示例 以 示例 1 为例： j i nums[j] nums[i] nums 0 0 3 3 [3,2,2,3] 0 1 3 2 [2,2,2,3] 1 2 2 2 [2,2,2,3] 2 3 2 3 [2,2,2,3] 返回 j，即 2 ","date":"2021-02-26","objectID":"/27/:1:0","tags":["LeetCode","Java"],"title":"27. 移除元素","uri":"/27/"},{"categories":["LeetCode"],"content":"2 代码实现 class Solution { public int removeElement(int[] nums, int val) { int j = 0; for(int i = 0; i \u003c nums.length; i++){ if(nums[i]!=val){ nums[j] = nums[i]; j++; } } return j; } } ","date":"2021-02-26","objectID":"/27/:2:0","tags":["LeetCode","Java"],"title":"27. 移除元素","uri":"/27/"},{"categories":["LeetCode"],"content":"3 题目链接 https://leetcode-cn.com/problems/remove-element/ ","date":"2021-02-26","objectID":"/27/:3:0","tags":["LeetCode","Java"],"title":"27. 移除元素","uri":"/27/"},{"categories":["LeetCode"],"content":"26. 删除排序数组中的重复项","date":"2021-02-26","objectID":"/26/","tags":["LeetCode","Java"],"title":"26. 删除排序数组中的重复项","uri":"/26/"},{"categories":["LeetCode"],"content":"给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 简单 给定一个排序数组，你需要在 原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i \u003c len; i++) { print(nums[i]); } ","date":"2021-02-26","objectID":"/26/:0:0","tags":["LeetCode","Java"],"title":"26. 删除排序数组中的重复项","uri":"/26/"},{"categories":["LeetCode"],"content":"1 解题思路 利用双指针的思想，用 i 去找有没有和 j 相同的元素； 如果有，需要将 i 右移； 如果没有，需要将 i 所指元素赋值给 j + 1 所指元素； 只有这样才能将之前重复的元素给覆盖； 最后返回 j + 1 即可，其表示非重复元素的个数。 示例 以 示例 1 为例： j i nums[j] nums[i] nums 0 1 1 1 [1,1,2] 0 2 1 2 [1,2,2] 1 end 返回 j+1，即 2 ","date":"2021-02-26","objectID":"/26/:1:0","tags":["LeetCode","Java"],"title":"26. 删除排序数组中的重复项","uri":"/26/"},{"categories":["LeetCode"],"content":"2 代码实现 class Solution { public int removeDuplicates(int[] nums) { int j = 0; for(int i=1;i\u003cnums.length;i++){ if(nums[j] != nums[i]){ nums[++j] = nums[i]; } } return j+1; } } ","date":"2021-02-26","objectID":"/26/:2:0","tags":["LeetCode","Java"],"title":"26. 删除排序数组中的重复项","uri":"/26/"},{"categories":["LeetCode"],"content":"3 题目链接 https://leetcode-cn.com/problems/merge-two-sorted-lists/ ","date":"2021-02-26","objectID":"/26/:3:0","tags":["LeetCode","Java"],"title":"26. 删除排序数组中的重复项","uri":"/26/"},{"categories":["LeetCode"],"content":"21. 合并两个有序链表","date":"2021-02-25","objectID":"/21/","tags":["LeetCode","Java"],"title":"21. 合并两个有序链表","uri":"/21/"},{"categories":["LeetCode"],"content":"将两个升序链表合并为一个新的 升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 简单 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2： 输入：l1 = [], l2 = [] 输出：[] 示例 3： 输入：l1 = [], l2 = [0] 输出：[0] 提示： 两个链表的节点数目范围是 [0, 50] -100 \u003c= Node.val \u003c= 100 l1 和 l2 均按 非递减顺序 排列 ","date":"2021-02-25","objectID":"/21/:0:0","tags":["LeetCode","Java"],"title":"21. 合并两个有序链表","uri":"/21/"},{"categories":["LeetCode"],"content":"1 代码实现 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) return l2; if (l2 == null) return l1; ListNode res = l1.val \u003c l2.val ? l1 : l2; res.next = mergeTwoLists(res.next, l1.val \u003e= l2.val ? l1 : l2); return res; } } ","date":"2021-02-25","objectID":"/21/:1:0","tags":["LeetCode","Java"],"title":"21. 合并两个有序链表","uri":"/21/"},{"categories":["LeetCode"],"content":"2 题目链接 https://leetcode-cn.com/problems/merge-two-sorted-lists/ ","date":"2021-02-25","objectID":"/21/:2:0","tags":["LeetCode","Java"],"title":"21. 合并两个有序链表","uri":"/21/"},{"categories":["LeetCode"],"content":"20. 有效的括号","date":"2021-02-25","objectID":"/20/","tags":["LeetCode","Java"],"title":"20. 有效的括号","uri":"/20/"},{"categories":["LeetCode"],"content":"给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 简单 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 输入：s = \"()\" 输出：true 示例 2： 输入：s = \"()[]{}\" 输出：true 示例 3： 输入：s = \"(]\" 输出：false 示例 4： 输入：s = \"([)]\" 输出：false 示例 5： 输入：s = \"{[]}\" 输出：true 提示： 1 \u003c= s.length \u003c= 104 s 仅由括号 '()[]{}' 组成 ","date":"2021-02-25","objectID":"/20/:0:0","tags":["LeetCode","Java"],"title":"20. 有效的括号","uri":"/20/"},{"categories":["LeetCode"],"content":"1 解题思路 数据结构中栈的应用的经典问题——括号匹配 ","date":"2021-02-25","objectID":"/20/:1:0","tags":["LeetCode","Java"],"title":"20. 有效的括号","uri":"/20/"},{"categories":["LeetCode"],"content":"2 代码实现 class Solution { public boolean isValid(String s) { Stack\u003cCharacter\u003e stack = new Stack\u003cCharacter\u003e(); for(char c : s.toCharArray()){ if(c == '(') stack.push(')'); else if(c == '[') stack.push(']'); else if(c == '{') stack.push('}'); else if(stack.isEmpty() || c != stack.pop()) return false; } return stack.isEmpty(); } } ","date":"2021-02-25","objectID":"/20/:2:0","tags":["LeetCode","Java"],"title":"20. 有效的括号","uri":"/20/"},{"categories":["LeetCode"],"content":"3 题目链接 https://leetcode-cn.com/problems/valid-parentheses/ ","date":"2021-02-25","objectID":"/20/:3:0","tags":["LeetCode","Java"],"title":"20. 有效的括号","uri":"/20/"},{"categories":["LeetCode"],"content":"14. 最长公共前缀","date":"2021-02-25","objectID":"/14/","tags":["LeetCode","Java"],"title":"14. 最长公共前缀","uri":"/14/"},{"categories":["LeetCode"],"content":"编写一个函数来查找字符串数组中的最长公共前缀。 简单 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\" 示例 1： 输入：strs = [\"flower\",\"flow\",\"flight\"] 输出：\"fl\" 示例 2： 输入：strs = [\"dog\",\"racecar\",\"car\"] 输出：\"\" 解释：输入不存在公共前缀。 提示： 0 \u003c= strs.length \u003c= 200 0 \u003c= strs[i].length \u003c= 200 strs[i] 仅由小写英文字母组成 ","date":"2021-02-25","objectID":"/14/:0:0","tags":["LeetCode","Java"],"title":"14. 最长公共前缀","uri":"/14/"},{"categories":["LeetCode"],"content":"1 解题思路 字符串数组长度为 0 ，返回 \"\" 字符串数组长度为 1 ，返回 strs[0] 选择strs[0]为初始结果 对字符串数组进行遍历 如果 strs[i] 不是以 result 开始，则让 result 变短 示例 以 示例 1 为例： i strs[i] result 0 flower flower 1 flow flowe 1 flow flow 2 flight flo 2 flight fl 输出结果 \"fl\" ","date":"2021-02-25","objectID":"/14/:1:0","tags":["LeetCode","Java"],"title":"14. 最长公共前缀","uri":"/14/"},{"categories":["LeetCode"],"content":"2 代码实现 class Solution { public String longestCommonPrefix(String[] strs) { if (strs.length == 0) return \"\"; if (strs.length == 1) return strs[0]; String result = strs[0]; for (int i = 0; i \u003c strs.length; i++) { if (!strs[i].startsWith(result)) { // 对 result 进行裁剪 result = result.substring(0, result.length() - 1); i--; } } return result; } } ","date":"2021-02-25","objectID":"/14/:2:0","tags":["LeetCode","Java"],"title":"14. 最长公共前缀","uri":"/14/"},{"categories":["LeetCode"],"content":"3 题目链接 https://leetcode-cn.com/problems/longest-common-prefix/ ","date":"2021-02-25","objectID":"/14/:3:0","tags":["LeetCode","Java"],"title":"14. 最长公共前缀","uri":"/14/"},{"categories":["LeetCode"],"content":"13. 罗马数字转整数","date":"2021-02-25","objectID":"/13/","tags":["LeetCode","Java"],"title":"13. 罗马数字转整数","uri":"/13/"},{"categories":["LeetCode"],"content":"罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 简单 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX +V+ II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。  示例 1: 输入: \"III\" 输出: 3 示例 2: 输入: \"IV\" 输出: 4 示例 3: 输入: \"IX\" 输出: 9 示例 4: 输入: \"LVIII\" 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: \"MCMXCIV\" 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 提示： 1 \u003c= s.length \u003c= 15 s 仅含字符 ('I', ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M') 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。 IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。 ","date":"2021-02-25","objectID":"/13/:0:0","tags":["LeetCode","Java"],"title":"13. 罗马数字转整数","uri":"/13/"},{"categories":["LeetCode"],"content":"1 解题思路 此题的难点在于IV（4）、IX（9）等数字的计算，根据下表可分析，这些字符的特征为左边 \u003c 右边，且数值等于右边 - 左边 字符 数值 计算 IV 4 V - I IX 9 X - I XL 50 L - X XC 100 C - X CD 500 D - C DM 1000 M - D 建立HashMap，存入 I， V， X， L，C，D 和 M 七个字符及对应的数值。 对给出的罗马数字逐个字符进行判断 若左\u003c右，则减去左 否则，添加左 示例 以 示例 5 为例： 左 右 左\u003c右？ sum M C false 1000 C M true 900 M X false 1900 X C true 1890 C I false 1990 I V true 1989 V end false 1994 输出结果 1994 ","date":"2021-02-25","objectID":"/13/:1:0","tags":["LeetCode","Java"],"title":"13. 罗马数字转整数","uri":"/13/"},{"categories":["LeetCode"],"content":"2 代码实现 class Solution { public int romanToInt(String s) { HashMap\u003cCharacter, Integer\u003e map = new HashMap\u003c\u003e(); map.put('I',1); map.put('V',5); map.put('X',10); map.put('L',50); map.put('C',100); map.put('D',500); map.put('M',1000); char[] str = s.toCharArray(); int sum = 0; for (int i = 0; i \u003c str.length; i++) { if( i+1 \u003c str.length \u0026\u0026 map.get(str[i]) \u003c map.get(str[i+1])) { sum -= map.get(str[i]); }else { sum += map.get(str[i]); } } return sum; } } ","date":"2021-02-25","objectID":"/13/:2:0","tags":["LeetCode","Java"],"title":"13. 罗马数字转整数","uri":"/13/"},{"categories":["LeetCode"],"content":"3 题目链接 https://leetcode-cn.com/problems/palindrome-number/ ","date":"2021-02-25","objectID":"/13/:3:0","tags":["LeetCode","Java"],"title":"13. 罗马数字转整数","uri":"/13/"},{"categories":["LeetCode"],"content":"9. 回文数","date":"2021-02-25","objectID":"/9/","tags":["LeetCode","Java"],"title":"9. 回文数","uri":"/9/"},{"categories":["LeetCode"],"content":"给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 简单 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。 示例 1： 输入：x = 121 输出：true 示例 2： 输入：x = -121 输出：false 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3： 输入：x = 10 输出：false 解释：从右向左读, 为 01 。因此它不是一个回文数。 示例 4： 输入：x = -101 输出：false 提示： $-2^{31} \u003c= x \u003c= 2^{31} - 1$ ","date":"2021-02-25","objectID":"/9/:0:0","tags":["LeetCode","Java"],"title":"9. 回文数","uri":"/9/"},{"categories":["LeetCode"],"content":"1 解题思路 0 为回文数，复数和10的倍数都不是回文数 利用7. 整数反转中的方法将 x 反转 当 x 不为 0 时 将 n 扩大为原来的十倍（相当于每位的数字向左移一位），同时 n 加上 x 的个位数字 n = n * 10 + x % 10; x 整除 10 （相当于删除掉个位） 当 x 为 0 时结束 若 反转前后大小相等则为回文数 示例 以 示例 1 为例： x n while begin 0 true 121 1 true 12 12 true 1 121 true 0 end false 反转前后均为121，输出 true ","date":"2021-02-25","objectID":"/9/:1:0","tags":["LeetCode","Java"],"title":"9. 回文数","uri":"/9/"},{"categories":["LeetCode"],"content":"2 代码实现 class Solution { public boolean isPalindrome(int x) { if(x \u003c 0 || x % 10==0) return false; if(x == 0) return true; int temp = x; int n = 0; while(x!=0){ n = n * 10 + x % 10; x = x / 10; } if(temp==n) return true; return false; } } ","date":"2021-02-25","objectID":"/9/:2:0","tags":["LeetCode","Java"],"title":"9. 回文数","uri":"/9/"},{"categories":["LeetCode"],"content":"3 题目链接 https://leetcode-cn.com/problems/palindrome-number/ ","date":"2021-02-25","objectID":"/9/:3:0","tags":["LeetCode","Java"],"title":"9. 回文数","uri":"/9/"},{"categories":["LeetCode"],"content":"7. 整数反转","date":"2021-02-25","objectID":"/7/","tags":["LeetCode","Java"],"title":"7. 整数反转","uri":"/7/"},{"categories":["LeetCode"],"content":"给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。 简单 给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [ $ −2^{31} $ , $ 2^{31} −1$ ] ，就返回 0 。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x = 123 输出：321 示例 2： 输入：x = -123 输出：-321 示例 3： 输入：x = 120 输出：21 示例 4： 输入：x = 0 输出：0 提示： $-2^{31} \u003c= x \u003c= 2^{31} - 1$ ","date":"2021-02-25","objectID":"/7/:0:0","tags":["LeetCode","Java"],"title":"7. 整数反转","uri":"/7/"},{"categories":["LeetCode"],"content":"1 解题思路 定义 long 型数据 n 当 x 不为 0 时 将 n 扩大为原来的十倍（相当于每位的数字向左移一位），同时 n 加上 x 的个位数字 n = n * 10 + x % 10; x 整除 10 （相当于删除掉个位） 当 x 为 0 时结束 利用强制类型转换将n转换为int型，若转换前后大小不变则未越界，否则返回 0 示例 以 示例 1 为例： x n while begin 0 true 123 3 true 12 32 true 1 321 true 0 end false 对 n 进行强制类型转换，转换前后相等，返回 321 ","date":"2021-02-25","objectID":"/7/:1:0","tags":["LeetCode","Java"],"title":"7. 整数反转","uri":"/7/"},{"categories":["LeetCode"],"content":"2 代码实现 class Solution { public int reverse(int x) { long n = 0; while(x!=0){ n = n * 10 + x % 10; x /= 10; } return (int)n==n?(int)n:0; } } ","date":"2021-02-25","objectID":"/7/:2:0","tags":["LeetCode","Java"],"title":"7. 整数反转","uri":"/7/"},{"categories":["LeetCode"],"content":"3 题目链接 https://leetcode-cn.com/problems/reverse-integer/ ","date":"2021-02-25","objectID":"/7/:3:0","tags":["LeetCode","Java"],"title":"7. 整数反转","uri":"/7/"},{"categories":["LeetCode"],"content":"1. 两数之和","date":"2021-02-25","objectID":"/1/","tags":["LeetCode","Java"],"title":"1. 两数之和","uri":"/1/"},{"categories":["LeetCode"],"content":"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个整数，并返回它们的数组下标。 简单 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] 提示： 2 \u003c= nums.length \u003c= 103 -109 \u003c= nums[i] \u003c= 109 -109 \u003c= target \u003c= 109 只会存在一个有效答案 ","date":"2021-02-25","objectID":"/1/:0:0","tags":["LeetCode","Java"],"title":"1. 两数之和","uri":"/1/"},{"categories":["LeetCode"],"content":"1 解题思路 建立空HashMap，其中key为补数，vlaue为下标。 HashMap\u003cInteger,Integer\u003e hash = new HashMap\u003cInteger,Integer\u003e(); 每遍历nums中一个数nums[i]，就去HashMap中进行查找，是否存在key与nums[i]相等 若存在： 则nums[i]为符合条件的整数之一，下标为i，另一个整数的下标为HashMap中key=nums[i]所对应的value值； 若不存在： 则将补数 key = (target - nums[i]) , value = i 存入HashMap中； hash.put(target - nums[i]),i); 示例 以 示例 1 为例： i nums[i] HashMap 结果 0 2 { 7=0 } fail 1 7 { 7=0 } success HashMap中存在key = nums[i]，查找成功! 第一个下标为i= 1，第二个下标为hash.get(nums[i]) = 0 ","date":"2021-02-25","objectID":"/1/:1:0","tags":["LeetCode","Java"],"title":"1. 两数之和","uri":"/1/"},{"categories":["LeetCode"],"content":"2 代码实现 class Solution { public int[] twoSum(int[] nums, int target) { // 建立结果数组 int[] result = new int[2]; // 哈希表 HashMap\u003cInteger,Integer\u003e hash = new HashMap\u003cInteger,Integer\u003e(); for(int i = 0; i \u003c nums.length; i++){ // 存在，返回结果 if(hash.containsKey(nums[i])){ result[0] = i; result[1] = hash.get(nums[i]); return result; } // 不存在，将数据存入 hash.put(target-nums[i],i); } return result; } } ","date":"2021-02-25","objectID":"/1/:2:0","tags":["LeetCode","Java"],"title":"1. 两数之和","uri":"/1/"},{"categories":["LeetCode"],"content":"3 题目链接 https://leetcode-cn.com/problems/two-sum/ ","date":"2021-02-25","objectID":"/1/:3:0","tags":["LeetCode","Java"],"title":"1. 两数之和","uri":"/1/"},{"categories":["Java"],"content":"[Java核心技术] 面向对象","date":"2021-02-23","objectID":"/java02/","tags":["Java","JavaVolume"],"title":"[Java核心技术] 面向对象","uri":"/java02/"},{"categories":["Java"],"content":"Java 核心技术读书笔记——Java面向对象 ","date":"2021-02-23","objectID":"/java02/:0:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 面向对象","uri":"/java02/"},{"categories":["Java"],"content":"1 面向对象思想 笔记 对像是一个变量； 类就是类型（是规范，是定义），从万千对象中抽取共性； 类规定了对象应该有的属性内容和方法； 对象是类的具体实现，是活生生的； ","date":"2021-02-23","objectID":"/java02/:1:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 面向对象","uri":"/java02/"},{"categories":["Java"],"content":"2 类 类（ class） 是构造对象的模板或蓝图。由类构造（construct）对象的过程称为创建类的实例 （instance）。 // 最简单的类 class A{ } ","date":"2021-02-23","objectID":"/java02/:2:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 面向对象","uri":"/java02/"},{"categories":["Java"],"content":"3 对象 ","date":"2021-02-23","objectID":"/java02/:3:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 面向对象","uri":"/java02/"},{"categories":["Java"],"content":"3.1 对象的三个主要特性 对象的行为（behavior）：可以对对象施加哪些操作，或可以对对象施加哪些方法？ 对象的状态（state）：当施加那些方法时，对象如何响应？ 对象标识（identity）：如何辨别具有相同行为与状态的不同对象？ 笔记 A obj1 = new A(); A obj2 = new A(); 以上两个对象，它们的类型都是A，但是这是两个不同的对象，在内存中有不同的存放地址。因此，没有两个对象是完全一样的。 ","date":"2021-02-23","objectID":"/java02/:3:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] 面向对象","uri":"/java02/"},{"categories":["Java"],"content":"3.2 对象的赋值方式 对象赋值是Reference赋值，基本类型是直接值拷贝 //MyNumber.java class MyNumber { int num = 5; } //ReferenceTest.java public class ReferenceTest { public static void main(String[] args) { // 基本类型的变量值小，可直接拷贝 int num1 = 5; int num2 = num1; System.out.println(\"num1: \" + num1 + \", num2: \" + num2); // num1: 5, num2: 5 num2 = 10; System.out.println(\"num1: \" + num1 + \", num2: \" + num2); // num1: 5, num2: 10 MyNumber obj1 = new MyNumber(); MyNumber obj2 = new MyNumber(); System.out.println(obj1.num); // 5 System.out.println(obj2.num); // 5 System.out.println(\"======接下来输出新值=====\"); obj2 = obj1; /** * 5 5 * ⇑ ⇖ * obj1 obj2 * * 对象包含多个值，不容易复制，赋值采用共享同一块内存区域； * obj1 和 obj2 指向了同一个 5 * */ obj2.num = 10; /** * 10 5 * ⇑ ⇖ * obj1 obj2 * */ System.out.println(obj1.num); // 10 System.out.println(obj2.num); // 10 } } //ArgumentPassingTest public class ArgumentPassingTest { public static void main(String[] args) { int a = 1, b = 2; swap(a,b); /** * 1 2 1 2 * ⇑ ⇑ ⇑ ⇑ * a b m n * * swap的形参为int型，int直接赋值， * 调用后内存中出现 a b m n * m n 的交换并不影响 a b 的交换 * */ System.out.println(\"a is \" + a + \", b is \" + b); //a=1, b=2 没有交换 MyNumber obj1 = new MyNumber(); MyNumber obj2 = new MyNumber(); obj2.num = 10; swap(obj1, obj2); /** * 5 10 * ⇗ ⇖ ⇗ ⇖ * obj1 obj3 obj2 obj4 * * 对象包含多个值，不容易复制，赋值采用共享同一块内存区域； * obj1 和 obj3 指向同一块内存； * obj2 和 obj4 指向同一块内存； */ System.out.println(\"obj1 is \" + obj1.num + \", obj2 is \" + obj2.num); // obj1 10, obj2 5 交换成功 } public static void swap(int m, int n) //swap的形参为int型，int直接赋值 { int s = m; m = n; n = s; } public static void swap(MyNumber obj3, MyNumber obj4) { int s = obj3.num; obj3.num = obj4.num; obj4.num = s; } } ","date":"2021-02-23","objectID":"/java02/:3:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] 面向对象","uri":"/java02/"},{"categories":["Java"],"content":"4 构造函数 Java构造函数的名称必须和类名一样，且没有返回值 public class A{ int id; public A(int id2){ id = id2; } } Java有构造函数，但是没有析构函数 构造函数是制造对象的过程（在内存中开辟一个空间存储数据） 析构函数是清楚对象的过程（将一个数据对象清空） 每个变量都是有生命周期的，它只能存储在离它最近的一对{}中 public class LifeCycleTest { public static void main(String[] args) { int a=0; // a 在main函数中都是active //i只能活在for循环中 for(int i=0; i\u003c5; i++) { int k = 0; k++; } if(a\u003e0) { Object obj1 = new Object(); //obj1 只能在if分支中 System.out.println(\"a is positive\"); } else { Object obj2 = new Object(); //obj2只能在else分支中 System.out.println(\"a is non-positive\"); } } } 当变量被创建时，变量将占据内存，当变量消亡时，系统将收回内存 Java 具有内存自动回收机制，当变量退出其生命周期后，JVM会自动回收所分配的内存对象的内存。所以不需要析构函数来释放内存。 对象回收效率依赖于垃圾回收器GC（Garbage Collector），其回收算法关系到性能好坏。 每个Java类都必须有构造函数 如果没有显式定义构造函数，Java编译器自动为该类产生一个空的无形参构造函数。 每个子类的构造函数第一句话，都默认调用父类的无形参构造函数super()，除非子类的构造函数第一句话是super，而且super语句必须放在第一条。 一个类可以有多个构造函数，只要形参列表不相同即可。 在new对象的时候，根据实参的不同，自动挑选相应的构造函数。如果实参形参匹配不上，将会报错。 class MyPairNumber { int m; int n; public MyPairNumber() { m = 0; n = 0; } public MyPairNumber(int a) { m = a; n = 0; } public MyPairNumber(int a, int b) { m = a; n = b; } } public class ConstructorTest { public static void main(String[] args) { MyPairNumber obj1 = new MyPairNumber(); MyPairNumber obj2 = new MyPairNumber(5); MyPairNumber obj3 = new MyPairNumber(10,20); System.out.println(\"obj1 has \" + obj1.m + \",\" + obj1.n); //obj1 has 0,0 System.out.println(\"obj2 has \" + obj2.m + \",\" + obj2.n); //obj2 has 5,0 System.out.println(\"obj3 has \" + obj3.m + \",\" + obj3.n); //obj3 has 10,20 // A a = new A(); //error, A类中没有无参数的构造函数 } } ","date":"2021-02-23","objectID":"/java02/:4:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 面向对象","uri":"/java02/"},{"categories":["Java"],"content":"5 信息隐藏和this ","date":"2021-02-23","objectID":"/java02/:5:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 面向对象","uri":"/java02/"},{"categories":["Java"],"content":"5.1 信息隐藏 面向对象有一个法则：信息隐藏 类的成员属性，是私有的private; 类的方法是共有public的，通过方法修改成员属性的值。 通过类的方法来简介访问类的属性，而不是直接访问类的属性。 get和set方法是共有public的，统称getter和setter 外界对类成员的操作只能通过get和set方法 //InfoHiding.java class InfoHiding { private int id; public InfoHiding(int id2) { id = id2; } public int getId() { return id; } public void setId(int id2) { id = id2; } } //InfoHidingTest.java public class InfoHidingTest { public static void main(String[] args) { InfoHiding obj = new InfoHiding(100); obj.setId(200); System.out.println(obj.getId()); } } ","date":"2021-02-23","objectID":"/java02/:5:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] 面向对象","uri":"/java02/"},{"categories":["Java"],"content":"5.2 this this 负责指向本类中的成员变量 //InfoHiding.java class InfoHiding { private int id; public InfoHiding(int id2) { id = id2; } public int getId() { return id; } public void setId(int id2) { id = id2; } } //InfoHiding2.java public class InfoHiding2 { private int id; public InfoHiding2(int id) //在构造函数中，形参的优先级更高。 { this.id = id; //this 相当于 InfoHiding2，指向本类中的成员变量 } public int getId() { return id; } public void setId(int id) { this.id = id; } } this 负责指向本类中的成员方法 this.add(5,3); //调用本类的add方法，this可忽略 this 可以代替本类中的构造函数 //MyPairNumber.java public class MyPairNumber { private int m; private int n; public int getM() { return m; } public void setM(int m) { this.m = m; } public int getN() { return n; } public void setN(int n) { this.n = n; } public MyPairNumber() { this(0, 0); } public MyPairNumber(int m) { //this 当作构造函数使用 this(m, 0); } public MyPairNumber(int m, int n) { // this 指向本类中的成员变量 this.m = m; // m = 5 this.n= n; // n = 0 } public int sum() { // this 指向本类中的成员方法 return this.add(m,n); //return add(m,n); 也可以 } public int add(int a, int b){ return a+b; } } //ThisTest.java public class ThisTest { public static void main(String[] args) { MyPairNumber obj = new MyPairNumber(5); System.out.println(obj.sum()); // 5 } } ","date":"2021-02-23","objectID":"/java02/:5:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] 面向对象","uri":"/java02/"},{"categories":["Java"],"content":"利用百度地图API实现网页定位与距离计算","date":"2021-02-21","objectID":"/baidumap/","tags":["Java"],"title":"利用百度地图API实现网页定位与距离计算","uri":"/baidumap/"},{"categories":["Java"],"content":"在写项目时，需要通过浏览器获取用户所在城市定位，并计算两个定位之间的距离，于是先利用百度地图API实现网页定位接着进行距离计算。 ","date":"2021-02-21","objectID":"/baidumap/:0:0","tags":["Java"],"title":"利用百度地图API实现网页定位与距离计算","uri":"/baidumap/"},{"categories":["Java"],"content":"1 注册账户 百度地图开放平台官网：http://wiki.lbsyun.baidu.com/ 按步骤注册即可 ","date":"2021-02-21","objectID":"/baidumap/:1:0","tags":["Java"],"title":"利用百度地图API实现网页定位与距离计算","uri":"/baidumap/"},{"categories":["Java"],"content":"2 创建应用 注册成功后在应用管理中创建应用，应用类型选择浏览器端 创建成功后复制应用的AK ","date":"2021-02-21","objectID":"/baidumap/:2:0","tags":["Java"],"title":"利用百度地图API实现网页定位与距离计算","uri":"/baidumap/"},{"categories":["Java"],"content":"3 引入js脚本 \u003cscript type=\"text/javascript\" src=\"http://api.map.baidu.com/api?v=2.0\u0026ak=HorW07DM******LWS**rf48******yF\"\u003e\u003c/script\u003e ","date":"2021-02-21","objectID":"/baidumap/:3:0","tags":["Java"],"title":"利用百度地图API实现网页定位与距离计算","uri":"/baidumap/"},{"categories":["Java"],"content":"4 获取定位 function getLocation() { var address; var geolocation = new BMap.Geolocation(); geolocation.getCurrentPosition(function getinfo(position){ address = position.address.city; //获取城市信息 province = position.address.province; }, function(e) { alert(\"获取百度定位位置信息失败\"); }); geolocation.getCurrentPosition(function (r) { //定位位置 if (this.getStatus() === BMAP_STATUS_SUCCESS) { alter(\"city:\"+address+\",latitude:\"+r.point.lat+\",longitude:\"+r.point.lng) }, { enableHighAccuracy: true }) } //关于状态码 //BMAP_STATUS_SUCCESS 检索成功。对应数值“0”。 //BMAP_STATUS_CITY_LIST 城市列表。对应数值“1”。 //BMAP_STATUS_UNKNOWN_LOCATION 位置结果未知。对应数值“2”。 //BMAP_STATUS_UNKNOWN_ROUTE 导航结果未知。对应数值“3”。 //BMAP_STATUS_INVALID_KEY 非法密钥。对应数值“4”。 //BMAP_STATUS_INVALID_REQUEST 非法请求。对应数值“5”。 //BMAP_STATUS_PERMISSION_DENIED 没有权限。对应数值“6”。(自 1.1 新增) //BMAP_STATUS_SERVICE_UNAVAILABLE 服务不可用。对应数值“7”。(自 1.1 新增) //BMAP_STATUS_TIMEOUT 超时。对应数值“8”。(自 1.1 新增) ","date":"2021-02-21","objectID":"/baidumap/:4:0","tags":["Java"],"title":"利用百度地图API实现网页定位与距离计算","uri":"/baidumap/"},{"categories":["Java"],"content":"5 根据经纬度计算两个地址间距离 Maven库导包 \u003cdependency\u003e \u003cgroupId\u003eorg.gavaghan\u003c/groupId\u003e \u003cartifactId\u003egeodesy\u003c/artifactId\u003e \u003cversion\u003e1.1.3\u003c/version\u003e \u003c/dependency\u003e 代码实现： import org.gavaghan.geodesy.Ellipsoid; import org.gavaghan.geodesy.GeodeticCalculator; import org.gavaghan.geodesy.GeodeticCurve; import org.gavaghan.geodesy.GlobalCoordinates; public class CaculateDistance { public Double Distance( Float latituse1,Float longitude1,Float latituse2,Float longitude2){ GlobalCoordinates source = new GlobalCoordinates(latituse1, longitude1); GlobalCoordinates target = new GlobalCoordinates(latituse2, longitude2); return getDistanceMeter(source, target, Ellipsoid.Sphere); } public static double getDistanceMeter(GlobalCoordinates gpsFrom, GlobalCoordinates gpsTo, Ellipsoid ellipsoid) { //创建GeodeticCalculator，调用计算方法，传入坐标系、经纬度用于计算距离 GeodeticCurve geoCurve = new GeodeticCalculator().calculateGeodeticCurve(ellipsoid, gpsFrom, gpsTo); return geoCurve.getEllipsoidalDistance(); } } ","date":"2021-02-21","objectID":"/baidumap/:5:0","tags":["Java"],"title":"利用百度地图API实现网页定位与距离计算","uri":"/baidumap/"},{"categories":["Java"],"content":"6 效果展示 ","date":"2021-02-21","objectID":"/baidumap/:6:0","tags":["Java"],"title":"利用百度地图API实现网页定位与距离计算","uri":"/baidumap/"},{"categories":["Java"],"content":"7 踩坑记录 ","date":"2021-02-21","objectID":"/baidumap/:7:0","tags":["Java"],"title":"利用百度地图API实现网页定位与距离计算","uri":"/baidumap/"},{"categories":["Java"],"content":"7.1 通过h5获取自带经纬度 优点： 需要引用的资源较少，H5自带的方法 缺点： 1、获取的经纬度偏差较大，如果需要配合地图使用，还需要使用地图提供的经纬度转换方法 2、目前大多数浏览器（包括手机端），已经不支持http的请求获取用户地址，必须为https域名的才能发起请求。目前测试，在安卓手机的微信打开的浏览器和IE浏览器还能支持获取经纬度。 //判断是否支持 获取本地位置 if (navigator.geolocation) { var n = navigator.geolocation.getCurrentPosition(function(res){ console.log(res); // 需要的坐标地址就在res中 }); } else { alert('该浏览器不支持定位'); } ","date":"2021-02-21","objectID":"/baidumap/:7:1","tags":["Java"],"title":"利用百度地图API实现网页定位与距离计算","uri":"/baidumap/"},{"categories":["Java"],"content":"7.2 ip定位获取当前所在城市 精度太差，可能定位到附近城市，不建议使用。 var map = new BMap.LocalCity(); map.get(function (result){ var city= result.name; }); ","date":"2021-02-21","objectID":"/baidumap/:7:2","tags":["Java"],"title":"利用百度地图API实现网页定位与距离计算","uri":"/baidumap/"},{"categories":["Java"],"content":"8 参考资料 参考资料 Java 根据经纬度计算实际距离 ","date":"2021-02-21","objectID":"/baidumap/:8:0","tags":["Java"],"title":"利用百度地图API实现网页定位与距离计算","uri":"/baidumap/"},{"categories":["Github"],"content":"这篇文章介绍了如何在Hugo上添加Algolia搜索支持。\n以 LoveIt 主题为例。","date":"2021-02-20","objectID":"/hugo-algolia/","tags":["Github","Hugo","Algolia"],"title":"Hugo添加Algolia搜索支持","uri":"/hugo-algolia/"},{"categories":["Github"],"content":"这篇文章介绍了如何在Hugo上添加Algolia搜索支持。 以 LoveIt 主题为例。 系统环境 Windows 10 hugo_extended_0.68.3_Windows-64bit ","date":"2021-02-20","objectID":"/hugo-algolia/:0:0","tags":["Github","Hugo","Algolia"],"title":"Hugo添加Algolia搜索支持","uri":"/hugo-algolia/"},{"categories":["Github"],"content":"1 注册账户 Algolia官网：https://www.algolia.com/ 按步骤注册即可 ","date":"2021-02-20","objectID":"/hugo-algolia/:1:0","tags":["Github","Hugo","Algolia"],"title":"Hugo添加Algolia搜索支持","uri":"/hugo-algolia/"},{"categories":["Github"],"content":"2 创建空索引 注册成功后系统会引导创建应用和索引，如果未创建，请手动创建 流程如下： 创建应用 选择免费的方案 选择服务器所在地 创建空索引 ","date":"2021-02-20","objectID":"/hugo-algolia/:2:0","tags":["Github","Hugo","Algolia"],"title":"Hugo添加Algolia搜索支持","uri":"/hugo-algolia/"},{"categories":["Github"],"content":"3 配置API Keys 点击导航栏API Keys，记录信息(Application ID, Search-Only API Key, Admin API Key) 在config.toml中进行配置 # 搜索配置 [languages.zh-cn.params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [languages.zh-cn.params.search.algolia] index = \"ieblyang\" appID = \"Your Application ID\" searchKey = \"Your Search-Only API Key\" ","date":"2021-02-20","objectID":"/hugo-algolia/:3:0","tags":["Github","Hugo","Algolia"],"title":"Hugo添加Algolia搜索支持","uri":"/hugo-algolia/"},{"categories":["Github"],"content":"4 生成索引文件 使用hugo 命令后，public文件夹下生成index.json文件 ","date":"2021-02-20","objectID":"/hugo-algolia/:4:0","tags":["Github","Hugo","Algolia"],"title":"Hugo添加Algolia搜索支持","uri":"/hugo-algolia/"},{"categories":["Github"],"content":"5 上传索引文件 ","date":"2021-02-20","objectID":"/hugo-algolia/:5:0","tags":["Github","Hugo","Algolia"],"title":"Hugo添加Algolia搜索支持","uri":"/hugo-algolia/"},{"categories":["Github"],"content":"5.1 手动上传 点击Upload Record(s)上传索引文件 第一次上传需要继续配置可搜索属性 自定义排序规则（Custom Ranking）可以暂时不做配置 ","date":"2021-02-20","objectID":"/hugo-algolia/:5:1","tags":["Github","Hugo","Algolia"],"title":"Hugo添加Algolia搜索支持","uri":"/hugo-algolia/"},{"categories":["Github"],"content":"5.2 自动上传 在blog目录下执行以下命令 npm init npm install atomic-algolia --save 执行完后会生成 node_modules 文件夹（如果代码托管在 GitHub 的话，可以在.gitignore中添加/node_modules以忽略该文件）。在项目根目录下还会有一个package.json文件，打开该文件，在scripts下添加\"algolia\": \"atomic-algolia\"后如下： \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" }, 在博客项目根目录下建立一个.env文件，文件内容如下： 请按照自己的应用进行配置 ALGOLIA_APP_ID=2W*****71W ALGOLIA_INDEX_NAME=ieblyang ALGOLIA_INDEX_FILE=public/index.json ALGOLIA_ADMIN_KEY=a8b6be4*****ad0c525*****f00cd2af 执行下面的命令更新Algolia: npm run algolia ","date":"2021-02-20","objectID":"/hugo-algolia/:5:2","tags":["Github","Hugo","Algolia"],"title":"Hugo添加Algolia搜索支持","uri":"/hugo-algolia/"},{"categories":["Github"],"content":"6 效果展示 启动测试环境 hugo serve -e production ","date":"2021-02-20","objectID":"/hugo-algolia/:6:0","tags":["Github","Hugo","Algolia"],"title":"Hugo添加Algolia搜索支持","uri":"/hugo-algolia/"},{"categories":["Github"],"content":"7 参考资料 参考资料 Hugo添加Algolia搜索支持 采用 Algolia 作为 Hugo 搜索方案 ","date":"2021-02-20","objectID":"/hugo-algolia/:7:0","tags":["Github","Hugo","Algolia"],"title":"Hugo添加Algolia搜索支持","uri":"/hugo-algolia/"},{"categories":["Java"],"content":"[Java核心技术] 基本语句和结构","date":"2021-02-03","objectID":"/java01/","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"Java 核心技术读书笔记——基本语句和结构 Java简介 Java 是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。 Java 分为三个体系： JavaSE(Standard Edition，java平台标准版) 面向PC级应用开发 JavaEE(Enterprise Edition，java平台企业版) 面向企业级应用开发 JavaME(Micro Edition，java平台微型版) 面向嵌入式应用开发 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字\"2\"：J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。 ","date":"2021-02-03","objectID":"/java01/:0:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"1 主要特性 ","date":"2021-02-03","objectID":"/java01/:1:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"1.1 简单性 Java 的语法与 C语言 和 C++ 语言很接近，很容易学习和使用。 Java 丢弃了 C++ 中很少使用的、很难理解的、令人迷惑的特性。 Java 不使用指针，而是引用。并提供了自动分配和回收内存空间，使得程序员不必为内存管理而担忧。 ","date":"2021-02-03","objectID":"/java01/:1:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"1.2 面向对象 Java提供类、接口和继承等面向对象的特性，为了简单起见，支持类之间的单继承，支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为 implements）。 Java全面支持动态绑定，而 C++只对虚函数使用动态绑定。 ","date":"2021-02-03","objectID":"/java01/:1:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"1.3 分布式 Java支持 Internet 应用的开发，在基本的 Java 应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括 URL、URLConnection、Socket、ServerSocket 等。Java 的 RMI（远程方法激活）机制也是开发分布式应用的重要手段。 ","date":"2021-02-03","objectID":"/java01/:1:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"1.4 健壮性 Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。对指针的丢弃是 Java 的明智选择。Java 的安全检查机制使得 Java 更具健壮性。 ","date":"2021-02-03","objectID":"/java01/:1:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"1.5 安全性 Java 通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。除了Java 具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。 ","date":"2021-02-03","objectID":"/java01/:1:5","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"1.6 体系结构中立 Java 程序（后缀为 java 的文件）在 Java 平台上被编译为体系结构中立的字节码格式（后缀为 class的文件），然后可以在实现这个 Java 平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。 ","date":"2021-02-03","objectID":"/java01/:1:6","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"1.7 可移植性 这种可移植性来源于体系结构中立性，另外，Java 还严格规定了各个基本数据类型的长度。Java 系统本身也具有很强的可移植性，Java 编译器是用 Java 实现的，Java 的运行环境是用 ANSI C 实现的。 ","date":"2021-02-03","objectID":"/java01/:1:7","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"1.8 解释型 如前所述，Java 程序在 Java 平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行。在运行时，Java 平台中的 Java 解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。 ","date":"2021-02-03","objectID":"/java01/:1:8","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"1.9 高性能 与那些解释型的高级脚本语言相比，Java 的确是高性能的。事实上，Java 的运行速度随着 JIT(Just-In-Time）编译器技术的发展越来越接近于 C++。 ","date":"2021-02-03","objectID":"/java01/:1:9","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"1.10 多线程 在 Java 语言中，线程是一种特殊的对象，它必须由 Thread 类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为 Thread(Runnable) 的构造子类将一个实现了 Runnable 接口的对象包装成一个线程，其二，从 Thread 类派生出子类并重写 run 方法，使用该子类创建的对象即为线程。值得注意的是 Thread 类已经实现了 Runnable 接口，因此，任何一个线程均有它的 run 方法，而 run 方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java 支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为 synchronized）。 ","date":"2021-02-03","objectID":"/java01/:1:10","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"1.11 动态性 Java 语言的设计目标之一是适应于动态变化的环境。Java 程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java 中的类有一个运行时刻的表示，能进行运行时刻的类型检查。 ","date":"2021-02-03","objectID":"/java01/:1:11","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"2 Java语法规范 Java 是面向对象的编程语言，一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态，是Java程序最小独立单元，包括成员变量和成员方法。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 ","date":"2021-02-03","objectID":"/java01/:2:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"2.1 基本语法 大小写敏感 类名：是以大写字母开头的名词。如果名字由多个单词组成，每个单词的第一个字母都应该大写称为骆驼命名法。 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 源文件名：源代码的文件名必须与公共类的名字相同，并用 .java 作为扩展名。 主方法： public static void main(String[] args) 运行已编译的程序时，Java 虚拟机将从指定类中的 main方法开始执行，因此为了代码能够执行，在类的源文件中必须包含一个 main 方法。 main函数是程序启动的总入口。 main函数的形参args是外界提供给main函数的参数，可以在main函数中使用。 ","date":"2021-02-03","objectID":"/java01/:2:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"2.2 Java 标识符 Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。 所有的标识符都应该以字母（A-Z 或者 a-z）、美元符（$）、或者下划线（_）开始 首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合 关键字不能用作标识符 标识符大小写敏感 合法标识符举例：age、$salary、_value、__1_value 非法标识符举例：123abc、-salary ","date":"2021-02-03","objectID":"/java01/:2:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"2.3 Java 修饰符 Java 可以使用修饰符来修饰类中方法和属性。主要有两类修饰符： 访问控制修饰符 : default, public , protected, private 非访问控制修饰符 : final, abstract, static, synchronized ","date":"2021-02-03","objectID":"/java01/:2:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"2.4 Java 变量 Java 中主要有如下几种类型的变量 局部变量 类变量（静态变量） 成员变量（非静态变量） ","date":"2021-02-03","objectID":"/java01/:2:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"2.5 Java 关键字 类别 关键字 说明 访问控制 private 私有的 protected 受保护的 public 公共的 类、方法和变量修饰符 abstract 声明抽象 class 类 extends 扩充,继承 final 最终值,不可改变的 implements 实现（接口） interface 接口 native 本地，原生方法（非 Java 实现） new 新,创建 static 静态 strictfp 严格,精准 synchronized 线程,同步 transient 短暂 volatile 易失 程序控制语句 break 跳出循环 case 定义一个值以供 switch 选择 continue 继续 default 默认 do 运行 else 否则 for 循环 if 如果 instanceof 实例 return 返回 switch 根据值选择执行 while 循环 错误处理 assert 断言表达式是否为真 catch 捕捉异常 finally 有没有异常都执行 throw 抛出一个异常对象 throws 声明一个异常可能被抛出 try 捕获异常 包相关 import 引入 package 包 基本类型 boolean 布尔型 byte 字节型 char 字符型 double 双精度浮点 float 单精度浮点 int 整型 long 长整型 short 短整型 变量引用 super 父类,超类 this 本类 void 无返回值 保留关键字 goto 是关键字，但不能使用 const 是关键字，但不能使用 null 空 ","date":"2021-02-03","objectID":"/java01/:2:5","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"2.6 Java 注释 Java 中的注释不会出现在可执行程序中。因此，可以在源程序中根据需要添加任意多的注释，而不必担心可执行代码会膨胀。 单行注释 // 长段注释 /* */ 多行注释 /** */ /** * 这是一个多行注释示例 * * ©author ieblYang */ public class FirstSample { /*这是一个长段注释示例*/ public static void main(String[] args) { //这是一个单行注释示例 System.out.println(\"We will not use 'Hello, World!'\"); } } ","date":"2021-02-03","objectID":"/java01/:2:6","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"3 数据类型 在 Java 中，一共有 8 种基本类型：byte（字节）、short（短整数）、 int（整数）、 long（长整数）、 float、double（浮点数）、 char（字符）、boolean（布尔） 。 ","date":"2021-02-03","objectID":"/java01/:3:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"3.1 整型 整型用于表示没有小数部分的数值，可正可负。Java 提供了 4 种整型。如下表所示： 类型 存储需求 取值范围 默认值 byte 1字节 -128 ～ 127 0 short 2字节 -32768 ～ 32767 0 int 4字节 -2147483648 ～ 2147483647 0 long 8字节 -9223372036854775808 ～ 9223372036854775807 0L 笔记 byte 1 byte = 8 bits 存储有符号的、以二进制补码表示的整数。 用在大型数组中可以显著节约空间，主要代替小整数，因为byte变量占用的空间只有int的 1/4。 在二进制文件读写中使用较多。 public class IntegerTest { public static void main(String[] args){ short a1 = 32767; System.out.println(a1); //short a2 = 32768; error 越界 int b1 = 2147483647; System.out.println(b1); //int b2 = 32768; error 越界 long c1 = 1000000000000L; System.out.println(c1); long c2 = 2147483647; //隐式做了从int变成long的操作 System.out.println(c2); long c3 = 2147483648L; //去掉L将报错 System.out.println(c3); } } ","date":"2021-02-03","objectID":"/java01/:3:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"3.2 浮点类型 浮点类型用于表示有小数部分的数值。在 Java 中有两种浮点类型，float（单精度）、double（双精度）。 类型 存储需求 取值范围 表示 默认值 float 4字节 大约 ± 3.40282347E+38F (有效位数为 6 ~ 7 位） 后缀 F 或 f 0.0f double 8字节 大约 ± 1.79769313486231570E+308 (有效位数为15位） 无后缀或添加后缀 D 或 d 0.0d 笔记 float、double均符合 IEEE 754 标准。 float、double均不能用来表示很精确的数字。 public class Floatingtest{ public static void main(String[] args){ float f1 = 1.23f; //float f2 = 1.23; error, float赋值必须带f double d1 = 4.56d; double d2 = 4.56; //double 可以省略末尾d System.out.println(f1); System.out.println((double) f1); System.out.println(d1); System.out.println((float) d2); System.out.println(f1 == 1.229999999f); //true System.out.println(f1 - 1.229999999f); //0.0 System.out.println(d2 == 4.559999999999999999d);//true System.out.println(d2 - 4.559999999999999999d);//0.0 } ","date":"2021-02-03","objectID":"/java01/:3:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"3.3 char 型 char类型是一个单一的 16 位 Unicode字符,最小值是 \\u0000（即为 0）,最大值是 \\uffff（即为65535）,char 数据类型可以储存任何字符。 public class Floatingtest{ public static void main(String[] args){ char a = 'a'; char b = 97; //根据 ascii 码转化为 a char c = '我'; char d = '\\u4e00'; //“一”字 \\u4e00 ~ \\u9fa5 两万多汉字 System.out.println(a); System.out.println(b); System.out.println(c); System.out.println(d); ","date":"2021-02-03","objectID":"/java01/:3:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"3.4 boolean 类型 boolean (布尔）类型有两个值：false（默认值） 和 true, 用来判定逻辑条件。 整型值和布尔值之间不能进行相互转换。 ","date":"2021-02-03","objectID":"/java01/:3:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"4 变量 在 Java 中，每个变量都有一个类型（ type)。在声明变量时，变量的类型位于变量名之前。 Java语言支持的变量类型有： 类变量：独立于方法之外的变量，用 static 修饰。 实例变量：独立于方法之外的变量，不过没有 static 修饰。 局部变量：类的方法中的变量。 ","date":"2021-02-03","objectID":"/java01/:4:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"4.1 变量初始化 声明一个变量之后，必须用赋值语句对变量进行显式初始化， 千万不要使用未初始化的变量。 在 Java 中， 变量的声明尽可能地靠近变量第一次使用的地方， 这是一种良好的程序编写风格。 ","date":"2021-02-03","objectID":"/java01/:4:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"4.2 常量 在 Java 中， 利用关键字 final 指示常量。 关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上,常量名使用全大写。 ","date":"2021-02-03","objectID":"/java01/:4:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"5 运算符 算术运算符 +、 -、 *、 /、% 逻辑运算符 \u0026\u0026、 || 、！ 比较运算符 !=、 \u003e、 \u003e=、\u003c、\u003c=、== 移位运算符 \u003e\u003e、 \u003c\u003c 警告 当参与 / 运算的两个操作数都是整数时，表示整数除法；否则，表示浮点除法。 整数被 0 除将会产生一个异常， 而浮点数被 0 除将会得到无穷大或 NaN 结果。 ","date":"2021-02-03","objectID":"/java01/:5:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"5.1 数值类型之间的转换 ","date":"2021-02-03","objectID":"/java01/:5:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"5.2 强制类型转换 强制类型转换的语法格式是在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名。例如： /*直接进行强制类型转换*/ double x * 9.997; int nx = (int) x; //变量 nx 的值为 9。强制类型转换通过截断小数部分将浮点值转换为整型 /*使用 Math_ round 方法对浮点数进行舍入运算，得到最接近的整数*/ double x z 9.997; int nx = (int) Math.round(x); //变量 nx 的值为 9。当调用 round 的时候返回的结果为 long 型,需要使用强制类型转换。 警告 如果试图将一个数值从一种类型强制转换为另一种类型， 而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值。例如，(byte)300 的实际值为 44。 ","date":"2021-02-03","objectID":"/java01/:5:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"5.3 结合赋值和运算符 可以在赋值中使用二元运算符。 x += 4; //等价于 x = x + 4; ","date":"2021-02-03","objectID":"/java01/:5:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"5.4 自增与自减运算符 自增运算符：++ 自减运算符：-- 前缀自增自减法(++a,–a): 先进行自增或者自减运算，再进行表达式运算。 后缀自增自减法(a++,a–): 先进行表达式运算，再进行自增或者自减运算。 int m = 7; int n = 7; int a = 2 * ++m; // now a is 16, m is 8 int b = 2 * n++; // now b is 14, n is 8 /* 建议不要在表达式中使用 ++, 因为这样的代码很容易让人闲惑，而且会带来烦人的 bug。 */ ","date":"2021-02-03","objectID":"/java01/:5:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"5.5 关系和 boolean 运算符 相等：== 不等：!= 小于：\u003c 大于：\u003e 小于等于：\u003c= 大于等于：\u003e= 逻辑“与”：\u0026\u0026 逻辑“或”：|| 逻辑“非”：! 三元运算符：?: /* \u0026\u0026 和 || 运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。*/ x != 0 \u0026\u0026 1 / x \u003e x + y // no division by 0 ，如果 x 等于 0, 那么第二部分就不会计算。 x \u003c y ? x : y //会返回 x 和 y 中较小的一个 ","date":"2021-02-03","objectID":"/java01/:5:5","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"5.6 位运算符 Java 定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。位运算符作用在所有的位上，并且按位运算。 下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13： 操作符 描述 例子 ＆ 如果相对应位都是1，则结果为1，否则为0 (A＆B)，得到12，即 0000 1100 | 如果相对应位都是 0，则结果为 0，否则为 1 `（A ^ 如果相对应位值相同，则结果为0，否则为1 （A ^ B）得到49，即 0011 0001 〜 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。 (〜A)得到-61，即 1100 0011 \u003c\u003c 按位左移运算符。左操作数按位左移右操作数指定的位数。 A \u003c\u003c 2得到240，即 1111 0000 \u003e\u003e 按位右移运算符。左操作数按位右移右操作数指定的位数。 A \u003e\u003e 2得到15，即 1111 \u003e\u003e\u003e 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 A\u003e\u003e\u003e2得到15，即 0000 1111 ","date":"2021-02-03","objectID":"/java01/:5:6","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"5.7 括号与运算符级别 如果不使用圆括号，就按照给出的运算符优先级次序进 行计算。同一个级别的运算符按照从左到右的次序进行计算 （除了表中给出的右结合运算符外）。 运算符 结合性 [].()(方法调用) 从左向右 ! ~ ++ -- +(一元运算) -(一元运算) ()(强制类型转换) new 从右向左 * / % 从左向右 + - 从左向右 \u003c\u003c \u003e\u003e \u003e\u003e\u003e 从左向右 \u003c \u003c= \u003e \u003e= instanccof 从左向右 == != 从左向右 \u0026 从左向右 ^ 从左向右 | 从左向右 \u0026\u0026 从左向右 || 从左向右 ?: 从右向左 = += -= *= /= %= \u0026= ` = ^= «= »= »\u003e=` ","date":"2021-02-03","objectID":"/java01/:5:7","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"5.8 枚举类型 （后面补充） ","date":"2021-02-03","objectID":"/java01/:5:8","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"6 字符串 Java 没有内置的字符串类型，而是在标准 Java 类库中提供了一个预定义类，很自然地叫做 String。 每个用双引号括起来的字符串都是 String 类的一个实例： String e = \"\"; // an empty string String greeting = \"Hello\"; ","date":"2021-02-03","objectID":"/java01/:6:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"6.1 子串 String 类的 substring 方法可以从一个较大的字符串提取出一个子串。 例如： String s = greeting.substring(0, 3); //第一个参数是开始位置，第二个参数是不想复制的第一个位置 创建了一个由字符“ Hel ” 组成的字符串。 ","date":"2021-02-03","objectID":"/java01/:6:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"6.2 拼接 Java 语言使用 + 号连接（拼接）两个字符串。 String expletive = \"Expletive\"; String PC13 = \"deleted\"; String message = expletive + PC13; 当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串。 int age = 13; String rating = \"PC\" + age; 如果需要把多个字符串放在一起， 用一个定界符分隔，可以使用静态 join 方法： String all = String.join(\" / \", \"S\", \"M\",\"L\", \"XL\"); // all is the string \"S / H / L / XL\" ","date":"2021-02-03","objectID":"/java01/:6:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"6.3 不可变字符串 ","date":"2021-02-03","objectID":"/java01/:6:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"6.4 检测字符串是否相等 使用equals方法检测两个字符串是否相等。 s.euqals(t) //相等返回true,否则返回false \"Hello\".equals(greeting); 使用equalsIgnoreCore方法检测不区分大小写的情况下，字符串是否相等。 \"Hello\".equalsIgnoreCase(\"hel1o\") 警告 一定不要使用==运算符检测两个字符串是否相等！ 这个运算符只能够确定两个字串是否放置在同一个位置上。当然，如果字符串放置在同一个位置上， 它们必然相等。但是，完全有可能将内容相同的多个字符串的拷贝放置在不同的位置上。 如果虚拟机始终将相同的字符串共享， 就可以使用=运算符检测是否相等。但实际上只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的。 String greeting = \"Hello\"; //initialize greeting to a string if (greeting == \"Hello\"){ ... } // probably true if (greeting.substring(0, 3) == \"HeV\"){ ... } // probably false ","date":"2021-02-03","objectID":"/java01/:6:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"6.5 空串与 NUll 串 空串 \"\" 是一个 Java 对象，有自己的串长度（0）和内容（空）。可以调用以下代码检查一个字符串是否为空： if (str.lengthQ = 0){ ... } if (str.equals(\"\")){ ... } String 变量还可以存放一个特殊的值，名为 null, 这表示目前没有任何对象与该变量关联。要检查一个字符串是否为 null, 要使用以下条件： if (str == null){ ... } 有时要检查一个字符串既不是 null 也不为空串，这种情况下就需要使用以下条件： if (str != null \u0026\u0026 str.length() != 0){ ... } ","date":"2021-02-03","objectID":"/java01/:6:5","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"6.6 码点与代码单元 Java 字符串由 char 值序列组成。 char 数据类型是一个采用 UTF-16 编码表示 Unicode 码点的代码单元。大多数的常用 Unicode 字符使用一个代码单元就可以表示，而辅助字符需要一对代码单元表示。 length 方法将返回采用 UTF-16 编码表示的给定字符串所需要的代码单元数量。例如： String greeting = \"Hello\"; int n = greeting.length。; // is 5 . 要想得到实际的长度，即码点数量，可以调用： int cpCount = greeting.codePointCount(0, greeting.lengthQ); 调用 s.charAt(n) 将返回位置 n 的代码单元，n 介于 0 ~ s.length()-l 之间。例如： char first = greeting.charAtO); // first is 'H' char last = greeting.charAt(4); // last is 'o' 要想得到第 i 个码点，应该使用下列语句 int index = greeting.offsetByCodePoints(0, i); int cp = greeting.codePointAt(index); ","date":"2021-02-03","objectID":"/java01/:6:6","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"6.7 String API 方法摘要： 类型 方法 描述 char charAt (int index) 返回指定索引处的 char 值 int codePointAt(int Index) 返回从给定位置开始的码点 int offsetByCodePoints(int startlndex, int cpCount) 返回从 startlndex 代码点开始，位移 cpCount 后的码点索引 int compareTo(String other) 按照字典顺序，如果字符串位于 other 之前， 返回一个负数；如果字符串位于 other 之后，返回一个正数；如果两个字符串相等，返回 0 IntStream codePoints() 将这个字符串的码点作为一个流返回。调用 toArray 将它们放在一个数组中 boolean equals(0bject other) 如果字符串与 other 相等， 返回 true boolean equalsIgnoreCase(String other) 如果字符串与 other 相等（忽略大小写）返回 true boolean startsWith(String prefix) 如果字符串以 prefix 开头，则返回 true boolean endsWith(String suffix) 如果字符串以 suffix 结尾，则返回 true int indexOf(String str) 返回与字符串str 匹配的第一个子串的开始位置。 int indexOf(String str, int fromIndex ) 返回与字符串 str 匹配的第一个指定字符的开始位置，从 fromIndex 开始搜索，如果在原始串中不存在str，返回 -1 int indexOf(int cp) 返回与代码点 cp 匹配的第一个子串的开始位置 int indexOf(int cp, int fromIndex) 返回此字符串 匹配的第一个子串的开始位置，从 fromIndex开始搜索，如果在原始串中不存在 str，返回 -1 int lastIndexOf(String str) 返回与字符串 str匹配的最后一个子串的开始位置，从原始串尾端开始计算 int lastIndexOf(String str, int fromIndex ) 返回与字符串 str 匹配的最后一个子串的开始位置，从 fromIndex 开始计算 int lastindexOf(int cp) 返回与代码点 cp 匹配的最后一个子串的开始位置，从原始串尾端开始计算 int lastindexOf(int cp, int fromIndex ) 返回与代码点 cp 匹配的最后一个子串的开始位置，从 fromIndex 开始计算 int length() 返回字符串的长度 int codePointCount(int startlndex , int endlndex) 返回 startlndex 和 endludex-1之间的代码点数量。没有配成对的代用字符将计入代码点 String replace( CharSequence oldString,CharSequence newString) 返回一个新字符串。这个字符串用 newString 代替原始字符串中所有的 oldString。可以用 String 或 StringBuilder 对象作为 CharSequence 参数 String substring(int beginlndex) 返回一个新字符串。这个字符串包含原始字符串中从 beginlndex到串尾的所有代码单元 String substring(int beginlndex, int endlndex) 返回一个新字符串。这个字符串包含原始字符串中从 beginlndex 到 endlndex-l的所有代码单元 String toLowerCase( ) 返回一个新字符串。这个字符串将原始字符串中的大写字母改为小写 String toUpperCase( ) 返回一个新字符串。这个字符串将原始字符串中的小写字母改为大写 String trim( ) 返回一个新字符串。这个字符串将删除了原始字符串头部和尾部的空格 String join(CharSequence delimiter, CharSequence ... elements) 返回一个新字符串，用给定的定界符连接所有元素 ","date":"2021-02-03","objectID":"/java01/:6:7","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"6.8 构建字符串 如果需要用许多小段的字符串构建一个字符串， 那么应该按照下列步骤进行。 首先，构建一个空的字符串构建器： StringBuilder builder = new StringBuilder(); 当每次需要添加一部分内容时，就调用 append 方法。 builder.append(ch); // appends a single character bui1der.append(str); // appends a string 在需要构建字符串时就凋用 toString 方法，将可以得到一个 String 对象，其中包含了构建器中的字符序列。 String completedString = builder.toString(); StringBuilder 类中的重要方法： 方法 描述 StringBuilder() 构造一个空的字符串构建器 int length() 返回构建器或缓冲器中的代码单元数量 StringBuilder append(String str) 追加一个字符串并返回 this StringBuilder append(char c) 追加一个代码单元并返回 this StringBuilder appendCodePoint(int cp) 追加一个代码点，并将其转换为一个或两个代码单元并返回 this void setCharAt(int i ,char c) 将第 i 个代码单元设置为 c StringBuilder insert(int offset,String str) 在 offset 位置插入一个字符串并返回 this StringBuilder insert(int offset,char c) 在 offset 位置插入一个代码单元并返回 this StringBuilder delete(int startindex,int endlndex) 删除偏移量从 startindex 到 -endlndex-1 的代码单元并返回 this String toString() 返回一个与构建器或缓冲器内容相同的字符串 ","date":"2021-02-03","objectID":"/java01/:6:8","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"7 输入输出 ","date":"2021-02-03","objectID":"/java01/:7:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"7.1 读取输入 通过控制台进行输人，首先需要构造一个 Scanner 对象，并与“标准输人流” System.in 关联。Scanner类定义在java.util 包中，使用时需要先通过import引入java.util包。 import java.util.*; public class InputTest { public static void main(String[] args) { Scanner in = new Scanner(Systera.in); // nextLine 输入一行 System.out.print(\"What is your name? \"); String name = in.nextLine(); // nextInt 读取一个整数 System.out.print(\"How old are you? \")； int age = in.nextInt(); // 控制台输出 System.out.println(\"Hello,\" + name + \".Next year, you'll be \" + (age + 1)); } } java.util.Scanner 5.0 类型 方法 描述 Scanner (InputStream in) 用给定的输入流创建一个 Scanner 对象 String nextLine( ) 读取输入的下一行内容 String next( ) 读取输入的下一个单词（以空格作为分隔符） int nextInt( ) 读取并转换下一个表示整数的字符序列 double nextDouble( ) 读取并转换下一个表示浮点数的字符序列 boolean hasNext( ) 检测输入中是否还有其他单词 boolean hasNextInt( ) 检测是否还有表示整数的下一个字符序列 boolean hasNextDouble( ) 检测是否还有表示整数或浮点数的下一个字符序列 java.lang.System 1.0 static Console console() 如果有可能进行交互操作，就通过控制台窗口为交互的用户返回一个 Console 对象，否则返回 null。对于任何一个通过控制台窗口启动的程序，都可使用 Console 对象。否则，其可用性将与所使用的系统有关。 java.io.Console static char[] readPassword(String prompt, Object...args) static String readLine(String prompt, Object...args) 显示字符串 prompt 并且读取用户输入，直到输入行结束。args 参数可以用来提供输人格式。 ","date":"2021-02-03","objectID":"/java01/:7:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"7.2 格式化输出 Java SE 5.0 沿用了 C语言库函数中的 printf 方法。 double x = 10000.0/3.0; System.out.printf(\"%8.2f\", x);//用 8 个字符的宽度和小数点后两个字符的精度打印 //输出结果3333.33 每一个以 ％ 字符开始的格式说明符都用相应的参数替换。 格式说明符尾部的转换符将指示被格式化的数值类型。 转换符 类型 举例 d 十进制整数 159 x 十六进制整数 9f o 八进制数 237 f 定点浮点数 15.9 e 指数浮点数 1.59e+01 g 通用浮点数 —— a 十六进制浮点数 0x1.fccdp3 s 字符串 Hello c 字符 H b 布尔 True h 散列码 4268b2 tx 或 Tx 日期时间（T强制大写） 已经过时，应当改为使用 javaJime 类 % 百分号 % n 与平台有关的行分隔符 一 还可以给出控制格式化输出的各种标志，如下表所示： 标志 目的 举例 + 打印正数和负数的符号 +3333.33 空格 在正数之前添加空格 3333.33 0 数字前面补 0 003333.33 - 左对齐 13333.33 ( 将负数括在括号内 ( 3333.33 ) , 添加分组分隔符 3,333.33 #（对于 f 格式） 包含小数点 3,333. #（对于 x 或 0 格式） 添加前缀 0x 或 0 0xcafe $ 给定被格式化的参数索引。例如，％1$d， ％1$x 将以十进制和十六进制格式打印第一个参数 159 9F \u003c 格式化前面说明的数值。 例如，％d%\u003cX 以十进制和十六进制打印同一个数值 159 9F ","date":"2021-02-03","objectID":"/java01/:7:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"7.3 文件的输入输出 对文件进行读取需要用File对像构造一个Scanner对象，如下所示： Scanner in = new Scanner(paths.get(\"myfile.txt\")，\"UTF-8\"); 警告 可以构造一个带有字符串参数的 Scanner, 但这个 Scanner 将字符串解释为数据，而不是文件名。例如，如果调用: Scanner in = new Scanner(\"myfile.txt\"); // ERROR? 这个 scanner 会将参数作为包含 10 个字符的数据：‘ m ’,‘ y ’,‘ f ’ 等。 如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再加一个额外的反斜杠：\"c:\\\\mydirectory\\\\myfile.txt\" 。 对文件进行写入就需要构造一个PrintWriter对象。在构造器中，只需要提供文件名，如果文件不存在，创建该文件。 PrintWriter out = new PrintWriter(\"myfile.txt\",\"UTF-8\"); 如果用一个不存在的文件构造一个 Scanner, 或者用一个不能被创建的文件名构造一个 PrintWriter,那么就会发生异常。Java 编译器认为这些异常比“被零除” 异常更严重。应该告知编译器： 已经知道有可能出现“ 输入 / 输出” 异常。这需要在 main 方法中用 throws 子句标记，如下所示： public static void main(String[] args) throws IOException { Scanner in = new Scanner(Paths.get(\"myfi1e.txt\"), \"UTF-8\"); } java.util.Scanner 5.0 Scanner(File f) 构造一个从给定文件读取数据的 Scanner。 Scanner(String data) 构造一个从给定字符串读取数据的 Scanner。 java.io.PrintWriter 1.1 PrintWriter(String fileName) 构造一个将数据写入文件的 PrintWriter。文件名由参数指定。 java.nio.file.Paths 7 static Path get(String pathname) 根据给定的路径名构造一个 Path。 ","date":"2021-02-03","objectID":"/java01/:7:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"8 控制流程 ","date":"2021-02-03","objectID":"/java01/:8:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"8.1 条件语句 if 语句 if(布尔表达式) { //如果布尔表达式为true将执行的语句 } if…else if(布尔表达式){ //如果布尔表达式的值为true }else{ //如果布尔表达式的值为false } if…else if…else if(布尔表达式 1){ //如果布尔表达式 1的值为true执行代码 }else if(布尔表达式 2){ //如果布尔表达式 2的值为true执行代码 }else if(布尔表达式 3){ //如果布尔表达式 3的值为true执行代码 }else { //如果以上布尔表达式都不为true执行代码 } 嵌套的 if…else if(布尔表达式 1){ //如果布尔表达式 1的值为true执行代码 if(布尔表达式 2){ //如果(布尔表达式 1的值为true)\u0026\u0026(布尔表达式 2的值为true)执行代码 } } ","date":"2021-02-03","objectID":"/java01/:8:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"8.3 循环 while 循环 //不满足条件，则不能进入循环 while( 布尔表达式 ) { //循环内容 } do…while 循环 //不满足条件，也至少执行一次 do { //代码语句 }while(布尔表达式); for 循环 for(初始化; 布尔表达式; 更新) { //代码语句 } 增强 for 循环 Java5 引入了一种主要用于数组的增强型 for 循环。 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。 for(声明语句 : 表达式) { //代码句子 } /** * Test.java */ public class Test { public static void main(String args[]){ int [] numbers = {10, 20, 30, 40, 50}; for(int x : numbers ){ System.out.print( x ); System.out.print(\",\"); } System.out.print(\"\\n\"); String [] names ={\"James\", \"Larry\", \"Tom\", \"Lacy\"}; for( String name : names ) { System.out.print( name ); System.out.print(\",\"); } } } /** *运行结果 *10,20,30,40,50, *James,Larry,Tom,Lacy, */ switch case 语句 switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型，同时 case 标签必须为字符串常量或字面量。 switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。 case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。 switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。 switch(expression){ case value : //语句 break; //可选 case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句 } ","date":"2021-02-03","objectID":"/java01/:8:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"8.4 中断控制流程语句 break 关键字 break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。 break 跳出最里层的循环，并且继续执行该循环下面的语句。 continue 关键字 continue 适用于任何循环控制结构中。让程序立刻跳转到下一次循环的迭代。 在 for 循环中，continue 语句使程序跳过本次循环。 在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。 ","date":"2021-02-03","objectID":"/java01/:8:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"9 大数值 如果基本的整数和浮点数精度不能够满足需求， 那么可以使用java.math 包中的两个 很有用的类：Biglnteger 和 BigDecimal 这两个类可以处理包含任意长度数字序列的数值。 Biglnteger 类实现了任意精度的整数运算，BigDecimal 实现了任意精度的浮点数运算。 使用静态的 valueOf 方法可以将普通的数值转换为大数值： BigInteger a = BigInteger.valueOf(100); 处理大数值不能使用算术运算符（如：+ 和 *），需要使用大数值类中的 add 和 multiply 方法。 BigInteger c = a.add(b); // c = a + b BigInteger d = c.multiply(b.add(BigInteger.valueOf(2))); // d = c * (b + 2) ","date":"2021-02-03","objectID":"/java01/:9:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"10 数组 数组是一种数据结构，用来存储同一类型值的集合。通过一个整型下标可以访问数组中的每一个值。例如，如果 a 是一个整型数组， a[i] 就是数组中下标为 i 的整数。 ","date":"2021-02-03","objectID":"/java01/:10:0","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"10.1 声明数组 在声明数组变量时，需要指出数组类型 （ 数据元素类型紧跟 []）和数组变量的名字。下面是声明数组变量的语法： dataType[] arrayRefVar; // 首选的方法 dataType arrayRefVar[]; // 效果相同，但不是首选方法 ","date":"2021-02-03","objectID":"/java01/:10:1","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"10.2 创建数组 Java语言使用new操作符来创建数组，语法如下： /** * 使用 dataType[arraySize] 创建了一个数组。 * 把新创建的数组的引用赋值给变量 arrayRefVar。 */ arrayRefVar = new dataType[arraySize]; 数组变量的声明，和创建数组可以用一条语句完成，如下所示： dataType[] arrayRefVar = new dataType[arraySize]; dataType[] arrayRefVar = {value0, value1, ..., valuek}; 数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。 ","date":"2021-02-03","objectID":"/java01/:10:2","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"10.3 处理数组 数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 For-Each 循环。 public class TestArray { public static void main(String[] args) { double[] myList = {1.9, 2.9, 3.4, 3.5}; // 打印所有数组元素 for (int i = 0; i \u003c myList.length; i++) { System.out.println(myList[i] + \" \"); } // 计算所有元素的总和 double total = 0; for (int i = 0; i \u003c myList.length; i++) { total += myList[i]; } System.out.println(\"Total is \" + total); // 查找最大元素 double max = myList[0]; for (int i = 1; i \u003c myList.length; i++) { if (myList[i] \u003e max) max = myList[i]; } System.out.println(\"Max is \" + max); } } //运行结果如下： 1.9 2.9 3.4 3.5 Total is 11.7 Max is 3.5 JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。 语法格式如下： for(type element: array) { System.out.println(element); } public class TestArray { public static void main(String[] args) { double[] myList = {1.9, 2.9, 3.4, 3.5}; // 打印所有数组元素 for (double element: myList) { System.out.println(element); } } } //运行结果如下： 1.9 2.9 3.4 3.5 ","date":"2021-02-03","objectID":"/java01/:10:3","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"10.4 多维数组 多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如： String str[][] = new String[3][4]; 10.4.1 多维数组的动态初始化（以二维数组为例） 直接为每一维分配空间，格式如下： type[][] typeName = new type[typeLength1][typeLength2]; type 可以为基本数据类型和复合数据类型，arraylength1 和 arraylength2 必须为正整数，arraylength1 为行数，arraylength2 为列数。 例如： int a[][] = new int[2][3]; 解析： 二维数组 a 可以看成一个两行三列的数组。 从最高维开始，分别为每一维分配空间，例如： String s[][] = new String[2][]; s[0] = new String[2]; s[1] = new String[3]; s[0][0] = new String(\"Good\"); s[0][1] = new String(\"Luck\"); s[1][0] = new String(\"to\"); s[1][1] = new String(\"you\"); s[1][2] = new String(\"!\"); 解析： s[0]=new String[2] 和 s[1]=new String[3] 是为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度，然后再为其每个数组元素单独分配空间 s0=new String(\"Good\") 等操作。 10.4.2 多维数组的引用（以二维数组为例） 对二维数组中的每个元素，引用方式为 arrayName[index1][index2]，例如： num[1][0]; ","date":"2021-02-03","objectID":"/java01/:10:4","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["Java"],"content":"10.5 Arrays 类 java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。 具有以下功能： 给数组赋值：通过 fill 方法。 对数组排序：通过 sort 方法,按升序。 比较数组：通过 equals 方法比较数组中元素值是否相等。 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。 具体说明请查看下表： 序号 方法 说明 1 public static int binarySearch(Object[] a, Object key) 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1) 2 public static boolean equals(long[] a, long[] a2) 如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等） 3 public static void fill(int[] a, int val) 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等） 4 public static void sort(Object[] a) 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等） ","date":"2021-02-03","objectID":"/java01/:10:5","tags":["Java","JavaVolume"],"title":"[Java核心技术] 基本语句和结构","uri":"/java01/"},{"categories":["MiniProgram"],"content":"微信小程序自定义showToast图片","date":"2020-05-06","objectID":"/miniprogram03/","tags":["MiniProgram","showToast"],"title":"微信小程序自定义showToast图片","uri":"/miniprogram03/"},{"categories":["MiniProgram"],"content":"1 引言 ","date":"2020-05-06","objectID":"/miniprogram03/:1:0","tags":["MiniProgram","showToast"],"title":"微信小程序自定义showToast图片","uri":"/miniprogram03/"},{"categories":["MiniProgram"],"content":"1.1 使用场景 使用场景 在自己制作小程序的过程中，发现小程序自带的wx.showToast很适合做一些提示信息，只是icon仅支持\"success\",“loading\"两个图标，在查找官方文档后我发现，其实wx.showToast是支持自定义图片的，这样一下就方便很多了 ","date":"2020-05-06","objectID":"/miniprogram03/:1:1","tags":["MiniProgram","showToast"],"title":"微信小程序自定义showToast图片","uri":"/miniprogram03/"},{"categories":["MiniProgram"],"content":"1.2 官方文档 官方文档 官方文档 -\u003e API -\u003e 界面 -\u003e 交互 -\u003e wx.showToast wx.showToast(Object object) 显示消息提示框 参数 Object object 属性 类型 说明 title string 提示的内容 icon string 图标，默认 ‘success’ image string 自定义图标的本地路径，image 的优先级高于 icon duration number 提示的延迟时间,默认1500 mask boolean 是否显示透明蒙层，防止触摸穿透 ，默认：false success function 接口调用成功的回调函数 fail function 接口调用失败的回调函数 complete function 接口调用结束的回调函数（调用成功、失败都会执行） object.icon 的合法值 值 说明 success 显示成功图标，此时 title 文本最多显示 7 个汉字长度 loading 显示加载图标，此时 title 文本最多显示 7 个汉字长度 none 不显示图标，此时 title 文本最多可显示两行 注意 wx.showLoading 和 wx.showToast 同时只能显示一个 wx.showToast 应与 wx.hideToast 配对使用 ","date":"2020-05-06","objectID":"/miniprogram03/:1:2","tags":["MiniProgram","showToast"],"title":"微信小程序自定义showToast图片","uri":"/miniprogram03/"},{"categories":["MiniProgram"],"content":"2 代码实现 ","date":"2020-05-06","objectID":"/miniprogram03/:2:0","tags":["MiniProgram","showToast"],"title":"微信小程序自定义showToast图片","uri":"/miniprogram03/"},{"categories":["MiniProgram"],"content":"2.1 app.js // 为方便管理，我们先在 app.js 中定义一个函数 demoToast:function(title,image){ wx.showToast({ title: title, image:'/images/' + image, duration: 2000, mask:true }) }, ","date":"2020-05-06","objectID":"/miniprogram03/:2:1","tags":["MiniProgram","showToast"],"title":"微信小程序自定义showToast图片","uri":"/miniprogram03/"},{"categories":["MiniProgram"],"content":"2.2 /pages/face/face_login.js // 日后使用中，我们只需要调用 app.js 中的 demoToast 函数就可以使用 const app = getApp(); // 加载中,使用 wx.showLoading wx.showLoading ({ title: \"正在登录\", }) //成功 app.demoToast('测试成功','success.png'); // 失败 app.demoToast('测试失败','fail.png'); ","date":"2020-05-06","objectID":"/miniprogram03/:2:2","tags":["MiniProgram","showToast"],"title":"微信小程序自定义showToast图片","uri":"/miniprogram03/"},{"categories":["MiniProgram"],"content":"3 效果演示 ","date":"2020-05-06","objectID":"/miniprogram03/:3:0","tags":["MiniProgram","showToast"],"title":"微信小程序自定义showToast图片","uri":"/miniprogram03/"},{"categories":["MiniProgram"],"content":"3.1 加载中 ","date":"2020-05-06","objectID":"/miniprogram03/:3:1","tags":["MiniProgram","showToast"],"title":"微信小程序自定义showToast图片","uri":"/miniprogram03/"},{"categories":["MiniProgram"],"content":"3.2 失败 ","date":"2020-05-06","objectID":"/miniprogram03/:3:2","tags":["MiniProgram","showToast"],"title":"微信小程序自定义showToast图片","uri":"/miniprogram03/"},{"categories":["MiniProgram"],"content":"3.3 成功 ","date":"2020-05-06","objectID":"/miniprogram03/:3:3","tags":["MiniProgram","showToast"],"title":"微信小程序自定义showToast图片","uri":"/miniprogram03/"},{"categories":["MiniProgram"],"content":"4 参考资料 参考资料 微信小程序官方文档 https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html ","date":"2020-05-06","objectID":"/miniprogram03/:4:0","tags":["MiniProgram","showToast"],"title":"微信小程序自定义showToast图片","uri":"/miniprogram03/"},{"categories":["MiniProgram"],"content":"微信小程序函数节流，防止多次点击跳转","date":"2020-04-20","objectID":"/miniprogram02/","tags":["MiniProgram","函数节流"],"title":"微信小程序函数节流，防止多次点击跳转","uri":"/miniprogram02/"},{"categories":["MiniProgram"],"content":"1 使用场景 使用场景 在微信小程序中，点击“采集人脸”按钮后需要将相机采集到的照片上传到服务器，并进行人脸识别，在此过程存在一定时间的延迟，用户会误认为点击无效而进行多次点击，最后出现多次跳转页面的情况。 函数节流(throttle)：函数在一段时间内多次触发只会执行第一次，在这段时间结束前，不管触发多少次也不会执行函数。 ","date":"2020-04-20","objectID":"/miniprogram02/:1:0","tags":["MiniProgram","函数节流"],"title":"微信小程序函数节流，防止多次点击跳转","uri":"/miniprogram02/"},{"categories":["MiniProgram"],"content":"2 代码实现 ","date":"2020-04-20","objectID":"/miniprogram02/:2:0","tags":["MiniProgram","函数节流"],"title":"微信小程序函数节流，防止多次点击跳转","uri":"/miniprogram02/"},{"categories":["MiniProgram"],"content":"2.1 /utils/util.js # /utils/util.js function throttle(fn, gapTime) { if (gapTime == null || gapTime == undefined) { gapTime = 1500 } let _lastTime = null // 返回新的函数 return function () { let _nowTime = + new Date() if (_nowTime - _lastTime \u003e gapTime || !_lastTime) { fn.apply(this, arguments) //将this和参数传给原函数 _lastTime = _nowTime } } } ","date":"2020-04-20","objectID":"/miniprogram02/:2:1","tags":["MiniProgram","函数节流"],"title":"微信小程序函数节流，防止多次点击跳转","uri":"/miniprogram02/"},{"categories":["MiniProgram"],"content":"2.2 /pages/face/face_register.wxml \u003cview class='moto-container-collection'\u003e \u003ctext class = 'moto' bindtap=\"open\" type=\"primary\" data-type=\"takePhoto\"\u003e采集人脸\u003c/text\u003e \u003c/view\u003e ","date":"2020-04-20","objectID":"/miniprogram02/:2:2","tags":["MiniProgram","函数节流"],"title":"微信小程序函数节流，防止多次点击跳转","uri":"/miniprogram02/"},{"categories":["MiniProgram"],"content":"2.3 /pages/face/face_register.js //引用util.js const util = require('../../utils/util.js') //1s触发一次 Page({ open: util.throttle(function () { ... }, 1000) }) ","date":"2020-04-20","objectID":"/miniprogram02/:2:3","tags":["MiniProgram","函数节流"],"title":"微信小程序函数节流，防止多次点击跳转","uri":"/miniprogram02/"},{"categories":["MiniProgram"],"content":"3 参考资料 参考资料 该链接中有更加详细的讲解，可以前往学习参考 https://www.cnblogs.com/fps2tao/p/12186523.html ","date":"2020-04-20","objectID":"/miniprogram02/:3:0","tags":["MiniProgram","函数节流"],"title":"微信小程序函数节流，防止多次点击跳转","uri":"/miniprogram02/"},{"categories":["Ubuntu"],"content":"这篇文章展示了如何在Ubuntu16.04系统中安装Mysql数据库","date":"2020-04-18","objectID":"/ubuntu-mysql/","tags":["Ubuntu16.04","Mysql","Workbench"],"title":"Ubuntu16.04安装Mysql数据库","uri":"/ubuntu-mysql/"},{"categories":["Ubuntu"],"content":"这篇文章展示了如何在Ubuntu16.04系统中安装Mysql数据库，并安装可视化工具WorkBench 系统环境 Ubuntu 16.04 ","date":"2020-04-18","objectID":"/ubuntu-mysql/:0:0","tags":["Ubuntu16.04","Mysql","Workbench"],"title":"Ubuntu16.04安装Mysql数据库","uri":"/ubuntu-mysql/"},{"categories":["Ubuntu"],"content":"1 ubuntu安装Mysql # 更新安装源 sudo apt-get update # 安装mysql sudo apt-get install mysql-server # 安装过程中按提示设置root用户的密码 笔记 上述命令会安装以下包： apparmor mysql-client-5.7 mysql-common mysql-server mysql-server-5.7 mysql-server-core-5.7 ","date":"2020-04-18","objectID":"/ubuntu-mysql/:1:0","tags":["Ubuntu16.04","Mysql","Workbench"],"title":"Ubuntu16.04安装Mysql数据库","uri":"/ubuntu-mysql/"},{"categories":["Ubuntu"],"content":"2 启动和关闭mysql服务器 # 启动服务器 service mysql start # 关闭服务器 service mysql stop # 确认是否启动成功，若mysql节点处于LiSTEN状态表示启动成功 sudo netstat -tap | grep mysql ","date":"2020-04-18","objectID":"/ubuntu-mysql/:2:0","tags":["Ubuntu16.04","Mysql","Workbench"],"title":"Ubuntu16.04安装Mysql数据库","uri":"/ubuntu-mysql/"},{"categories":["Ubuntu"],"content":"3 进入mysql shell界面 mysql -u root -p ","date":"2020-04-18","objectID":"/ubuntu-mysql/:3:0","tags":["Ubuntu16.04","Mysql","Workbench"],"title":"Ubuntu16.04安装Mysql数据库","uri":"/ubuntu-mysql/"},{"categories":["Ubuntu"],"content":"4 安装可视化工具mysql-workbench sudo apt-get install mysql-workbench ","date":"2020-04-18","objectID":"/ubuntu-mysql/:4:0","tags":["Ubuntu16.04","Mysql","Workbench"],"title":"Ubuntu16.04安装Mysql数据库","uri":"/ubuntu-mysql/"},{"categories":["Ubuntu"],"content":"5 参考资料 笔记 https://blog.csdn.net/weixin_42209572/article/details/98983741 https://blog.csdn.net/bianchengxiaosheng/article/details/78494648 ","date":"2020-04-18","objectID":"/ubuntu-mysql/:5:0","tags":["Ubuntu16.04","Mysql","Workbench"],"title":"Ubuntu16.04安装Mysql数据库","uri":"/ubuntu-mysql/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 人脸属性业务实战","date":"2020-03-23","objectID":"/face12/","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 人脸属性业务实战 ","date":"2020-03-23","objectID":"/face12/:0:0","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"1 人脸属性业务介绍 ","date":"2020-03-23","objectID":"/face12/:1:0","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"1.1 什么是人脸属性 人脸属性指的是根据给定的人脸判断其性别、年龄和表情等 分类问题、回归问题 性别、是否戴眼镜、年轻人、微笑 ","date":"2020-03-23","objectID":"/face12/:1:1","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"1.2 常用数据集 常用数据集 UTKFace SCUT-FBP5500 CelebA APPA-REAL AFAD Dataset FER+ NKI ","date":"2020-03-23","objectID":"/face12/:1:2","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"2 人脸属性方法介绍 离散值：性别，戴眼镜，戴面纱，种族，表情等 连续值：年龄等 ","date":"2020-03-23","objectID":"/face12/:2:0","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"3 人脸属性方法难点 数据：不同人种，不同年龄，不同性别等等 林志颖、郭德纲年龄差别不大，但从面部很难区分 ","date":"2020-03-23","objectID":"/face12/:3:0","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"4 数据准备 CelebA CelebA是香港中文大学的开放数据，包含10177个名人身份的202599张图片 40个属性 ","date":"2020-03-23","objectID":"/face12/:4:0","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"4.1 数据下载 Google Drive Baidu Drive 4.1.1 说明 下载后会得到三个文件夹和一个 README.txt CelebA中有 10,177人 的 202,599张 图片 ├── Anno │ ├── identity_CelebA.txt │ ├── list_attr_celeba.txt │ ├── list_bbox_celeba.txt │ ├── list_landmarks_align_celeba.txt │ └── list_landmarks_celeba.txt ├── Eval │ └── list_eval_partition.txt ├── Img │ ├── img_celeba.7z │ ├── img_align_celeba.zip │ └── img_align_celeba_png.7z └── README.txt 笔记 identity_CelebA.txt 身份标记：图片名 + 编号，相同编号代表同一人，如：000001.jpg 2880 list_attr_celeba.txt 标记图片属性 list_landmarks_align_celeba.txt 对齐后的图片，人脸标记（眼鼻嘴）lefteye_x lefteye_y righteye_x righteye_y nose_x nose_y leftmouth_x leftmouth_y rightmouth_x rightmouth_y list_landmarks_celeba.txt 自然环境下的图片，人脸标记（眼鼻嘴）lefteye_x lefteye_y righteye_x righteye_y nose_x nose_y leftmouth_x leftmouth_y rightmouth_x rightmouth_y list_eval_partition.txt 分组：训练、验证、测试 4.1.2 下载的图片 img_celeba.7z：纯“野生”文件，也就是从网络爬取的没有做裁剪的图片 img_align_celeba.zip：jpg格式的，比较小（推荐使用，直接解压即可 img_align_celeba_png.7z：把“野生”文件裁剪出人脸部分之后的图片，png格式 4.1.3 list_attr_celeba.txt中属性说明 英文 中文 5_o_Clock_Shadow 胡须 Arched_Eyebrows 柳叶眉 Attractive 有魅力 Bags_Under_Eyes 眼袋 Bald 秃顶 Bangs 刘海 Big_Lips 大嘴唇 Big_Nose 大鼻子 Black_Hair 黑发 Blond_Hair 金发 Blurry 模糊 Brown_Hair 棕色头发 Bushy_Eyebrows 浓眉 Chubby 圆脸 Double_Chin 双下巴 Eyeglasses 戴眼镜 Goatee 山羊胡子 Gray_Hair 白发 Heavy_Makeup 浓妆 High_Cheekbones 高颧骨 Male 男人 Mouth_Slightly_Open 嘴微微张开 Mustache 胡子 Narrow_Eyes 小眼睛 No_Beard 没有胡须 Oval_Face 鸭蛋脸 Pale_Skin 苍白的皮肤 Pointy_Nose 尖鼻子 Receding_Hairline 发际线高 Rosy_Cheeks 红润的脸颊 Sideburns 鬓胡 Smiling 微笑 Straight_Hair 直发 Wavy_Hair 卷发 Wearing_Earrings 戴着耳环 Wearing_Hat 戴着帽子 Wearing_Lipstick 擦口红 Wearing_Necklace 戴着项链 Wearing_Necktie 戴着领带 Young 年轻 ","date":"2020-03-23","objectID":"/face12/:4:1","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"4.2 数据处理 对img_celeba.7z.001~img_celeba.7z.014这14个文件进行合并，得到一个img_celeba.7z文件，并解压 # 数据合并 cat img_celeba.7z.0** \u003e img_celeba.7z # 安装 7z sudo apt-get install p7zip-full # 解压 7z x img_celeba.7z ","date":"2020-03-23","objectID":"/face12/:4:2","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"5 多任务网络结构 ","date":"2020-03-23","objectID":"/face12/:5:0","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"6 实例代码 ","date":"2020-03-23","objectID":"/face12/:6:0","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"6.1 数据集处理 人脸属性的标注信息存储在Anno文件夹下的list_attr_celeba.txt中，从标注文件中可以看出，CelebA数据集中标注了40种人脸属性的信息，系统选取其中的四个属性进行数据打包，分别为是否戴眼镜、性别、是否微笑、是否年轻，这四个属性对应的下标依次为15、20、31、39。 在进行数据打包前，需要先对人脸图片进行适当的处理，在CelebA数据集中，所有的人脸图片存储在Img文件夹下，所有人脸图片又分为三类文件，分别是img_celeba.7z，纯“野生”文件，即从网络上爬取的没有进行裁剪的图片，img_algin_celeba_png.7z，将爬取到的“野生”文件裁剪出人脸部分后的到的图片，并且图片的格式为png格式，img_align_celeba.zip,将爬取到的“野生”文件经过人脸对齐和裁剪后得到的人脸图像，图片的格式为jpg格式，图片比较小，所以系统选用了img_algin_celeba文件中的图片进行处理和模型训练。 在数据集处理中，使用dlib库定义人脸检测器，对数据集中的人脸图片进行人脸检测，若没有发现人脸信息则将这张图片过滤掉，在成功获取到人脸框之后，需要对人脸框进行一定的扩充，对扩充后的人脸框仍然小于50 * 50的人脸图片要将其过滤掉，对数据集中的图片进行过滤的代码如下： if len(rects) == 0: continue x1 = rects[0].left() y1 = rects[0].top() x2 = rects[0].right() y2 = rects[0].bottom() y1 = int(max(y1 - 0.3 * (y2 - y1), 0)) if y2 - y1 \u003c 50 or x2 - x1 \u003c 50 or x1 \u003c 0 or y1 \u003c 0: continue 对符合要求的人脸图片，先进行人脸对齐，将图片裁剪为128 * 128的大小，然后定义tfrecord字典的格式，其中image为byte型，eyeglasses、male、smiling、young为int型，相关代码如下： ex = tf.train.Example( features = tf.train.Features( feature = { \"image\": tf.train.Feature( bytes_list = tf.train.BytesList(value=[im_data.tobytes()]) ), \"Eyeglasses\": tf.train.Feature( int64_list = tf.train.Int64List( value = [int(attr_val[16])] ) ), \"Male\": tf.train.Feature( int64_list = tf.train.Int64List( value = [int(attr_val[21])] ) ), \"Smiling\": tf.train.Feature( int64_list=tf.train.Int64List( value=[int(attr_val[32])] ) ), \"Young\": tf.train.Feature( int64_list = tf.train.Int64List( value = [int(attr_val[40])] ) ) } ) ) 最后，对数据集进行训练集与测试集的划分，其中95%的数据划分为训练集，剩余的5%划分为测试集。 ","date":"2020-03-23","objectID":"/face12/:6:1","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"6.2 模型训练 主干网络使用slim提供的inception_v3_base，batch_norm层的参数配置如下： batch_norm_params = { \"is_training\": is_training, \"trainable\": True, \"decay\": 0.9997, \"epsilon\": 0.00001, \"variables_collections\":{ \"beta\": None, \"gamma\": None, \"moving_mean\":[\"moving_vars\"], \"moving_variance\": ['moving_var'] } } 对卷积层和全连接层进行权值上的约束时，正则化方法采用L2正则，并定义这些层是可训练的，对卷积层的参数进行初始化，调用主干网络即inception_v3_base传入图片，获取到inception_v3_base网络的输出结果，使用tf.reduce_mean函数计算张量tensor沿着1、2维度上的平均值。使用tf.nn.dropout函数在训练过程中随机的扔掉一部分神经元，防止或减轻过拟合问题，针对系统研究的四个属性以主干网络的输出为四个分支的输入来定义分支，主要代码如下： weights_regularizer = tf.contrib.layers.l2_regularizer(0.00004) with tf.contrib.slim.arg_scope( [tf.contrib.slim.conv2d, tf.contrib.slim.fully_connected], weights_regularizer = weights_regularizer, trainable = True): with tf.contrib.slim.arg_scope( [tf.contrib.slim.conv2d], weights_initializer = tf.truncated_normal_initializer(stddev=0.1), activation_fn = tf.nn.relu, normalizer_fn = batch_norm, normalizer_params = batch_norm_params): nets, endpoints = inception_v3_base(images) print(nets) print(endpoints) net = tf.reduce_mean(nets,axis=[1,2]) net = tf.nn.dropout(net, drop_out, name = \"droplast\") net = flatten(net, scope=\"flatten\") net_eyeglasses = slim.fully_connected(net, 2, activation_fn = None) net_male = slim.fully_connected(net, 2, activation_fn=None) net_smiling = slim.fully_connected(net, 2, activation_fn=None) net_young = slim.fully_connected(net, 2, activation_fn=None) return net_eyeglasses, net_male, net_smiling, net_young 输入和label定义：网络搭建完成后，定义输入和label，并获取网络的预测结果，对于模型训练设置dropout=0.5，is_training=True，代码如下： input_x = tf.placeholder(tf.float32, shape=[None, 128, 128, 3]) label_eyeglasses = tf.placeholder(tf.int64, shape=[None, 1]) label_male = tf.placeholder(tf.int64, shape=[None, 1]) label_smiling = tf.placeholder(tf.int64, shape=[None, 1]) label_young = tf.placeholder(tf.int64, shape=[None, 1]) Loss的定义：采用交叉熵损失作为模型训练的Loss，对于tf.losses.sparse_softmax_cross_entropy其中labels是一维的， 预测结果是二维的，最后结果选取二维的最大值所对应的索引，即概率分布中最大的值。使用tf.nn.softmax将预测结果处理到0 ~ 1之间，将loss_eyeglasses，loss_male，loss_smiling，loss_young相加来定义总的loss，接着定义正则化的loss，定义loss的代码如下： loss_eyeglasses = tf.losses.sparse_softmax_cross_entropy( labels= label_eyeglasses, logits = logits_eyeglasses) loss_male = tf.losses.sparse_softmax_cross_entropy( labels=label_male, logits = logits_male) loss_smiling = tf.losses.sparse_softmax_cross_entropy( labels = label_smiling, logits = logits_smiling) loss_young = tf.losses.sparse_softmax_cross_entropy( labels = label_young, logits = logits_young) logits_eyeglasses = tf.nn.softmax(logits_eyeglasses) logits_male = tf.nn.softmax(logits_male) logits_smiling = tf.nn.softmax(logits_smiling) logits_young = tf.nn.softmax(logits_young) loss = loss_eyeglasses + loss_male + loss_smiling + loss_young reg_set = tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES) l2_loss = tf.add_n(reg_set) 学习方式与学习率的定义：定义学习率的衰减方式为指数衰减，初始学习率为0.0001，衰减的步长为1000，每次衰减的比率为0.98，相关代码如下： global_step = tf.Variable(0, trainable=True) lr = tf.train.exponential_decay(0.0001, global_step, decay_steps=1000, decay_rate=0.98, staircase=False) 优化器的定义:定义训练的方式为AdamOptimizer，传入学习率和loss，相关代码如下： update_ops = tf.get_collection(tf.GraphKeys.UPDATE_OPS) with tf.control_dependencies(update_ops): train_op = tf.train.AdamOptimizer(lr).minimize(loss + l2_loss, global_step) 对于训练集使用tf.train.shuffle_batch将队列中的数据打乱后再读取，在数据打包时，各个属性的label值用-1,1来表示，对这些值进行处理，将数据变为0,1，相关代码如下： batch_im = features[\"image\"] batch_eye = (features[\"Eyeglasses\"] + 1) // 2 batch_male = (features[\"Male\"] + 1) // 2 batch_smiling = (features[\"Smiling\"] + 1) // 2 batch_young = (features[\"Young\"] + 1) // 2 batch_im = tf.decode_raw(batch_im, tf.uint8) 模型共训练150000次，并对模型和日志信息进行保存，loss曲线如下图所示： ","date":"2020-03-23","objectID":"/face12/:6:2","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"6.3 模型固化 模型前项推理基本与模型训练部分一致，需要注意的是inception_v3函数中的dropout需要修改为1.0，is_training修改为False。 为了使预测结果更直观，调用起来更方便，将softmax值转换成argmax值，得到概率分布值高的所对应的轴，实现代码如下： logits_eyeglasses = tf.nn.softmax(logits_eyeglasses) logits_male = tf.nn.softmax(logits_male) logits_smiling = tf.nn.softmax(logits_smiling) logits_young = tf.nn.softmax(logits_young) logits_eyeglasses = tf.argmax(logits_eyeglasses, axis=1) logits_male = tf.argmax(logits_male, axis=1) logits_smiling = tf.argmax(logits_smiling, axis=1) logits_young = tf.argmax(logits_young, axis=1) 使用convert_variables_to_constants函数将计算图中的变量取值以常量的形式保存。在人脸属性模型的多任务网络中，在模型固化的节点list中放入人脸属性的四个节点的tensor的name，从而转化多任务网络的pb模型，参数配置如下： output_graph_def = tf.graph_util.\\ convert_variables_to_constants(session, session.graph.as_graph_def(), ['ArgMax', 'ArgMax_1', 'ArgMax_2', 'ArgMax_3']) ","date":"2020-03-23","objectID":"/face12/:6:3","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"6.4 模型测试 首先，读取打包好的pb文件，进行反序列化，恢复当前的graph。接着，获取需要推理的tensor，分别为pred_eyeglasses、pred_young、pred_male、pred_smiling，使用opencv读取测试图片，使用dlib库定义人脸检测器，提取出人脸框，并进行人脸数据的裁剪，计算当前四个tensor所对应的值，并在控制台打印输出结果，人脸属性模型测试结果如下图所示： ","date":"2020-03-23","objectID":"/face12/:6:4","tags":["FaceRecognition","TensorFlow","FaceAttribute"],"title":"人脸属性业务实战","uri":"/face12/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 活体检测业务实战","date":"2020-03-22","objectID":"/face11/","tags":["FaceRecognition","TensorFlow","FaceAlignment","FaceBiopsy"],"title":"活体检测业务实战","uri":"/face11/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 活体检测业务实战 ","date":"2020-03-22","objectID":"/face11/:0:0","tags":["FaceRecognition","TensorFlow","FaceAlignment","FaceBiopsy"],"title":"活体检测业务实战","uri":"/face11/"},{"categories":["FaceRecognition"],"content":"1 活体检测业务介绍 ","date":"2020-03-22","objectID":"/face11/:1:0","tags":["FaceRecognition","TensorFlow","FaceAlignment","FaceBiopsy"],"title":"活体检测业务实战","uri":"/face11/"},{"categories":["FaceRecognition"],"content":"1.1 什么是活体检测 为防止恶意者伪造和窃取他人的生物特征用于身份认证 判断提交的生物特征是否来自有生命的个体 ","date":"2020-03-22","objectID":"/face11/:1:1","tags":["FaceRecognition","TensorFlow","FaceAlignment","FaceBiopsy"],"title":"活体检测业务实战","uri":"/face11/"},{"categories":["FaceRecognition"],"content":"1.2 常见判断方式 人脸左转、右转、张嘴、眨眼等 前端：通过“动作+指令”采集数据 后端：对采集到的连续多帧数据进行分析 结果：判断是否完成相应动作 ","date":"2020-03-22","objectID":"/face11/:1:2","tags":["FaceRecognition","TensorFlow","FaceAlignment","FaceBiopsy"],"title":"活体检测业务实战","uri":"/face11/"},{"categories":["FaceRecognition"],"content":"2 活体检测方法介绍 ","date":"2020-03-22","objectID":"/face11/:2:0","tags":["FaceRecognition","TensorFlow","FaceAlignment","FaceBiopsy"],"title":"活体检测业务实战","uri":"/face11/"},{"categories":["FaceRecognition"],"content":"2.1 传统方法 基于脸部视觉特征的方法： 颜色纹理分析 材料（皮肤、纸面、镜面） 帧差信息 光流算法 脸部形状变化 ","date":"2020-03-22","objectID":"/face11/:2:1","tags":["FaceRecognition","TensorFlow","FaceAlignment","FaceBiopsy"],"title":"活体检测业务实战","uri":"/face11/"},{"categories":["FaceRecognition"],"content":"2.2 深度学习方法 多帧序列分析（CNN+LSTM） 人脸深度图（差异性分析） 3D landmark 多任务网络：人脸检测+人脸分类（真假人脸） ","date":"2020-03-22","objectID":"/face11/:2:2","tags":["FaceRecognition","TensorFlow","FaceAlignment","FaceBiopsy"],"title":"活体检测业务实战","uri":"/face11/"},{"categories":["FaceRecognition"],"content":"2.3 基于Landmark的方法（将用到的） 笔记 输入连续多帧人脸：摄像头不停向后端输送人脸 关键点定位：先进行人脸检测 -\u003e 关键点定位 动作检测：根据指定的动作指令来判定当前的多帧人脸关键点位置坐标的差异，根据坐标的差异判断人脸目前的动作，需要对坐标进行归一化，规避掉大小人脸。 张嘴检测 |嘴巴上部关键点 - 嘴巴下部关键点| \u003e 阈值 眨眼检测 |左眼眼睛上部关键点 - 左眼眼睛下部关键点| \u003e 阈值 |右眼眼睛上部关键点 - 右眼眼睛下部关键点| \u003e 阈值 ","date":"2020-03-22","objectID":"/face11/:3:0","tags":["FaceRecognition","TensorFlow","FaceAlignment","FaceBiopsy"],"title":"活体检测业务实战","uri":"/face11/"},{"categories":["FaceRecognition"],"content":"3 活体检测问题挑战及解决思路 作弊问题（镜面、视频） 约束场景下的活体检测 3D Landmark End2end的活体检测算法 tracking ","date":"2020-03-22","objectID":"/face11/:4:0","tags":["FaceRecognition","TensorFlow","FaceAlignment","FaceBiopsy"],"title":"活体检测业务实战","uri":"/face11/"},{"categories":["FaceRecognition"],"content":"4 Dlib 68点人脸检测 ","date":"2020-03-22","objectID":"/face11/:5:0","tags":["FaceRecognition","TensorFlow","FaceAlignment","FaceBiopsy"],"title":"活体检测业务实战","uri":"/face11/"},{"categories":["FaceRecognition"],"content":"5 实例代码 人脸关键点及活体检测页面相框会根据识别状态进行静态或动态的变化，用户点击开始后，小程序每1000ms采集一张图片并上传至服务端，根据服务端返回的68个人脸坐标信息，使用canvas将这68个人脸关键点绘制到对应的人脸图片中。 微信小程序利用服务端返回的68个人脸关键点的坐标信息，实现用户的张闭嘴检测和睁闭眼检测。 张闭嘴检测：|嘴巴上部关键点 - 嘴巴下部关键点| \u003e 阈值 睁闭眼检测：|左眼眼睛上部关键点 - 左眼眼睛下部关键点| \u003e 阈值 |右眼眼睛上部关键点 - 右眼眼睛下部关键点| \u003e 阈值 系统经过多次实际测试后，选取第67和第63个点用于张闭嘴检测，并设定阈值为0.03选取图6.7中的第41、第37、第46和第44个点用于睁闭眼状态的检测，并设定阈值为0.03，将识别的结果以emoji图片和文字两种形式，实时显示在页面中，核心代码如下： var diff1 = pos[67 * 4 + 1 ] - pos[63 * 4 + 1]; var diff2 = pos[41 * 4 + 1 ] - pos[37 * 4 + 1]; var diff3 = pos[46 * 4 + 1 ] - pos[44 * 4 + 1]; if(diff1 \u003e 0.03){ if( diff2 \u003c 0.03 \u0026\u0026 diff3 \u003c 0.03){ that.setData({ landmark_img:\"ecmo\"}) }else{ that.setData({ landmark_img:\"eomo\"}) } } if(diff1 \u003c= 0.03){ if( diff2 \u003c 0.03 \u0026\u0026 diff3 \u003c 0.03){ that.setData({ landmark_img:\"ecmc\"}) }else{ that.setData({ landmark_img:\"eomc\"}) } } ","date":"2020-03-22","objectID":"/face11/:6:0","tags":["FaceRecognition","TensorFlow","FaceAlignment","FaceBiopsy"],"title":"活体检测业务实战","uri":"/face11/"},{"categories":["MiniProgram"],"content":"结合微信小程序官方文档，学习小程序基础必背知识","date":"2020-03-21","objectID":"/miniprogram01/","tags":["MiniProgram"],"title":"结合官方文档，入门微信小程序","uri":"/miniprogram01/"},{"categories":["MiniProgram"],"content":"结合微信小程序官方文档，学习小程序基础必背知识 ","date":"2020-03-21","objectID":"/miniprogram01/:0:0","tags":["MiniProgram"],"title":"结合官方文档，入门微信小程序","uri":"/miniprogram01/"},{"categories":["MiniProgram"],"content":"1 什么是微信小程序 ","date":"2020-03-21","objectID":"/miniprogram01/:1:0","tags":["MiniProgram"],"title":"结合官方文档，入门微信小程序","uri":"/miniprogram01/"},{"categories":["MiniProgram"],"content":"1.1 张小龙这样定义 不需要下载安装即可使用 用户“用完即走”，不用关心是否安装太多应用 应用将无处不在，随时可用 ","date":"2020-03-21","objectID":"/miniprogram01/:1:1","tags":["MiniProgram"],"title":"结合官方文档，入门微信小程序","uri":"/miniprogram01/"},{"categories":["MiniProgram"],"content":"1.2 小程序特点 小程序适合做简单的、用完即走的应用 小程序适合低频的应用 小程序适合性能要求不高的应用 ","date":"2020-03-21","objectID":"/miniprogram01/:1:2","tags":["MiniProgram"],"title":"结合官方文档，入门微信小程序","uri":"/miniprogram01/"},{"categories":["MiniProgram"],"content":"2 小程序入门基础知识 小程序文件类型与目录结构 注册小程序页面，View、Text等组件的基本用法 Flex弹性盒子模型 移动端分辨率及小程序自适应单位RPX ","date":"2020-03-21","objectID":"/miniprogram01/:2:0","tags":["MiniProgram"],"title":"结合官方文档，入门微信小程序","uri":"/miniprogram01/"},{"categories":["MiniProgram"],"content":"2.1 小程序类型与目录结构 ├── app.js ├── app.json ├── app.wxss ├── pages │ │── index │ │ ├── index.wxml │ │ ├── index.js │ │ ├── index.json │ │ └── index.wxss │ └── logs │ ├── logs.wxml │ └── logs.js ├── utils └── project.config.json 笔记 pages 存放页面 文件 作用 举例（英雄联盟） js 逻辑 “技能” wxml 骨架 “英雄” wxss 样式 “皮肤” json 配置 “符文” utils 工具类 app.js 应用程序级别的逻辑 app.json 应用程序级别的配置 app.wxss 应用程序级别的全局样式 project.config.json 项目配置文件 就近原则 页面配置 高于 全局配置 ","date":"2020-03-21","objectID":"/miniprogram01/:2:1","tags":["MiniProgram"],"title":"结合官方文档，入门微信小程序","uri":"/miniprogram01/"},{"categories":["MiniProgram"],"content":"2.2 注册小程序页面 官方文档 官方文档 -\u003e 框架 -\u003e 小程序配置 -\u003e 全局配置 -\u003e pages app.json -\u003e pages pages 用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名）信息。文件名不需要写文件后缀，框架会自动去寻找对于位置的 .json, .js, .wxml, .wxss 四个文件进行处理。 数组的第一项代表小程序的初始页面（首页）。小程序中新增/减少页面，都需要对 pages 数组进行修改。 { \"pages\": [\"pages/index/index\", \"pages/logs/logs\"] } ","date":"2020-03-21","objectID":"/miniprogram01/:2:2","tags":["MiniProgram"],"title":"结合官方文档，入门微信小程序","uri":"/miniprogram01/"},{"categories":["MiniProgram"],"content":"2.3 基本组件 2.3.1 view 官方文档 官方文档 -\u003e 组件 -\u003e 视图容器 -\u003e view \u003cview\u003e \u003c/view\u003e 相当于网页中的 \u003cdiv\u003e \u003c/div\u003e 作用：容器、分隔文档 2.3.2 text 官方文档 官方文档 -\u003e 组件 -\u003e 基础内容 -\u003e text 写文本时最好用\u003ctext\u003e \u003c/text\u003e包裹，便于对文件设置样式和添加标签 不建议直接使用\u003cbutton\u003e \u003c/button\u003e，可以使用\u003cview\u003e \u003ctext\u003e 按钮 \u003c/text\u003e \u003c/view\u003e的形式来实现按钮 2.3.3 window 官方文档 官方文档 -\u003e 框架 -\u003e 小程序配置 -\u003e 全局配置 -\u003e window 用于设置小程序的状态栏、导航条、标题、窗口背景色。 { \"window\": { \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTextStyle\": \"black\", \"navigationBarTitleText\": \"微信接口功能演示\", \"backgroundColor\": \"#eeeeee\", \"backgroundTextStyle\": \"light\" } } ","date":"2020-03-21","objectID":"/miniprogram01/:2:3","tags":["MiniProgram"],"title":"结合官方文档，入门微信小程序","uri":"/miniprogram01/"},{"categories":["MiniProgram"],"content":"2.4 Flex弹性盒子模型 Flex弹性盒子模型是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。 目的:是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。 弹性盒子由弹性容器(Flex container)和弹性子元素(Flex item)组成。 弹性容器通过设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器。 弹性容器内包含了一个或多个弹性子元素。 常用属性 .container{ display: flex; flex-direction:column; /*垂直分布*/ align-items: center; /*元素居中*/ } ","date":"2020-03-21","objectID":"/miniprogram01/:2:4","tags":["MiniProgram"],"title":"结合官方文档，入门微信小程序","uri":"/miniprogram01/"},{"categories":["MiniProgram"],"content":"2.5 移动端分辨率及小程序自适应单位RPX 官方文档 官方文档 -\u003e 指南 -\u003e 小程序框架 -\u003e 视图层 -\u003e wxss 设备 屏幕尺寸 分辨率(pt) Reader 分辨率(px) 渲染后 PPI iPhone 3GS 3.5寸 320x480 @1x 320x480 空 163 iPhone 4/4s 3.5寸 320x480 @2x 640x960 空 326 iPhone 5/5S/5C 4.0寸 320x568 @2x 640x1136 空 326 iPhone 6/6S 4.7寸 375x667 @2x 750x1334 空 326 iPhone 6/6S Plus 5.5寸 414x736 @3x 1242x2208 1080x1920 401 小程序图片默认值 width:300px;height:225px 图片使用px图片不会随机型、分辨率等的变化而变化 图片使用rpx图片会随机型、分辨率等的变化而变化 pt 就是point，是一种固定长度的度量单位，是能够使用测量设备测得的长度，是排版印刷中常用的文字大小单位。 px 就是表示pixel，像素，是屏幕上显示数据的最基本的点。 px可以在计算机屏幕上，能达到预期的效果，在打印机和其它的高分辨率设备上，它又能取得所希望的效果。 px是一个点，它不是自然界的长度单位，谁能说出一个“点”有多长多大么？可以画的很小，也可以很大。如果点很小，那画面就清晰，我们称它为“分辨率高”，反之，就是“分辨率低”。所以，“像素”的大小是会“变”的，也称为“相对长度”。 ppi Pixels Per Inch也叫像素密度，所表示的是每英寸所拥有的像素数量。因此PPI数值越高，即代表显示屏能够以越高的密度显示图像，当然，显示的密度越高，拟真度就越高。 公式表达为 $ PPI=\\sqrt{(X^2+Y^2)} / Z $ $X$：长度像素数； $Y$：宽度像素数； $Z$：屏幕大小 ","date":"2020-03-21","objectID":"/miniprogram01/:2:5","tags":["MiniProgram"],"title":"结合官方文档，入门微信小程序","uri":"/miniprogram01/"},{"categories":["MiniProgram"],"content":"3 一个简单的页面 ","date":"2020-03-21","objectID":"/miniprogram01/:3:0","tags":["MiniProgram"],"title":"结合官方文档，入门微信小程序","uri":"/miniprogram01/"},{"categories":["MiniProgram"],"content":"3.1 目录结构 ├── app.js ├── app.json ├── app.wxss ├── images ├── pages │ └── welcome │ ├── welcome.wxml │ ├── welcome.js │ └── welcome.wxss └── project.config.json ","date":"2020-03-21","objectID":"/miniprogram01/:3:1","tags":["MiniProgram"],"title":"结合官方文档，入门微信小程序","uri":"/miniprogram01/"},{"categories":["MiniProgram"],"content":"3.2 代码展示 app.json { \"pages\": [ \"pages/welcome/welcome\" ], \"window\": { \"navigationBarBackgroundColor\": \"#b3d4db\" }, \"sitemapLocation\": \"sitemap.json\" } app.wxss text{ font-family:MicroSoft Yahei; } welcome.wxml \u003c!-- wxml 是用来编写页面骨架的文件--\u003e \u003c!-- \u003cdiv\u003e 容器 分隔文档 --\u003e \u003cview class=\"container\"\u003e \u003c!-- \u003cimage style=\"width:200rpx; height:200rpx\" src=\"/images/avatar.png\"\u003e\u003c/image\u003e --\u003e \u003cimage class=\"user-avatar\" src=\"/images/avatar.png\"\u003e\u003c/image\u003e \u003c!-- width:300px height:225px --\u003e \u003ctext class=\"user-name\"\u003eHello,World\u003c/text\u003e \u003cview class= \"moto-container\"\u003e \u003ctext class=\"moto\" \u003e开启小程序之旅\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e welcome.js //js不能为空，否则会报错，至少添加空的Page代码 Page({ }) welcome.wxss .container{ display: flex; flex-direction:column; /*垂直分布*/ align-items: center; /*元素居中*/ /*background-color: #b3d4db;*/ } page{ background-color: #b3d4db; height:100%; } .user-avatar{ width:200rpx; height:200rpx; margin-top:160rpx; } .user-name{ font-size:32rpx; font-weight:bold; margin-top:80rpx; /*font-family: MicroSoft Yahei;*/ } .moto{ font-size:22rpx; font-weight:bold; /*font-family: MicroSoft Yahei;*/ line-height: 80rpx; color: #405f80 } .moto-container{ margin-top:200rpx; border:1px solid #405f80; height:80rpx; width:200rpx; border-radius:5px; /*设置圆角*/ text-align:center; } ","date":"2020-03-21","objectID":"/miniprogram01/:3:2","tags":["MiniProgram"],"title":"结合官方文档，入门微信小程序","uri":"/miniprogram01/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 人脸对齐/关键点训练业务理论及实现","date":"2020-03-18","objectID":"/face10/","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 人脸对齐/关键点训练业务理论及实现 ","date":"2020-03-18","objectID":"/face10/:0:0","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"1 人脸对齐/关键点业务介绍 根据输入的人脸图像，自动定位出面部特征关键点，如眼睛、鼻尖、嘴角点、眉毛以及人脸各部件轮廓点等 2D人脸 3D人脸 关键点数量：5,21,29,68,96,192…… 旷视科技1000点与8000点对比如下图 表情识别、人脸编辑、人脸美妆、三维重建 ","date":"2020-03-18","objectID":"/face10/:1:0","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"2 人脸关键点算法评价指标 ","date":"2020-03-18","objectID":"/face10/:2:0","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"2.1 通常将输出结果表示成点的集合，再进一步表示成向量 ","date":"2020-03-18","objectID":"/face10/:2:1","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"2.2 NME：Normalized mean error 两外眼角间距离 人脸外接矩阵对角线长度 $$ e = \\frac{\\textstyle\\sum_{i=1}^n \\Vert X_{(i)}^e-X_{(i)}^e \\Vert_2}{N * d_{io}}$$ ","date":"2020-03-18","objectID":"/face10/:2:2","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"2.3 CED：Cumulative Errors Distribution（CED）curve 横坐标表达当前的偏差值 纵坐标表达满足当前偏差值得图片的数量 ","date":"2020-03-18","objectID":"/face10/:2:3","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"3 人脸关键点方法介绍 ","date":"2020-03-18","objectID":"/face10/:3:0","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"3.1 传统方法 3.1.1 形状学习 基于形状学习的模型：ASM、AAM 基于形状学习的人脸关键点流程 笔记 主要作用：勾勒出人脸基准点的轮廓，轮廓属于特定的形状。 人脸模型：对人脸特征点进行建模，首先选择基准图片，利用基准图片作为参照， 将训练集的图片按照基准进行变换，得到训练集的图像处理后的集合， 对训练集中人脸关键点标定的位置，对每一个点进行特征提取，以当前关键点为中心， 提取它的局部的图像区域进行特征提取，假设特征提取后有5个点，就会得到5个向量。 点搜索：给定一个测试集的图片，进行关键点的搜索， 初步搜索时选择5个点中的某几个点作为最开始搜索的对象，通常选择眼睛或鼻子。 对齐：根据基准点对人脸进行对齐。 其他点的搜索定位：以基准点为参照，预测想要定位的其他的点的大致位置！ 3.1.2 级联回归学习 基于级联回归学习的模型：CPR 笔记 对于人脸特征点定位，人脸关键点检测的目的是估计向量(Facial Shape) $S=(x_1,y_1,x_2,y_2,…,x_K,y_K)$ ， 其中 $K$ 表示关键点的个数，由于每个关键点有横纵两个坐标，所以 $S$ 的长度为 $2K$ 。 对于一个输入 $I$ , 给定一个初始形状 $S^0$ (通常是在训练集计算得到的平均形状)。 每一级输出的是根据输入图像得到的偏移估计$\\Delta S$，那么每一级都会更准确的预测 脸上Landmark的位置 $$S^{t+1 }= S^t+r_t(\\phi(I,S^t))$$ 其中，$S^t$ 和 $S^{t+1}$ 分别表示第 $t$ 和 $t+1$ 级预测的人脸形状(即所有关键点集合)，表示回归函数 CPR通过一系列回归器将一个指定的初始预测值逐步细化， 每一个回归器都依靠前一个回归器的输出来执行简单的图像操作， 整个系统可自动的从训练样本中学习。 CPR检测流程一共有T个阶段，在每个阶段中首先进行特征提取f， 这里使用的是shape-indexed features， 也可以使用诸如HOG、SIFT等人工设计的特征， 或者其他可学习特征（learning based features）， 然后通过训练得到的回归器R来估计增量ΔS( update vector)， 把ΔS加到前一个阶段的S上得到新的S，这样通过不断的迭代即可以得到最终的S(shape)。 推荐阅读文献 Face Alignment at 3000 FPS via Regressing Local Binary Features(LBF) Joint Cascade Face Detection and Alignment One Millisecond Face Alignment with an Ensemble of Regresion Trees(ETR) Face Alignment In-the-Wild: A Survey Facial feature point detection: A comprehensive survey ","date":"2020-03-18","objectID":"/face10/:3:1","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"3.2 深度学习方法 3.2.1 多级回归 DCNN 总体思想是由粗到细，实现5个人脸关键点的精确定位。网络结构分为3层：level 1、level 2、level 3。每层都包含多个独立的CNN模型，负责预测部分或全部关键点位置，在此基础上平均来得到该层最终的预测结果。 DCNN-Face++ 3.2.2 多任务 TCDCN 使用与人脸相关的属性共同来学习人脸的特征点位置，通过这种多任务的学习，来提高人脸特征点检测的鲁棒性。具体而言，就是在人脸特征点检测时候，同时进行多个任务（包括性别、是否戴眼镜、是否微笑以及脸部姿势）的学习。使用这些辅助属性可以帮助更好的定位特征点。 MTCNN CNN回归和检测多任务，多尺度级联，三个网络级联，由粗到精，同时完成检测和特征点定位回归。 3.2.3 直接回归 Vanilla CNN 作者对网络不同层的特征进行使用GMM进行聚类分析，发现网络进行的是层次的，由粗到精(hierarchical, coarse to fine)的特征定位，越深的网络特征越能反应出特征点的位置。 3.2.4 热图 DAN 与以往级联神经网络输入的是图像的某一部分不同，DAN各阶段网络的输入均为整张图片。当网络均采用整张图片作为输入时，DAN可以有效的克服头部姿态以及初始化带来的问题，从而得到更好的检测效果。之所以DAN能将整张图片作为输入，是因为其加入了关键点热图（Landmark Heatmaps），关键点热图的使用是本文的重要创新点。 3.2.5 3D人脸关键点定位 2D人脸主要为可见点信息，对于侧脸很难训练 正脸到侧脸姿态变化较大，且标注十分困难 人脸本身就具有深度信息 Dense Face Alignment DenseReg FAN 3DDFA PRNet ","date":"2020-03-18","objectID":"/face10/:3:2","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"4 人脸关键点常用数据集 数据集 个数 BiolD 20 LFPW 29 AFLW 21 COFW 29 ICCV13/MVFW 68 OCFW 68 300-W 68 HELEN 29 CelebA 5 300W-LP 68点 AFW,LFPW,HELEN,IBUG and XM2VTS Dlib库 能够检测出当前图片中的人脸的位置，并且完成人脸定位（68点），生成深度学习输入的训练样本。 ","date":"2020-03-18","objectID":"/face10/:4:0","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"5 人脸关键点定位问题挑战及解决思路 问题 解决思路 环境的变化 数据增强 姿态的变化 姿态分类、人脸对齐（矫正） 表情的变化 数据增强，GAN 遮挡问题 3D人脸关键点定位、优化主干网络 稠密点 3D人脸关键点定位、优化主干网络 ","date":"2020-03-18","objectID":"/face10/:5:0","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"6 编程实战及模型优化 TensorFlow+SENet-人脸关键点定位编程实战及模型优化 ","date":"2020-03-18","objectID":"/face10/:6:0","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"6.1 TensorFlow+SENet模型详细介绍 人脸关键点网络结构 笔记 数据：训练样本 网络结构：SENet 输出：预测人脸中的68个关键点，表示为68*2=136维的向量 回归网络 网络结构 SENet模型详细介绍 笔记 SE-Inception Module 是将SE模块嵌入到Inception结构的一个示例。方框旁边的维度信息代表该层的输出。 这里我们使用global average pooling作为Squeeze操作。紧接着两个Fully Connected 层组成一个Bottleneck结构去建模通道间的相关性，并输出和输入特征同样数目的权重。 我们首先将特征维度降低到输入的1/16，然后经过ReLu激活后再通过一个Fully Connected 层升回到原来的维度。这样做比直接用一个Fully Connected层的好处在于： 具有更多的非线性，可以更好地拟合通道间复杂的相关性； 极大地减少了参数量和计算量。然后通过一个Sigmoid的门获得0~1之间归一化的权重，最后通过一个Scale的操作来将归一化后的权重加权到每个通道的特征上。 SE-ResNet Module 操作过程基本和SE-Inception一样，只不过是在Addition前对分支上 Residual的特征进行了特征重标定。如果对Addition后主支上的特征进行重标定， 由于在主干上存在0~1的scale操作，在网络较深BP优化时就会在靠近输入层容易 出现梯度消散的情况，导致模型难以优化。 X1 = conv(X0) X2 = weight(X0) X3 = X0 + X1 ** X2 ","date":"2020-03-18","objectID":"/face10/:6:1","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"6.2 环境参数 环境参数 Tensorflow1.12 Ubuntu16.04 Python3.5 ","date":"2020-03-18","objectID":"/face10/:6:2","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"6.3 数据准备 数据准备 300W-LP ","date":"2020-03-18","objectID":"/face10/:6:3","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"7 实例代码 ","date":"2020-03-18","objectID":"/face10/:7:0","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"7.1 数据集处理 对landmark中的标注信息进行适当的调整，代码如下： x_max = int(np.max(landmark[0:68, 0])) x_min = int(np.min(landmark[0:68, 0])) y_max = int(np.max(landmark[0:68, 1])) y_min = int(np.min(landmark[0:68, 1])) y_min = int(y_min - (y_max - y_min) * 0.3) y_max = int(y_max + (y_max - y_min) * 0.05) x_min = int(x_min - (x_max - x_min) * 0.05) x_max = int(x_max + (x_max - x_min) * 0.05) 对数据进行裁剪，将人脸区域抠出来，获取人脸框的大小并对landmark数据进行标准化，将其归一化到0~1之间，对x,y的处理如下： im_point.append((landmark[p][0] - x_min) * 1.0 / sp[1]) im_point.append((landmark[p][1] - y_min) * 1.0 / sp[0]) 将图片的大小改变为128*128的大小，将整个数据集中80%的数据划分为训练集，剩余的20%划分为测试集。 ","date":"2020-03-18","objectID":"/face10/:7:1","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"7.2 模型训练 数据读取：定义get_one_batch函数，每次从中获取一个batchsize的数据，定义type=0时为训练集，读取train.tfrecords文件，type=1时为测试集，读取test.tfrecords。定义和读取文件队列，对训练集使用shuffle_batch获取队列中的数据，对测试集直接使用batch获取队列中的数据。定义features对读取出的数据进行解析，获取features中的image和label，接着将图像数据解码为uint8格式，对图像数据进行reshape并将其转换为float型。 定义网络结构：定义输入为placeholder，数据类型为float32，shape中batch_size定义为None，图像尺寸为128 * 128 * 3；模型共需要预测68个人脸关键点共136个点，将label的shape定义为136，具体代码如下： input_x = tf.placeholder(tf.float32, shape=[None, 128, 128, 3]) label = tf.placeholder(tf.float32, shape=[None, 136]) logits = SENet(input_x, is_training=True, keep_prob=0.8) SENet:定义senet_blob(net, in_dim, on_dim, stride)函数，其中in_dim为输入特征图通道数，on_dim为输出特征图通道数，stride表示当前网络是否进行下采样。对输入的张量进行备份，并进行卷积操作，对通道的数量进行适当的降维，第一次，降4倍，进行1 * 1的卷积，接着进行3 * 3的卷积，接着再进行1 * 1的卷积，得到与输出维度相同的卷积，对stride大于1的数据通道poll2d进行下采样。通过reduce_mean对1、2维度进行average_pooling，调用slim.fully_connected加入全连接层，加入激活层，再次加入全连接层，使用sigomid将权重映射到0,1之间，得到通道加权之后的网络结构，将得到的值与备份的张量相加，实现跳连部分。 定义好基本模块之后，开始搭建SENet网络结构，定义权重可选的正则化程序为slim.l2_regularizer(0.00001)、定义权重初始化程序为slim.variance_scaling_initializer()、定义激活函数为tf.nn.relu、定义正则化函数为slim.batch_norm、定义正则化函数的参数为bn_param。网络结构定义代码如下： with slim.arg_scope([slim.batch_norm], **bn_param): net = slim.conv2d(input_x, 32, [3, 3]) net = slim.avg_pool2d(net, [3, 3], stride=2, padding=\"SAME\") net = senet_blob(net, 32, 64, 2) net = senet_blob(net, 64, 128, 2) net = senet_blob(net, 128, 128, 2) net = senet_blob(net, 128, 256, 2) net = senet_blob(net, 256, 512, 2) net = tf.reduce_mean(net, axis=[1, 2])) net = slim.fully_connected(net, 1024) net = tf.nn.dropout(net, keep_prob=keep_prob) net = tf.nn.relu(net) net = slim.fully_connected(net, 136) return net 网络维度的变化如下图所示： 学习率：学习率采用衰减学习率，初始学习率为0.001，衰减步长为1000步，每次衰减0.98，定义update_ops对batchnorm层进行更新，具体代码如下： global_step = tf.Variable(0, trainable=False) lr = tf.train.exponential_decay(0.001, global_step, decay_steps=1000, decay_rate=0.98, staircase=False) update_ops = tf.get_collection(tf.GraphKeys.UPDATE_OPS) with tf.control_dependencies(update_ops): train_op = tf.train.AdamOptimizer(lr).minimize(loss, global_step) 模型共训练150000次，并对模型和日志信息进行保存，loss曲线如下图所示： ","date":"2020-03-18","objectID":"/face10/:7:2","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"7.3 模型固化 模型固化部分的网络结构与模型训练中的基本一致，需要将is_training修改为False、keep_prob修改为1.0,将shape中的None置为1表示每次处理一张图片，修改前后的代码如下： #修改前：input_x = tf.placeholder(tf.float32, shape=[None, 128, 128, 3]) input_x = tf.placeholder(tf.float32, shape=[1, 128, 128, 3]) #修改前：logits = SENet(input_x, is_training=True, keep_prob=0.8) logits = SENet(input_x, is_training=False, keep_prob=1.0) 根据读取到的ckpt文件恢复当前的graph，定义输出的网络节点的对应部分，并保存pb文件，相关代码如下： coord = tf.train.Coordinator() tf.train.start_queue_runners(sess=session, coord=coord) init_op = tf.group(tf.global_variables_initializer(), tf.local_variables_initializer()) session.run(init_op) ckpt = tf.train.get_checkpoint_state(\"models-3\") saver.restore(session, ckpt.model_checkpoint_path) print(ckpt.model_checkpoint_path) output_graph_def = tf.graph_util.convert_variables_to_constants(session,session.graph.as_graph_def(),['fully_connected_9/Relu']) with tf.gfile.FastGFile(\"face_landmark_model.pb\", \"wb\") as f: f.write(output_graph_def.SerializeToString()) f.close() ","date":"2020-03-18","objectID":"/face10/:7:3","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"7.4 模型测试 读取打包好的pb文件，从pb文件中恢复当前的graph， 接着进行前项推理，通过opencv读取用于测试的人脸图片，将图片resize到128 * 128，将读取到的图片扩充为四维后传给网络，使用opencv对68个人脸关键点进行绘制，并显示输出结果，相关代码如下： for im_url in im_list: im_data = cv2.imread(im_url) sp = im_data.shape im_data = im_data[sp[0] * 1//4:,:,:] im_data = cv2.resize(im_data, (128, 128)) pred = sess.run(landmark, {\"Placeholder:0\": np.expand_dims(im_data, 0)}) pred = pred[0] for i in range(0, 136, 2): cv2.circle(im_data, (int(pred[i] * 128), int(pred[i+1] * 128)), 2, (0, 255, 0), 2) cv2.imshow(\"test\", im_data) cv2.waitKey(0) 人脸关键点定位的模型测试结果如下图所示： ","date":"2020-03-18","objectID":"/face10/:7:4","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["FaceRecognition"],"content":"8 参考资料 参考资料 人脸关键点对齐 人脸对齐（十）–人脸对齐综述 人脸特征点检测（四）——Tasks-Constrained DCN（TCDCN） 人脸关键点检测9——DAN SE-Inception v3架构的模型搭建（keras代码实现） 对SE_ResNet的理解 ","date":"2020-03-18","objectID":"/face10/:8:0","tags":["FaceRecognition","TensorFlow","SENet","FaceAlignment"],"title":"人脸对齐/关键点训练业务理论及实现","uri":"/face10/"},{"categories":["BugFixes"],"content":"解决AttributeError: module 'scipy.misc' has no attribute 'imread'的报错","date":"2020-03-15","objectID":"/bug02/","tags":["BugFixes","人脸匹配","scipy"],"title":"解决AttributeError: module 'scipy.misc' ···  'imread'的报错","uri":"/bug02/"},{"categories":["BugFixes"],"content":"解决AttributeError: module ‘scipy.misc’ has no attribute ‘imread’的报错 ","date":"2020-03-15","objectID":"/bug02/:0:0","tags":["BugFixes","人脸匹配","scipy"],"title":"解决AttributeError: module 'scipy.misc' ···  'imread'的报错","uri":"/bug02/"},{"categories":["BugFixes"],"content":"系统配置 系统配置 ubuntu 16.04 python 3.5 tensorflow 1.12.0 ","date":"2020-03-15","objectID":"/bug02/:0:1","tags":["BugFixes","人脸匹配","scipy"],"title":"解决AttributeError: module 'scipy.misc' ···  'imread'的报错","uri":"/bug02/"},{"categories":["BugFixes"],"content":"报错信息 报错信息 module ‘scipy_misc’ has no attribute ‘imread’ ","date":"2020-03-15","objectID":"/bug02/:0:2","tags":["BugFixes","人脸匹配","scipy"],"title":"解决AttributeError: module 'scipy.misc' ···  'imread'的报错","uri":"/bug02/"},{"categories":["BugFixes"],"content":"问题分析 问题分析 python3 src\\align\\align_dataset_mtcnn.py /root/py3_tensorflow/dataset/LFW /root/py3_tensorflow/dataset/LFW-160 --margin 32 --random_order --gpu_memory_fraction 0.25 在解析LFW数据集时报错，应该是在安装FaceNet的依赖的时候没有在requirements.txt中限定版本，默认安装了高版本的scipy imread is deprecated! imread is deprecated in SciPy 1.0.0, and will be removed in 1.2.0. Use imageio.imread instead. ","date":"2020-03-15","objectID":"/bug02/:0:3","tags":["BugFixes","人脸匹配","scipy"],"title":"解决AttributeError: module 'scipy.misc' ···  'imread'的报错","uri":"/bug02/"},{"categories":["BugFixes"],"content":"修复方法 修复方法 降低scipy的版本为1.2.1 sudo pip3 uninstall scipy sudo pip3 install scipy==1.2.1 ","date":"2020-03-15","objectID":"/bug02/:0:4","tags":["BugFixes","人脸匹配","scipy"],"title":"解决AttributeError: module 'scipy.misc' ···  'imread'的报错","uri":"/bug02/"},{"categories":["BugFixes"],"content":"解决ValueError: Object arrays cannot be loaded when allow_pickle=False的报错","date":"2020-03-15","objectID":"/bug01/","tags":["BugFixes","人脸匹配","numpy"],"title":"解决ValueError: Object arrays ··· allow_pickle=False的报错","uri":"/bug01/"},{"categories":["BugFixes"],"content":"解决ValueError: Object arrays cannot be loaded when allow_pickle=False的报错 ","date":"2020-03-15","objectID":"/bug01/:0:0","tags":["BugFixes","人脸匹配","numpy"],"title":"解决ValueError: Object arrays ··· allow_pickle=False的报错","uri":"/bug01/"},{"categories":["BugFixes"],"content":"系统配置 系统配置 ubuntu 16.04 python 3.5 tensorflow 1.12.0 ","date":"2020-03-15","objectID":"/bug01/:0:1","tags":["BugFixes","人脸匹配","numpy"],"title":"解决ValueError: Object arrays ··· allow_pickle=False的报错","uri":"/bug01/"},{"categories":["BugFixes"],"content":"报错信息 报错信息 ValueError: Object arrays cannot be loaded when allow_pickle=False ","date":"2020-03-15","objectID":"/bug01/:0:2","tags":["BugFixes","人脸匹配","numpy"],"title":"解决ValueError: Object arrays ··· allow_pickle=False的报错","uri":"/bug01/"},{"categories":["BugFixes"],"content":"问题分析 问题分析 python3 src\\align\\align_dataset_mtcnn.py /root/py3_tensorflow/dataset/LFW /root/py3_tensorflow/dataset/LFW-160 --margin 32 --random_order --gpu_memory_fraction 0.25 numpy版本过高 ","date":"2020-03-15","objectID":"/bug01/:0:3","tags":["BugFixes","人脸匹配","numpy"],"title":"解决ValueError: Object arrays ··· allow_pickle=False的报错","uri":"/bug01/"},{"categories":["BugFixes"],"content":"修复方法 修复方法 降低numpy版本为1.16.2 sudo pip3 uninstall numpy sudo pip3 install numpy==1.16.2 ","date":"2020-03-15","objectID":"/bug01/:0:4","tags":["BugFixes","人脸匹配","numpy"],"title":"解决ValueError: Object arrays ··· allow_pickle=False的报错","uri":"/bug01/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 人脸匹配业务理论及实现","date":"2020-03-14","objectID":"/face09/","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 人脸匹配业务理论及实现 ","date":"2020-03-14","objectID":"/face09/:0:0","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"1 人脸匹配业务介绍 1:1 验证， verification 1:N 识别， identification ","date":"2020-03-14","objectID":"/face09/:1:0","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"2 人脸匹配算法性能评价指标 人脸验证：ROC曲线、PR曲线 人脸识别：CMC曲线 ","date":"2020-03-14","objectID":"/face09/:2:0","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"2.1 CMC曲线 累积匹配曲线 Top1 error 预测出来最大概率的那个分类是正确的概率。 Top5 error 预测出来最大概率的5个分类里有正确的概率。 ","date":"2020-03-14","objectID":"/face09/:2:1","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"3 人脸匹配方法介绍 ","date":"2020-03-14","objectID":"/face09/:3:0","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"3.1 人脸特征表示问题 颜色：一般输出一个向量，通常为一个直方图 纹理：对颜色矩阵差分可以得到纹理特征 形状：对图像中的结构信息进行分解 学习：对以上三种人为设计的基本信息进行学习，加入监督信息、类别信息等，更加鲁棒 笔记 如何进行特征表示的优化学习？ PCA（无监督） 对高维的稠密的可以通过PCA进行特征降维，提取主成分 LDA（有监督） 优化特征空间 迁移学习 对于空间上存在不同分布的两种样本，指向同一个投影（Common Subspace） 稀疏表示（Deep Learning之前的一代技术） 多用于信号分解、图像降噪等领域，用较少的基本信号的线性组合来表达大部分或者全部的原始信号 低秩学习（low-rank） 图像数据具有局部相似性，可能存在“一一表示”，从而矩阵就可能不是满秩 哈希学习 哈希函数可以是基于线性的、核函数、球面函数、深度神经网络、无参函数 通过机器学习机制将数据映射成简洁的二进制串的形式, 同时使得哈希码尽可能地保持原空间中的近邻关系, 即保相似性 ","date":"2020-03-14","objectID":"/face09/:3:1","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"3.2 人脸特征度量问题 3.2.1 什么是度量问题？ A和B同类，A和C不同类 A和B的相似性大于A和C的相似性 3.2.2 欧氏距离（Euclidean Distance） 欧氏距离是最常见的距离度量，衡量的是多维空间中各个点之间的绝对距离。 如点$x=(x_1,…,x_n)$和$y=(y_1,…,y_n)$之间的距离为： $$ d(x,y)=\\sqrt{\\displaystyle\\sum_{i=1}^n(x_i - y_i)^2} $$ 3.2.3 马氏距离（Mahalanobis Distance） 是由马哈拉诺比斯（P. C. Mahalanobis）提出的，表示数据的协方差距离。 它是一种有效的计算两个未知样本集的相似度的方法。 与欧氏距离不同的是它考虑到各种特性之间的联系, 并且是尺度无关的（scale-invariant），即独立于测量尺度。 对于一个均值为$μ=(μ_1,μ_2,μ_3,…,μ_p)^T$协方差矩阵为$S$的多变量$x=(x_1,x_2,x_3,…,x_p)^T$其马氏距离为： $$D_M(x)=\\sqrt{(x−μ)^TS^{-1}(x−μ)}$$ 3.2.4 度量优化问题 对解空间加不同的约束，在很大的假设空间中找出合适的解，缩小解空间。 ","date":"2020-03-14","objectID":"/face09/:3:2","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"3.3 人脸匹配的深度学习方法 笔记 分类问题的网络是单支的 进行人脸特征匹配时，用欧氏距离和余弦距离来测量当前提取出来的特征向量，特征向量利用网络进行学习 样本量非常丰富，单类样本样本数量非常多时，通常采用分类网络 相似性的网络是多分支的 通过多分支网络对输入的样本进行改造，根据样本id设计不同的Loss 2分支采用 Contrastive Loss 3分支采用 Triplet Loss 利用两种不同的Loss提取出特征，提取的特征具有鉴别信息（同类之间相似性很小，不同类之间相似性很大） 通常采用欧氏距离进行Loss的计算 多分支网络在进行特征表示时，会进行不同分支间参数共享，网络收敛后，去除其中一只来提取特征，以此提取出特征向量 样本量比较少，单类样本数量也比较少时，通常采用多分支网络结构 重排序（ReRank） 利用深度学习网络提取完特征，并对特征进行了相似性度量和排序后，根据排序结果再次重新排序 ","date":"2020-03-14","objectID":"/face09/:4:0","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"4 FaceNet编程实战及模型优化 ","date":"2020-03-14","objectID":"/face09/:5:0","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"4.1 FaceNet模型详细介绍 4.1.1 Learn to rank 笔记 Anchor和Positive为同类样本 经过学习之后，同类样本之间的相似度更高（距离更小） 4.1.2 网络结构 笔记 FaceNet也可称为Triplet Net的一个网络结构 Batch由多个三元组构成，包含样本对(Anchor,Positive,Negative) DEEP ARCHITECTURE 深度网络主干网络（标准卷积神经网），对输入的图像进行特征提取，将图片转化成向量 对提取出来的向量通过L2进行归一化 得到归一化后的EMBEDDING（最终的特征向量） EMBEDDING作为 Triplet Loss 的输入，输入同样为三元组(Anchor的特征向量,Positive的特征向量,Negative的特征向量) 4.1.3 Loss设计 $$\\displaystyle\\sum_{i=1}^N[\\text{\\textbardbl}f(x{_i^a})-f(x{_i^p})\\text{\\textbardbl}{_2^2} -\\text{\\textbardbl}f(x{_i^a})-f(x{_i^n})\\text{\\textbardbl}{2^2}+\\alpha]+$$ 笔记 N个三元组 (Anchor-Positive)-(Anchor-Negative) 得到同类和不同类之间的样本距离差 α为间隔，通过α可以调节同类样本和不同类样本之间的距离满足多大的距离差才能算作一个样本 通过Loss的设计学出来的特征可以用来度量样本的相似度 计算向量相似度时采用的是二范式，即欧氏距离 利用FaceNet进行特征向量提取，计算样本相似度时只采用欧氏距离即可 4.1.4 难例挖掘 OHEM 笔记 难例挖掘是指,针对模型训练过程中导致损失值很大的一些样本(即使模型很大概率分类错误的样本),重新训练它们. 维护一个错误分类样本池, 把每个batch训练数据中的出错率很大的样本放入该样本池中,当积累到一个batch以后,将这些样本放回网络重新训练. 在进行Loss计算时，主要考虑难例，对简单样本不计算Loss 4.1.5 数据增强 颜色信息、几何变换、GAN、多样本数据增强 笔记 数据增强也叫数据扩增，意思是在不实质性的增加数据的情况下，让有限的数据产生等价于更多数据的价值。 颜色信息常包括：噪声、模糊、颜色变换、擦除、填充等。 几何变换常包括：翻转，旋转，裁剪，变形，缩放等。 GAN包含两个网络，一个是生成网络，一个是对抗网络，基本原理如下： G是一个生成图片的网络，它接收随机的噪声z，通过噪声生成图片，记做G(z) 。 D是一个判别网络，判别一张图片是不是“真实的”，即是真实的图片，还是由G生成的图片。 多样本数据增强不同于单样本数据增强，多样本数据增强方法利用多个样本来产生新的样本。 ","date":"2020-03-14","objectID":"/face09/:5:1","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"4.2 FaceNet环境搭建 笔记 源码地址： https://github.com/davidsandberg/facenet TensorFlow1.12、Ubuntu16.04、Python3.5 https://github.com/VisualComputingInstitute/triplet-reid #下载FaceNet git clone https://github.com/davidsandberg/facenet # 进入facenet目录下 cd facenet #修改 requirements.txt 将tensorflow==1.7注释掉，保存 gedit requirements.txt # 下载需要的依赖库 sudo pip3 install -r requirements.txt #安装完成 ","date":"2020-03-14","objectID":"/face09/:5:2","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"4.3 人脸匹配数据准备 4.3.1 常见数据集 LFW LFW人脸数据库主要用来研究非受限情况下的人脸识别问题,主要测试人脸识别的准确率。 Celeba CelebA由香港中文大学开放提供，广泛用于人脸相关的计算机视觉训练任务，可用于人脸属性标识训练、人脸检测训练以及landmark标记等。 VGGface2 VGGFace2 是一个大规模人脸识别数据，包含331万图片，9131个ID，平均图片个数为362.6。 CASIA-WebFace CASIA-WebFace数据集包含了10575 个人的494414 张图像。CASIA-webface数据库，压缩包有4个多g，里面包含了10000个人，一共50万张人脸图片，无论是做SVM，DNN还是别的训练，都是非常好的数据库。 CASIA-faceV5 亚洲人脸数据库 4.3.2 数据格式 文件夹名/文件夹名_文件名 同一个人的图片放在相同文件夹 4.3.3 人脸匹配数据准备 1.方法一 #下载FaceNet源码 git clone https://github.com/davidsandberg/facenet # 进入facenet目录下 cd facenet #安装所需依赖库 sudo pip3 install -r requirements.txt #添加环境变量 export PYTHONPATH=$(pwd)/src #人脸对齐脚本 -\u003e 将图片裁剪成160*160的人脸图片 python3 src/align/align_dataset_mtcnn.py lfw lfw_160--image_size 160 --margin 32 --random_order -- gpu_memory_fraction 0.25 2.方法二 dlib库用来进行人脸检测+关键点定位 根据关键点或者人脸检测结果，提取人脸图像 3.通过mtcnn完成人脸匹配数据准备 ","date":"2020-03-14","objectID":"/face09/:5:3","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"5 实例代码 ","date":"2020-03-14","objectID":"/face09/:6:0","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"5.1 数据集处理 在使用FaceNet框架进行人脸匹配模型训练时，需要将数据转换为FaceNet要求的数据格式，同一个人的不同图片存放在同一个文件夹下，数据格式为：“文件夹名/文件夹名_文件名”。在FaceNet中不需要额外的将数据打包为tfrecord格式，如果与要求的格式一致，FaceNet框架会自动解析数据。 LFW数据集的处理：在使用FaceNet框架时需要将图片裁剪到160*160，系统使用FaceNet自带的align_dataset_mtcnn.py脚本对LFW数据集中的人脸图片进行处理。命令和参数的配置如下： python3 src/align/align_dataset_mtcnn.py /mnt/dataset/LFW /mnt/dataset/LFW-160 --image_size 160 --margin 32 --random_order --gpu_memory_fraction 0.25 CASIA-FaceV5亚洲人脸数据集的处理：使用dlib库创建人脸检测器，利用人脸检测器对数据集中的图片依次进行检测，将未检测出人脸的图片过滤掉，成功检测出人脸的图片先获取到检测出的人脸位置，对检测出的人脸框进行扩充，这样做可以保证获取到的人脸是一张完整的人脸，根据扩充后的坐标将图片裁剪为160 * 160大小，裁剪后的图片根据不同的人存储到相对应的文件夹下，主要代码如下： for idx_folder in im_folder_list: im_items_list = glob.glob(idx_folder + \"/*\") if not os.path.exists(\"{}/{}\".format(crop_im_path, idx)): os.mkdir(\"{}/{}\".format(crop_im_path, idx)) idx_im = 0 for im_path in im_items_list: im_data = cv2.imread(im_path) dets = detector(im_data, 1) if dets.__len__() == 0: continue d = dets[0] # 获取人脸坐标 x1 = d.left() y1 = d.top() x2 = d.right() y2 = d.bottom() # 对识别出的人脸进行扩充 y1 = int(y1 - (y2 - y1) * 0.3) x1 = int(x1 - (x2 - x1) * 0.05) x2 = int(x2 + (x2 - x1) * 0.05) y2 = y2 im_crop_data = im_data[y1:y2,x1:x2] im_data = cv2.resize(im_crop_data, (160, 160)) im_save_path = \"{}/{}/{}_{}.jpg\".format(crop_im_path, idx, idx, \"%04d\" % idx_im) cv2.imwrite(im_save_path, im_data) idx_im += 1 idx += 1 ","date":"2020-03-14","objectID":"/face09/:6:1","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"5.2 模型训练 人脸匹配模型训练采用FaceNet提供的train_tripletloss.py脚本，在使用tripletloss训练时，需要修改数据的存放路径，其余参数采用默认参数，相关代码如下： parser.add_argument('--data_dir', type=str, help='Path to the data directory containing aligned face patches.', default='/mnt/dataset/64_CASIA-FaceV5/crop_image_160' '') 模型训练中loss曲线如下图所示: ","date":"2020-03-14","objectID":"/face09/:6:2","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"5.3 模型固化 FaceNet提供了freeze_graph.py脚本，来进行模型固化。脚本运行需要两个参数，model_dir是训练好的模型的路径，output_file是固化好的pb文件的输出路径。 ","date":"2020-03-14","objectID":"/face09/:6:3","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"5.4 模型测试 使用FaceNet中提供得validate_on_lfw.py脚本，利用经过处理的LFW数据集对训练好的模型进行测试。该脚本使用auc实现对算法性能的评价。在使用该脚本时，需要传入两个参数，一个是处理好的LFW数据集的路径，一个是训练好的模型的路径。 测试得到的数据如下图所示： ","date":"2020-03-14","objectID":"/face09/:6:4","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["FaceRecognition"],"content":"6 参考资料 参考资料 《机器学习》第10章 降维与度量分析 【技术综述】深度学习中的数据增强方法都有哪些？ face recognition[翻译][深度人脸识别:综述] NanoNets :数据有限时如何应用深度学习？ 数据增强：数据有限时如何使用深度学习 ？ LFW人脸数据库的简介 CelebA数据集详细介绍及其属性提取源代码 性别年龄论文阅读（3）——VGGFace2 Dataset之CASIA-WebFace ","date":"2020-03-14","objectID":"/face09/:7:0","tags":["FaceRecognition","TensorFlow"],"title":"人脸匹配业务理论及实现","uri":"/face09/"},{"categories":["Flask"],"content":"结合官方文档 入门Flask","date":"2020-03-13","objectID":"/flask01/","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"结合Flask官方中文文档，学习Flask基础入门知识 ","date":"2020-03-13","objectID":"/flask01/:0:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"1 Flask介绍 ","date":"2020-03-13","objectID":"/flask01/:1:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"1.1 简介 Flask是一个基于Python实现的Web开发‘微’框架 官方文档：http://flask.pocoo.org/docs/0.12/ 中文文档：http://docs.jinkan.org/docs/flask/ Flask和Django一样，也是一个基于MVC设计模式的Web框架 Flask依赖三个库 Jinja2 模板引擎 Werkzeug WSGI工具集 Itsdangerous基于Django的签名模块 ","date":"2020-03-13","objectID":"/flask01/:1:1","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"1.2 流行原因 有非常齐全的官方文档，上手非常简单 有非常好的扩展机制和第三方扩展环境，工作中常见的软件都会有对应的扩展。自己动手实现扩展也很容易 社区活跃度非常高 微信框架的形式给开发者带来更大的选择空间 ","date":"2020-03-13","objectID":"/flask01/:1:2","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"1.3 MVC(Model, View, Controller)设计模式 一种软件设计典范，用一种业务逻辑，使数据，界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面与用户交互的同时，不需要重新编写业务逻辑。 MVC被独特的发展起来用于映射传统的输入，处理和输出功能在一个逻辑的图形化界面结构中。 核心思想：解耦 优点：降低各模块之间的耦合性，方便变更，更容易重构代码，最大程度实现了代码的重用。 Model:用于封装与应用程序的业务逻辑相关的数据及对数据的处理方法，是Web应用程序中用于处理应用程序的数据逻辑部分，Model通常只提供功能性的接口，通过这些接口可以获取Model的所有功能。 View:负责数据的显示和呈现，View是对用户 的直接输出。 Controller:负贵从用户端收集用户的输入，可以看成提供View的反向功能，主要处理用户交互。 ","date":"2020-03-13","objectID":"/flask01/:1:3","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"2 安装（Linux） ","date":"2020-03-13","objectID":"/flask01/:2:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"2.1 创建一个虚拟环境 创建一个项目文件夹，然后创建一个虚拟环境。创建完成项目文件夹中会有一个venv文件夹： mkdir myproject cd myproject python3 -m venv venv ","date":"2020-03-13","objectID":"/flask01/:2:1","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"2.2 激活虚拟环境 在开始工作前，先要激活响应的虚拟环境： .venv/bin/activate ","date":"2020-03-13","objectID":"/flask01/:2:2","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"2.3 安装Flask 在已激活的虚拟环境中可以使用如下命令安装Flask： pip3 install Flask ","date":"2020-03-13","objectID":"/flask01/:2:3","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"2.4 安装virtualenv 在Linux下，virtualenv 通过操作系统的包管理安装： # Debian,Ubuntu sudo apt-get install python-virtualenv ","date":"2020-03-13","objectID":"/flask01/:2:4","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"3 Hello World from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello,World!' if __name__ == '__main__': app.run() 笔记 首先导入了Flask类。 该类的实例将会成为WSGI应用。 接着创建一个该类的实例。第一个参数是应用模块或者包的名称。如果使用一个单一模块(就像本例), 那么应当使用 name ，因为名称会根据这个模块是按应用方式使用还是作为一个模块导入而发生变化(可能 是 ‘main’ ，也可能是实际导入的名称)。这个参数是必需的，这样 Flask 才能知道在哪里可以找到模板和 静态文件等东西。 然后使用 route() 装饰器来告诉 Flask 触发函数的 URL 。 函数名称被用于生成相关联的URL。函数最后返回需要在用户浏览器中显示的信息。 把它保存为 hello. py 或其他类似名称。不要使用flask.py作为应用名称，这会与 Flask 本身发生冲突。 ","date":"2020-03-13","objectID":"/flask01/:3:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"4 参数配置 ","date":"2020-03-13","objectID":"/flask01/:4:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"4.1 利用app.run（）配置 在启动的时候还可以添加参数，在 run() 中 debug 是否开启调试模式，开启后修改过python代码会自动重启 threaded 是否开启多线程 port 启动指定服务器的端口号 host 主机，默认是127.0.0.1，指定为0.0.0.0代表本机所有ip if __name__ == '__main__': app.run(debug=True,port=8000,host='0.0.0.0') ","date":"2020-03-13","objectID":"/flask01/:4:1","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"4.2 使用config.py配置文件 新建config.py # 以DEBUG为例 DEBUG = True 载入配置文件 app.config.from_object('config') 配置文件读取 app.run(host='0.0.0.0', debug=app.config['DEBUG'], port=90) 重要 app.config.from_object('config') 载入配置文件，使用时DEBUG必须大写 config 配置文件中的参数必须全部大写 DEBUG 的值默认值为 False ","date":"2020-03-13","objectID":"/flask01/:4:2","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"4.3 使用flask-script插件配置 4.3.1 安装使用 安装 pip3 install flask-script 使用app构建manager对象 manager = Manager(app=app) 使用manager启动程序 manager.run() 4.3.2 参数使用 -d #是否开启调试模式 -r #是否自动重新加载文件 -h, -host #指定主机 -p, -port #指定端口 -threaded #是否使用多线程 -?, -help #查看帮助 #示例： python3 manage.py runserver --help ","date":"2020-03-13","objectID":"/flask01/:4:3","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"5 请求流程 ","date":"2020-03-13","objectID":"/flask01/:5:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"6 路由 路由：将从客户端发送过来的请求分发到指定函数上 @app.route('/') def index(): return 'Index Page' @app.route('/hello') def hello(): return 'Hello,World' ","date":"2020-03-13","objectID":"/flask01/:6:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"6.1 变量规则 @app.route('/user/\u003cusername\u003e') def show_user_profile(username): # show the user profile for that user return 'User %s' % escape(username) @app.route('/post/\u003cint:post_id\u003e') def show_post(post_id): # show the post with the given id, the id is an integer return 'Post %d' % post_id @app.route('/path/\u003cpath:subpath\u003e') def show_subpath(subpath): # show the subpath after /path/ return 'Subpath %s' % escape(subpath) 笔记 参数 路径参数 位置参数 关键字参数 请求参数 get 参数在路径中？之后 post参数在请求体中 Flask中参数 都是关键字参数 默认标识是\u003c\u003e name需要和对应的视图函数的参数名字保持一致 参数允许有默认值 如果有默认值，那么在路由中，不传输参数也可以 如果没有默认值，参数在路由中必须传递 默认参数类型是字符串,写法 \u003cconverter:variable_name\u003e converter类型 string 默认值，会将/认为是参数分割符 int 接收整型 float 接收浮点型 path 接收到的数据格式是字符串，会将斜线/认为是一个字符 uuid 只接收uuid字符串，唯一码，一种生成规则 any 列出的元组中的任意一个 ","date":"2020-03-13","objectID":"/flask01/:6:1","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"6.2 唯一的URL / 重定向行为 以下的两条规则的不同之处在于是否使用尾部的/: @app.route('/projects/') def projects(): return 'The project page' @app.route('/about') def about(): return 'The about page' 笔记 projects 的 URL 是中规中矩的，尾部有一个斜杠，看起来就如同一个文件夹。 访问一个没有斜杠结尾的 URL 时 Flask 会自动进行重定向，在尾部加上一个斜杠。 about 的 URL 没有尾部斜杠，因此其行为表现与一个文件类似。如果访问这个 URL 时添加了尾部斜杠就会得到一个 404 错误。这样可以保持 URL 唯一，并帮助 搜索引擎避免重复索引同一页面。 ","date":"2020-03-13","objectID":"/flask01/:6:2","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"6.3 反向解析 url_for('函数名',参数名=value) 根据endpoint获取到对应的路径 endpoint默认就是函数的名字 如果有参数 url_for(‘函数名’,key=value,key=value) 反向解析在模板上可以直接使用 使用在app中 url_for(‘endpoint’) endpoint 默认是函数名字 使用在blueprint中 url_for(‘bluename.endpoint’) 蓝图名字.函数名 获取静态资源路径 url_for(‘static’,filename=‘path’) static 资源 path 相对于资源的路径 笔记 为什么不在把 URL 写死在模板中，而要使用反转函数 url_for() 动态构建？ 反转通常比硬编码 URL 的描述性更好。 可以只在一个地方改变 URL ，而不用到处乱找。 URL 创建会为你处理特殊字符的转义和 Unicode 数据，比较直观。 生产的路径总是绝对路径，可以避免相对路径产生副作用。 如果应用是放在 URL 根路径之外的地方（如在 /myapplication 中，不在 / 中）， url_for() 会妥善处理。 from flask import Flask, escape, url_for app = Flask(__name__) @app.route('/') def index(): return 'index' @app.route('/login') def login(): return 'login' @app.route('/user/\u003cusername\u003e') def profile(username): return '{}\\'s profile'.format(escape(username)) with app.test_request_context(): print(url_for('index')) print(url_for('login')) print(url_for('login', next='/')) print(url_for('profile', username='John Doe')) #运行结果 / /login /login?next=/ /user/John%20Doe ","date":"2020-03-13","objectID":"/flask01/:6:3","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"6.4 HTTP 方法 Web 应用使用不同的 HTTP 方法处理 URL 。当你使用 Flask 时，应当熟悉 HTTP 方法。 缺省情况下，一个路由只回应 GET 请求。 可以使用 route() 装饰器的 methods 参数来处理不同的 HTTP 方法: from flask import request @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': return do_the_login() else: return show_the_login_form() methods中指定请求方法 GET POST HEAD PUT DELETE ","date":"2020-03-13","objectID":"/flask01/:6:4","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"7 静态文件 动态的 web 应用也需要静态文件，一般是 CSS 和 JavaScript 理想情况下服务器已经配置好了提供静态文件的服务。但是在开发过程中， Flask 也能做好这项工作。只要在包或模块旁边创建一个名为 static 的文件夹就行了。 静态文件位于应用的 /static 中。 使用特定的 ‘static’ 端点就可以生成相应的 URL url_for('static', filename='style.css') # 这个静态文件在文件系统中的位置应该是 static/style.css ","date":"2020-03-13","objectID":"/flask01/:7:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"8 模板 模板是呈现给用户的界面，在MVT中充当T的角色，实现了VT的解耦，开发中VT有着N:M的关系，一个V可以通用任意T，一个T可以被任意V调用。 模板处理分为两个过程： 加载 渲染 模板代码包含两个部分： 静态HTML 动态插入的代码段 Flask 会在 templates 文件夹内寻找模板。因此，如果应用是一个模块， 那么模板文件夹应该在模块旁边；如果是一个包，那么就应该在包里面： 情形 1 : 一个模块: /application.py /templates /hello.html 情形 2 : 一个包: /application /__init__.py /templates /hello.html ","date":"2020-03-13","objectID":"/flask01/:8:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"8.1 Jinja2 Flask中使用Jinja2模板引擎 Jinja2由Flask作者开发 一个现代化设计和友好的Python模板语言 模仿Django的模板引擎 优点： 速度快，被广泛使用 HTML设计和后端Python分离 较少Python复杂度 非常灵活，快速和安全 提供了控制，继承等高级功能 Flask 自动配置 Jinja2 模板引擎。 使用 render_template()方法可以渲染模板，只要提供模板名称和需要作为参数传递给模板的变量就行了。下面是一个简单的模板渲染例子: from flask import render_template @app.route('/hello/') @app.route('/hello/\u003cname\u003e') def hello(name=None): return render_template('hello.html', name=name) ","date":"2020-03-13","objectID":"/flask01/:8:1","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"8.2 模板语法 模板语法主要分为两种：变量、标签 8.2.1 变量 模板中的变量{{ var }} 视图传递给模板的数据 前面定义出来的数据 变量不存在，默认忽略 8.2.2 标签 模板中的标签{% tag %} 逻辑控制 使用外部表达式 创建变量 宏定义 ","date":"2020-03-13","objectID":"/flask01/:8:2","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"8.3 结构标签 8.3.1 block {% block xxx %} {% endblock %} 块操作 父模板挖坑，子模板填坑 首次出现挖坑，非首次填坑 多次填坑会出现覆盖，不想覆盖使用{{super()}} 8.3.2 extends {% extends 'xxx' %} \u003c!--继承后保留块中的内容--\u003e {{super()}} 8.3.3 include {% include 'xxx' %} 包含，将其他html包含进来，体现的是由零到一的概念 能用block + extends实现的，尽量不要使用include 8.3.4 marco {% marco hello(name) %} {% endmarco %} {{name}} 宏定义，可以在html中定义函数 可以接收参数 通过调用函数生成html 支持导入操作 {% from xxx import yy %} ","date":"2020-03-13","objectID":"/flask01/:8:3","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"8.4 for 循环 {% for item in cols %} AA {% else %} BB {% endfor %} 可以使用和Python一样的for...else 也可以获取循环信息loop loop.first loop.last loop.index loop.index() loop.revindex loop.revindex() ","date":"2020-03-13","objectID":"/flask01/:8:4","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"8.5 过滤器 {{变量|过滤器|过滤器...}} 过滤器并不是先写先执行 safe最后做 capitalize 驼峰命名 lower 变为小写 upper 变为大写 title 标题 trim 去掉空格 reverse 反转 format 格式化 striptags 渲染之前，将值中标签去掉 ","date":"2020-03-13","objectID":"/flask01/:8:5","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"8.6 Flask-Bootstrap 官方文档：Flask-Bootstrap 8.6.1 安装 pip3 install flask-bootstrap 8.6.2 导入和加载扩展 from flask import Flask from flask_bootstrap import Bootstrap def create_app(): app = Flask(__name__) Bootstrap(app) return app # do something with app... 8.6.2 创建基于Bootstrap的模板 {% extends \"bootstrap/base.html\" %} {% block title %}This is an example page{% endblock %} {% block navbar %} \u003cdiv class=\"navbar navbar-fixed-top\"\u003e \u003c!-- ... --\u003e \u003c/div\u003e {% endblock %} {% block content %} \u003ch1\u003eHello, Bootstrap\u003c/h1\u003e {% endblock %} ","date":"2020-03-13","objectID":"/flask01/:8:6","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"9 Request from flask import request @app.route('/request', methods=['GET', 'POST']) def req(): print(request) print(request.method) print(request.data) # arguments 参数，get请求参数 print(request.args) print(request.args.get('name')) # post 相关请求都会有数据 print(request.form) print(request.files) print(requset.cookies) #ip地址 print(requset.remote_addr) # 浏览器标识 print(requset.user_agent) print(requset.user_url) ","date":"2020-03-13","objectID":"/flask01/:9:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"10 Response 服务器返回给客户端的数据 由程序员创建，返回Response对象 直接返回Response对象 通过make_response(data,code) -data 返回的数据内容 -code 状态码 返回文本的内容，状态码 返回模板 @app.route('/response') def(resp): result = render_template('hello.html') print(result) print(type(result)) response = make_response('\u003ch3\u003e响应\u003c/h3\u003e',400) print(response) print(type(response)) return response ","date":"2020-03-13","objectID":"/flask01/:10:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"11 重定向和错误 redirect() url_for(‘函数名’,参数=value) 使用 redirect() 函数可以重定向。使用 abort() 可以更早退出请求，并返回错误代码: from flask import abort, redirect, url_for @app.route('/') def index(): return redirect(url_for('login')) @app.route('/login') def login(): abort(401) this_is_never_executed() # 上例实际上是没有意义的，它让一个用户从索引页重定向到一个无法访问的页面（401 表示禁止访问）。 # 但是上例可以说明重定向和出错跳出是如何工作的。 缺省情况下每种出错代码都会对应显示一个黑白的出错页面。使用 errorhandler() 装饰器可以定制出错页面: from flask import render_template @app.errorhandler(404) def page_not_found(error): return render_template('page_not_found.html'), 404 #注意 render_template() 后面的 404 ，这表示页面对应的出错 代码是 404 ，即页面不存在。缺省情况下 200 表示：一切正常。 ","date":"2020-03-13","objectID":"/flask01/:11:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"12 JSON JSON 格式的响应是常见的，用 Flask 写这样的 API 是很容易上手的。如果从视图返回一个 dict ，那么它会被转换为一个 JSON 响应。 @app.route(\"/me\") def me_api(): user = get_current_user() return { \"username\": user.username, \"theme\": user.theme, \"image\": url_for(\"user_image\", filename=user.image), } 如果 dict 还不能满足需求，还需要创建其他类型的 JSON 格式响应，可以使用 jsonify() 函数。该函数会序列化任何支持的 JSON 数据类型。 @app.route(\"/users\") def users_api(): users = get_all_users() return jsonify([user.to_json() for user in users]) ","date":"2020-03-13","objectID":"/flask01/:12:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"13 蓝图 Blueprint 是一种组织一组相关视图及其他代码的方式。与把视图及其他 代码直接注册到应用的方式不同，蓝图方式是把它们注册到蓝图，然后在工厂函数中把蓝图注册到应用。 flask中用来解决上帝文件问题，将请求从主文件中拆分到多个文件中。 ","date":"2020-03-13","objectID":"/flask01/:13:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"13.1 插件安装 pip3 install flask-blueprint ","date":"2020-03-13","objectID":"/flask01/:13:1","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"13.2 初始化蓝图 # manager.py from flask import Flask from flask_script import Manager from App.views import bp app = Flask(__name__) # 在app中注册 app.register_blueprint(blueprint=bp) manager = Manager(app=app) if __name__ == '__main__' manager.run() # /App/views from flask import Blueprint # 创建一个类，构造一个蓝图 bp = Blueprint('bp',__name__) # 使用 @bp.route('/') def.hello(): return 'Hello Blueprint!' ","date":"2020-03-13","objectID":"/flask01/:13:2","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"14 Cookie 客户端会话技术 数据都是存储在浏览器中 支持过期 不能跨域名 不能跨浏览器 cookie是通过Response来进行操作 flask中的cookie可以直接支持中文 flask对cookie中的内容做了编码 # 读取cookie from flask import request @app.route('/') def index(): username = request.cookies.get('username') # use cookies.get(key) instead of cookies[key] to not get a # KeyError if the cookie is missing. # 存储cookie from flask import make_response @app.route('/') def index(): resp = make_response(render_template(...)) resp.set_cookie('username', 'the username') return resp ","date":"2020-03-13","objectID":"/flask01/:14:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"15 Session 服务端会话技术 对数据进行数据安全操作 默认在内存中 不容易管理 容易丢失 不能多台电脑协作 Flask-Session 默认有效期31天 ","date":"2020-03-13","objectID":"/flask01/:15:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"15.1 Session使用 from flask import Flask, session, redirect, url_for, escape, request app = Flask(__name__) # 使用会话之前必须设置一个密钥。 # Set the secret key to some random bytes. Keep this really secret! app.secret_key = b'_5#y2L\"F4Q8z\\n\\xec]/' @app.route('/') def index(): if 'username' in session: return 'Logged in as %s' % escape(session['username']) return 'You are not logged in' @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': session['username'] = request.form['username'] return redirect(url_for('index')) return ''' \u003cform method=\"post\"\u003e \u003cp\u003e\u003cinput type=text name=username\u003e \u003cp\u003e\u003cinput type=submit value=Login\u003e \u003c/form\u003e ''' @app.route('/logout') def logout(): # remove the username from the session if it's there session.pop('username', None) return redirect(url_for('index')) ","date":"2020-03-13","objectID":"/flask01/:15:1","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"15.2 Flask-Session插件 官方文档：Flask-Session 安装 pip3 install Flask-Session 使用 from flask import Flask, session from flask.ext.session import Session app = Flask(__name__) # Check Configuration section for more details app.config['SESSION_TYPE'] = 'redis' Session(app=app) @app.route('/set/') def set(): session['key'] = 'value' return 'ok' @app.route('/get/') def get(): return session.get('key', 'not set') ","date":"2020-03-13","objectID":"/flask01/:15:2","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"16 消息闪现 闪现系统的基本工作原理是在请求结束时记录一个消息，提供且只提供给下一个请求使用。通常通过一个布局模板来展现闪现的消息。 flash() 用于闪现一个消息。在模板中，使用 get_flashed_messages() 来操作消息。 ","date":"2020-03-13","objectID":"/flask01/:16:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["Flask"],"content":"17 登录示例 from flask import Flask, flash,session, redirect, render_template, url_for, escape, request app = Flask(__name__) # Set the secret key to some random bytes. Keep this really secret! app.secret_key = b'_5#y2L\"F4Q8z\\n\\xec]/' @app.route('/') def index(): if 'username' in session: return 'Logged in as %s' % escape(session['username']) return 'You are not logged in' @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': if request.form['username'] != 'admin' or \\ request.form['password'] != 'secret': flash(u'Invalid password provided', 'error') else: flash('You were successfully logged in') return redirect(url_for('index')) return render_template('login.html', error=error) @app.route('/logout') def logout(): # remove the username from the session if it's there session.pop('username', None) return redirect(url_for('index')) 以下是实现闪现的 layout.html 模板： \u003c!doctype html\u003e \u003ctitle\u003eMy Application\u003c/title\u003e {% with messages = get_flashed_messages() %} {% if messages %} \u003cul class=flashes\u003e {% for category, message in messages %} \u003cli\u003e class=\"{{ category }}\"\u003e{{ message }}\u003c/li\u003e {% endfor %} \u003c/ul\u003e {% endif %} {% endwith %} {% block body %}{% endblock %} 以下是继承自 layout.html 的 index.html 模板： {% block body %} \u003ch1\u003eOverview\u003c/h1\u003e \u003cp\u003eDo you want to \u003ca href=\"{{ url_for('login') }}\"\u003elog in?\u003c/a\u003e {% endblock %} 以下是同样继承自 layout.html 的 login.html 模板： {% extends \"layout.html\" %} {% block body %} \u003ch1\u003eLogin\u003c/h1\u003e {% if error %} \u003cp class=error\u003e\u003cstrong\u003eError:\u003c/strong\u003e {{ error }} {% endif %} \u003cform method=post\u003e \u003cdl\u003e \u003cdt\u003eUsername: \u003cdd\u003e\u003cinput type=text name=username value=\"{{ request.form.username }}\"\u003e \u003cdt\u003ePassword: \u003cdd\u003e\u003cinput type=password name=password\u003e \u003c/dl\u003e \u003cp\u003e\u003cinput type=submit value=Login\u003e \u003c/form\u003e {% endblock %} ","date":"2020-03-13","objectID":"/flask01/:17:0","tags":["Python3.5","Flask"],"title":"结合官方文档 入门Flask","uri":"/flask01/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 人脸检测业务理论及实现","date":"2020-03-12","objectID":"/face06/","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 人脸检测业务理论及实现 ","date":"2020-03-12","objectID":"/face06/:0:0","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"1 人脸业务场景综述 ","date":"2020-03-12","objectID":"/face06/:1:0","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"1.1 生物信息识别 人脸识别是生物信息识别领域重要研究方向之一 生物特征有手形、指纹、脸形、虹膜、视网膜、脉搏、耳廓等 ","date":"2020-03-12","objectID":"/face06/:1:1","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"1.2 人脸业务场景 1.2.1 人脸检测（Face Detection） 检测出图像中人脸所在位置的一项技术 基础提供支持 姿态和表情的变化 不同人的外观差异 光照、遮挡、视角 不同大小、位置 1.2.2 人脸关键点（人脸对齐 Face Alignment） 定位出人脸上五官等关键点坐标的一项技术 人脸美颜、活体检测等基础 人脸外观差异 角度、姿态、遮挡等问题 实时性 稠密关键点（\u003e68点） 1.2.3 人脸属性（Face Attribute） 识别出人脸的性别、年龄、姿态、表情等属性值的一项技术 人脸分析基础 人脸外观差异 角度、姿态、遮挡等问题 等等 1.2.4 人脸对比（Face Compare） 计算两个人脸之间的相似度 人脸验证（Face Verification) 人脸识别（Face Compere） 人脸检索（Face Retrieval） 人脸聚类（Face Cluster） 等等 1.2.5 其他人脸业务场景 人脸活体检测 情绪识别 面相分析 颜值评分 明星脸匹配 人脸生成 人脸美妆、美颜 人脸风格化 痘痘、皱纹检测 人脸换脸 ","date":"2020-03-12","objectID":"/face06/:1:2","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"1.3 人脸业务流程 ","date":"2020-03-12","objectID":"/face06/:1:3","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"1.4 人脸采集相关问题 不同性别分布，男性、女性。 不同年龄分布，儿童、少年、中年、老年。 不同人种分布，黑人、白人、黄种人。. 不同脸型分布，人脸、猪脸、猴脸。 人脸没有正对摄像头，角度有倾斜，左右倾斜、. 上下倾斜。 翻拍的人脸照片，清晰照片、不清晰照片。 摄像头内包含单张人脸、多张人脸。 测试所处的环境:光线正常、过亮、过暗、暖光、冷光、白平衡等 不同场景:室内、室外、车站、超市等 ","date":"2020-03-12","objectID":"/face06/:1:4","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"1.5 人脸资源——相关数据集 PubFig: Public Figures Face Database(哥伦比亚大学公众人物脸部数据库) Large-scale CelebFaces Attributes (CelebA) Dataset Colorferet Multi-Task Facial Landmark (MTFL) dataset BiolD Face Database - FaceDB Labeled Faces in the Wild Home (LFW) Person identification in TV series CMUVASC \u0026 PIE Face dataset YouTube Faces Wider-face MegaFace CASIA-FaceV5 The CNBC Face Database CASIA-3D FaceV1 IMDB-WIKI FDDB Caltech人脸数据库 The Japanese Female Facial Expression (JAFFE) Database ","date":"2020-03-12","objectID":"/face06/:1:5","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"1.6 人脸资源——相关厂商 ","date":"2020-03-12","objectID":"/face06/:1:6","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"2 人脸检测问题 什么是人脸检测问题？ 从图像中找到人脸的位置 人脸检测的用处？ 更准确的人脸业务 人脸识别 人脸对比 人脸关键点 人脸属性 ","date":"2020-03-12","objectID":"/face06/:2:0","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"3 人脸标注方法 ","date":"2020-03-12","objectID":"/face06/:3:0","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"3.1 矩形框 传统方法都采用矩形标记法，用一个矩形框将画面中的人脸区域包含在内。这种标记方法存在的问题在于很难给出一个恰好包含面部的矩形框，并且获得各种不同算法的一致的认可。因此采用矩形框的方法无法很好的对不同算法的结果做出准确且有效的评价。 常用四个值来标定(x,y,w,h) (x,y)表示矩形左上角的坐标，w 矩形的宽，h 矩形的高 优点：网络学习起来更容易，目前很多人脸检测算法框架也采用矩形框标注的方法。 缺点：标注的区域中一部分并不属于人脸。 ","date":"2020-03-12","objectID":"/face06/:3:1","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"3.2 椭圆形标注 由于人脸天然呈现为椭圆形，所以用椭圆形来表征是一种较为准确的方法，如下图所示,这种方法可以对侧脸与转动后的面部进行描述，常用5个值来标定。 ra：椭圆长轴半径 rb：椭圆短轴半径 theta：椭圆长轴偏转角度 cx：椭圆圆心x坐标 cy：椭圆圆心y坐标 ","date":"2020-03-12","objectID":"/face06/:3:2","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"4 人脸检测性能评价指标 ","date":"2020-03-12","objectID":"/face06/:4:0","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"4.1 检测率、误报率 检测率 = 正确检出人脸个数/真实人脸个数 误报率 = 检出目标中错误的人脸数量/总共检测出的目标数量 每一个标记真值:GT只允许有一个检测与之相对应 重复检测会被视为错误检测 ","date":"2020-03-12","objectID":"/face06/:4:1","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"4.2 速度：FPS ","date":"2020-03-12","objectID":"/face06/:4:2","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"4.3 IOU(Intersection-over-Union) $IOU = \\dfrac{area(C) \\bigcap area(G)}{area(C) \\bigcup area(G)}$ 产生的候选框（candidate bound）与原标记框（ground truth bound）的交叠率,即它们的交集与并集的比值。 最理想情况是完全重叠，即比值为1。 ","date":"2020-03-12","objectID":"/face06/:4:3","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"4.4 Precision-Recall/ROC accuracy $ =\\frac{TP}{P+N}$ 符号 含义 p Positive 正样本数量 n Negative 负样本数量 Y 预测为正样本数量 N 预测为负样本数量 4.4.1 PR曲线 precisidon$ =\\frac{TP}{TP+FP}$ recall$ = \\frac{TP}{P}$ 符号 以人脸识别（PR）为例 p 真实人脸区域 n 真实背景区域 Y 检出的人脸框 N 没有检出区域 11-point interpolated average precision 4.4.2 ROC曲线 前提：当前图片智能有一个人脸 通常用于FDDB数据集 fp rate$ =\\frac{FP}{N}$ tp rate $= \\frac{TP}{P}$ 以人脸识别（ROC）为例 p 图片中存在人脸的图片 n 图片中不存在人脸的图片 Y 在当前图片中检测出人脸 N 在当前图片中没有检测出人脸 ","date":"2020-03-12","objectID":"/face06/:4:4","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"5 人脸检测方法介绍 ","date":"2020-03-12","objectID":"/face06/:5:0","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"5.1 传统的人脸检测方法 笔记 VJ(Viola-Jones)框架算法要点: 使用类Haar输入特征：对矩形图像区域的和或差进行阈值化。 积分图像技术加速了矩形图像区域的45度旋转的值的计算，这个图像结构被用来加速类Haar输入特征的计算。 使用Adaboost来创建二分类问题（人脸与非人脸）的分类器节点（高通过率，低拒绝率）。 把分类器节点组成筛选式级联（在筛选式级联里，一个节点是Adaboost类型的一组分类器）。 DPM DPM算法由Felzenszwalb提出，是一种基于部件的检测方法， 对目标的形变具有很强的鲁棒性。目前DPM已成为众多分类、分割、姿态估计等 算法的核心部分，Felzenszwalb本人也因此被VOC授予\"终身成就奖\"。 DPM算法采用了改进后的HOG特征，SVM分类器和滑动窗口（Sliding Windows）检测思想， 针对目标的多视角问题，采用了多组件（Component）的策略，针对目标本身的形变问题， 采用了基于图结构（Pictorial Structure）的部件模型策略。 此外，将样本的所属的模型类别，部件模型的位置等作为潜变量（Latent Variable）， 采用多示例学习（Multiple-instance Learning）来自动确定。 JDA（Joint Cascade Face Detection and Alignment） 目前比较先进的人脸检测算法.它结合了 cascade 和 alignment ，一方面做alignment对进一步的人脸识别意义重大， 另一方面作者在 section 2 讲到了landmark附近的特征可促进分类器分辨出更准确的结果， 最后，将这两者放在一起做不仅相互促进而且还相互节省了时间。 ","date":"2020-03-12","objectID":"/face06/:5:1","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"5.2 从粗粒度到细粒度的级联模型（Deep Learning） ","date":"2020-03-12","objectID":"/face06/:5:2","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"5.3 通用目标检测算法+基于人脸问题的优化 通用目标检测算法 人脸检测算法 人脸检测相关文献： http://www.imooc.com/article/284277 ","date":"2020-03-12","objectID":"/face06/:5:3","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"6 人脸检测问题挑战及解决思路 人脸可能出现在图像中的任何一个位置 人脸可能有不同的大小 人脸在图像中可能有不同的视角和姿态 人脸可能部分被遮挡 ","date":"2020-03-12","objectID":"/face06/:6:0","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"7 小人脸检测问题/策略 ","date":"2020-03-12","objectID":"/face06/:7:0","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"7.1 小人脸检测问题 下采样倍率很大时，人脸区域基本消失 相比于感受野和anchor的尺寸来说，人脸的尺寸太小 Anchor匹配策略（IOU小且变化敏感） 正负样本比例失衡 ","date":"2020-03-12","objectID":"/face06/:7:1","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"7.2 小人脸检测问题策略 尺度不敏感/多尺度的策略 调整优化Anchor策略 在线的难例挖掘 IOU计算方式 数据增强 ","date":"2020-03-12","objectID":"/face06/:7:2","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"8 SSD模型 ","date":"2020-03-12","objectID":"/face06/:8:0","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"8.1 Single Shot MultiBox Detector(one-stage方法) Wei Liu在ECCV 2016提出 端到端的训练 直接回归目标类别和位置 不同尺度的特征图上进行预测 ","date":"2020-03-12","objectID":"/face06/:8:1","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"8.2 SSD模型介绍 主干网络：VGGNet 多尺度Feature Map预测 Default bounding boxes的类别分数、偏移量 8.2.1 Anchor Anchor指特征图上的每一个点 8.2.2 Default box m*n个单元，每个单元称作一个Anchor 每个单元上生成固定尺度和长宽比的box 假设一个特征图有mxn个单元，每个单元对应k个default box,每个default box预测c个类别概率分布和4个坐标 (c+4)*k*m*n个输出值 8.2.3 Prior box 实际选择的default box 38*38*4 + 19*19*6 + 10*10*6 + 5*5*6 + 3*3*4+1*1*4= 8732个prior box 8.2.4 损失函数 $$L(x,c,l,g)=\\dfrac{1}{N} (L_{conf}(x,c)+\\alpha L_{loc}(x,l,g))$$ 8.2.5 样本构造 正样本 从GT box出发给找到最匹配的prior box放入候选正样本集 从prior box集出发，寻找与GT box满足lOU\u003e 0.5的最大prior box放入候选正样本集 负样本 难例挖掘 正负样本比 1:3 8.2.6 数据增强 随机采样多个path,与物体之间最小的jaccard overlap为: 0.1, 0.3, 0.5, 0.7与0.9 采样的区域比例是[0.3, 1.0]， aspect ratio 在0.5或2 GTbox中心在采样区域中且面积大于0 Resize到固定大小 以0.5的概率随机的水平翻转 ","date":"2020-03-12","objectID":"/face06/:8:2","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"8.3 TensorFlow+SSD环境搭建 笔记 安装TensorFlow环境 TensorFlow-gpu版本1.12以上 https://github.com/tensorflow/models.git 目标检测算法源码框架 安装教程 ","date":"2020-03-12","objectID":"/face06/:9:0","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"9 人脸检测数据集 ","date":"2020-03-12","objectID":"/face06/:10:0","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"9.1 WIDER FACE 数据集 笔记 WIDER FACE数据集 由香港中文大学提出 32203个图像和393703个人脸图像 在尺度，姿势，遮挡，表情，装扮，光照等 61个事件类别组织的，对于每一个事件类别，选取其中的40%作为训练集,10%用于交叉验证，50%作为测试集 下载地址：http://shuoyang1213.me/WIDERFACE/ ","date":"2020-03-12","objectID":"/face06/:10:1","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"9.2 Passcal VOC 对于WIDER FACE数据集，我们首先会将他转化为Passcal VOC格式 VOC主要有三个重要的文件夹 笔记 Annotations 存放标注信息 ImageSets 存放训练和测试用到的文件列表 JPEGImages 存放图片信息 VOC数据基本结构 \u003cannotaion\u003e \u003cfloder\u003ewiderface\u003c/floder\u003e \u003cfilename\u003e0--Parade_0_Parade_marchingband_1_5.jpg\u003c/filename\u003e #指向了JPEGImage下面的一个图片 \u003csource\u003e #图片来源 \u003cdatabse\u003ewider face Database\u003c/databse\u003e \u003cannotation\u003ePASCAL VOC2007\u003c/annotaion\u003e \u003cimage\u003eflickr\u003c/image\u003e \u003cflickrid\u003e1\u003c/flickerid\u003e \u003csource\u003e \u003cowner\u003e \u003cflickerid\u003eieblyang\u003c/flickerid\u003e \u003cname\u003eieblyang\u003c/name\u003e \u003c/owner\u003e \u003csize\u003e #当前图片的尺寸，通道数 \u003cwidth\u003e1024\u003c/width\u003e \u003cheight\u003e683\u003c/height\u003e \u003cdepth\u003e3\u003c/depth\u003e \u003c/size\u003e \u003csegmented\u003e0\u003c/segmented\u003e \u003cobject\u003e #一个object对应一个人脸 \u003cname\u003eface\u003c/name\u003e \u003cpose\u003eUnspecified\u003c/poss\u003e \u003ctruncated\u003e1\u003c/truncated\u003e \u003cdiffcult\u003e0\u003c/diffcult\u003e \u003cbndbox\u003e#记录了矩形框的坐标值 \u003cxmin\u003e495\u003c/xmin\u003e \u003cymin\u003e347\u003c/ymin\u003e \u003cxmax\u003e532\u003c/xmax\u003e \u003cymax\u003e398\u003c/ymax\u003e \u003c/bndbox\u003e \u003c/object\u003e ... \u003c/annotaion\u003e ","date":"2020-03-12","objectID":"/face06/:10:2","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"9.3 WIDER FACE 标注文件 # wider_face_train_bbx_gt.txt 0--Parade/0_Parade_marchingband_1_849.jpg # 图片路径 1 # 针对当前图片中的人脸个数 449 330 122 149 0 0 0 0 0 0 # 当前人脸的标准信息 ↑ ↑ 前两个值人脸框左上角坐标 ↑ ↑ 第三四个值表示人脸框的大小 ↑ ↑ ↑ ↑ ↑ ↑ 后六个值分别表示Scale、Pose、Occlusion、Expression、Makeup、Illumation 利用这六个值可以对人脸数据进行清洗 ","date":"2020-03-12","objectID":"/face06/:10:3","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"10 实例代码 ","date":"2020-03-12","objectID":"/face06/:11:0","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"10.1 数据集处理 WIDER FACE数据集在使用前，需要将它转化为Passcal VOC2007格式。Passcal VOC2007格式主要有三个重要的文件夹，Annotations用来存放标注信息，ImageSets存放训练和测试用到的文件列表，JPEGImages用来存放图片信息。 第一步，将WIDER FACE解析好的数据写入到xml文件中，处理时需要获取图片的基本信息，代码如下： size = doc.createElement('size') # 获取图片的基本信息 annotation.appendChild(size) width = doc.createElement('width') # 宽度 width.appendChild(doc.createTextNode(str(saveimg.shape[1]))) height = doc.createElement('height') # 高度 height.appendChild(doc.createTextNode(str(saveimg.shape[0]))) depth = doc.createElement('depth') # 通道数量 depth.appendChild(doc.createTextNode(str(saveimg.shape[2]))) 在这一步中，需要获取到人脸的坐标信息，代码如下： # bboxes 当前图片中人脸框的坐标 for i in range(len(bboxes)): bbox = bboxes[i] objects = doc.createElement('object') annotation.appendChild(objects) object_name = doc.createElement('name') object_name.appendChild(doc.createTextNode('face')) objects.appendChild(object_name) pose = doc.createElement('pose') pose.appendChild(doc.createTextNode('Unspecified')) objects.appendChild(pose) truncated = doc.createElement('truncated') truncated.appendChild(doc.createTextNode('0')) objects.appendChild(truncated) difficult = doc.createElement('difficult') difficult.appendChild(doc.createTextNode('0')) objects.appendChild(difficult) bndbox = doc.createElement('bndbox') objects.appendChild(bndbox) xmin = doc.createElement('xmin') xmin.appendChild(doc.createTextNode(str(bbox[0]))) bndbox.appendChild(xmin) ymin = doc.createElement('ymin') ymin.appendChild(doc.createTextNode(str(bbox[1]))) bndbox.appendChild(ymin) xmax = doc.createElement('xmax') xmax.appendChild(doc.createTextNode(str(bbox[0] + bbox[2]))) bndbox.appendChild(xmax) ymax = doc.createElement('ymax') ymax.appendChild(doc.createTextNode(str(bbox[1] + bbox[3]))) bndbox.appendChild(ymax) 第二步，对WIDER FACE数据集的训练集和测试集的真值文件进行解析。在这一过程中，需要对WIDER FACE数据集进行简单的数据清洗操作，使训练数据更加接近实际的业务场景，主要代码如下： sc = max(im_data.shape) im_data_tmp = numpy.zeros([sc, sc, 3], dtype = numpy.uint8) off_w = (sc - im_data.shape[1]) // 2 off_h = (sc - im_data.shape[0]) // 2 # 对图片进行周围填充，填充为正方形 im_data_tmp[off_h:im_data.shape[0] + off_h, off_w:im_data.shape[1] + off_w, ...] = im_data im_data = im_data_tmp numbox = int(gt.readline()) bboxes = [] for i in range(numbox): line = gt.readline() infos = line.split(\" \") for j in range(infos.__len__() - 1): infos[j] = int(infos[j]) # 数据清洗：保留resize到640×640 尺寸在8×8以上的人脸 if infos[2] * 80 \u003c im_data.shape[1] or infos[3] * 80 \u003c im_data.shape[0]: continue bbox = (infos[0] + off_w, infos[1] + off_h, infos[2], infos[3]) bboxes.append(bbox) 第三步，以SSD模型中的create_pascal_tf_record.py脚本为基础新建create_face_tf_record.py脚本对已经转化成Passcal VOC2007格式的训练样本和测试样本分别进行打包，在这一过程中需要将源码中的YEARS修改为widerface，将label_map_path指定到face_lable_map.pbtxt，训练集数据打包的命令参数如下： python3 object_detection/dataset_tools/create_face_tf_record.py \\ --data_dir=/mnt/dataset \\ --year=widerface \\ --output_path=/mnt/dataset/widerface/TF-data/train.record \\ --set=train ","date":"2020-03-12","objectID":"/face06/:11:1","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"10.2 模型训练 在SSD模型训练中，主要用到的是model_main脚本，由于源码中没有提供专门针对于resnet_50_v1_fpn这一结构的配置文件，所以在选取主干网络时，以ssd_resnet50_v1_fpn_shared_box_predictor_640x640_coco14_sync.config 为基础进行修改，将其修改为用于人脸检测任务的配置文件，并将修改好的配置文件重命名为ssd_resnet50_v1_fpn_shared_box_predictor_640x640_coco14_ sync_face.config，模型主要用于解决人脸识别问题，所以需要将num_classes设置为1。在训练过程中不需要用到预训练模型，所以将预训练模型fine_tune_checkpoint删除或注释掉，最后，修改输入输出的数据。 模型训练的命令及参数配置如下： python3 object_detection/model_main.py \\ --pipeline_config_path= \\ /mnt/FaceAI/models/research/object_detection/samples/configs/ssd_resnet50_v1_fpn_shared_box_predictor_640x640_coco14_sync_face.config --model_dir=/mnt/dataset/widerface/resnet50v1-fpn \\ --num_train_steps=100000 \\ --alsologtostder \\ 模型训练中，预设的训练次数为100000次，通过观察tensorboard中的loss曲线，模型训练的loss在40000次后已经趋于稳定，在训练74839次时停止了模型的训练，总的loss曲线如下图所示： ","date":"2020-03-12","objectID":"/face06/:11:2","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"10.3 模型固化 在模型结束后，使用tensorflow models提供的export_interence_graph.py脚本将已经训练好的模型打包成pb文件，命令与参数配置如下： python3 object_detection/export_inference_graph.py \\ --input_type =image_tensor \\ --popeline_config_path= \\ /mnt/FaceAI/models/research/object_detection/samples/configs/ssd_resnet50_v1_fpn_shared_box_predictor_640x640_coco14_sync_face.config \\ --trained_checkpoint_prefix= \\ /mnt/FaceAI/dataset/widerface/model/resnet50v1-fpn/model.ckpt-75065 --output_directory= \\ /mnt/FaceAI/dataset/widerface/model/resnet50v1-fpn/pb ","date":"2020-03-12","objectID":"/face06/:11:3","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"10.4 模型测试 在模型测试中，利用graph构图后，使用opencv读取用于测试的人脸图片，如果阈值大于0.6则表示识别出人脸，对识别出人脸的图片进行人脸框绘制，并将结果显示出来，实现代码如下： for image_path in im_path_list: imdata = cv2.imread(image_path) sp = imdata.shape imdata = cv2.resize(imdata, IMAGE_SIZE) output_dict = run_inference_for_single_image( imdata, detection_graph ) for i in range(len(output_dict['detection_scores'])): if output_dict['detection_scores'][i] \u003e 0.6: bbox = output_dict['detection_scores'][i] y1 = int(IMAGE_SIZE[0] * bbox[0]) x1 = int(IMAGE_SIZE[1] * bbox[1]) y2 = int(IMAGE_SIZE[0] * bbox[2]) x2 = int(IMAGE_SIZE[1] * bbox[3]) cv2.rectangle(imdata, (x1,y1), (x2,y2), (0,255,0), 2) cv2.imshow(\"im\", imdata) cv2.waitKey(0) 模型测试的结果如下图所示： ","date":"2020-03-12","objectID":"/face06/:11:4","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"11 参考资料 参考资料 FDDB人脸检测算法评价标准 目标检测 IOU（交并比） 理解笔记 走近人脸检测（2）——VJ人脸检测器及其发展 Viola-Jones人脸检測 DPM目标检测算法 解读 Joint Cascade Face Detection and Alignment 人脸检测算法 人脸识别技术大总结1——Face Detection \u0026 Alignment ","date":"2020-03-12","objectID":"/face06/:12:0","tags":["FaceRecognition","TensorFlow","FaceDetection"],"title":"人脸检测业务理论及实现","uri":"/face06/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现  Tensorflow Cifar-10图像分类任务","date":"2020-03-12","objectID":"/face05/","tags":["FaceRecognition","TensorFlow","Cifar-10"],"title":"Tensorflow Cifar-10图像分类任务","uri":"/face05/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 Tensorflow Cifar-10图像分类任务 ","date":"2020-03-12","objectID":"/face05/:0:0","tags":["FaceRecognition","TensorFlow","Cifar-10"],"title":"Tensorflow Cifar-10图像分类任务","uri":"/face05/"},{"categories":["FaceRecognition"],"content":"1 Cifar10图像分类任务 CIFAR-10数据集包含10小类，60000个32*32的彩色图像。有50000个训练图像和10000个测试图像 CIFAR-100数据集包含100小类，每小类包含600个图像，其中有500个训练图像和100个测试图像。100类被分组为20个大类。每个图像带有1个小类的\"fine”标签和1个大类\"coarse\"标签。 ","date":"2020-03-12","objectID":"/face05/:1:0","tags":["FaceRecognition","TensorFlow","Cifar-10"],"title":"Tensorflow Cifar-10图像分类任务","uri":"/face05/"},{"categories":["FaceRecognition"],"content":"2 Cifar10图像数据解析 def unpickle(ile): import pickle with open(file,'rb') as fo: dict = pickle.load(fo,encoding='bytes') return dict ","date":"2020-03-12","objectID":"/face05/:2:0","tags":["FaceRecognition","TensorFlow","Cifar-10"],"title":"Tensorflow Cifar-10图像分类任务","uri":"/face05/"},{"categories":["FaceRecognition"],"content":"3 Cifar10数据打包和数据读取 tf.train.string input producer Train.tfrecord Test.tfrecord ","date":"2020-03-12","objectID":"/face05/:3:0","tags":["FaceRecognition","TensorFlow","Cifar-10"],"title":"Tensorflow Cifar-10图像分类任务","uri":"/face05/"},{"categories":["FaceRecognition"],"content":"4 TensorFlow训练框架搭建 Data Net Loss Summary Session ","date":"2020-03-12","objectID":"/face05/:4:0","tags":["FaceRecognition","TensorFlow","Cifar-10"],"title":"Tensorflow Cifar-10图像分类任务","uri":"/face05/"},{"categories":["FaceRecognition"],"content":"5 TensorFlow挑战Cifar10编程案例 训练代码 测试代码 Tensorboard调试 模型优化 ","date":"2020-03-12","objectID":"/face05/:5:0","tags":["FaceRecognition","TensorFlow","Cifar-10"],"title":"Tensorflow Cifar-10图像分类任务","uri":"/face05/"},{"categories":["FaceRecognition"],"content":"6 如何优化Cifar10图像分类任务 更多的数据增强策略，比如: mixup等 更好的主干网络结构，比如: SENet等 更好的标签策略，比如: Soft-label策略 更好的loss设计，比如:采用分类+回归smooth-l1 loss等 不同的优化器、参数初始化方法等 ","date":"2020-03-12","objectID":"/face05/:6:0","tags":["FaceRecognition","TensorFlow","Cifar-10"],"title":"Tensorflow Cifar-10图像分类任务","uri":"/face05/"},{"categories":["FaceRecognition"],"content":"7 实例代码 https://github.com/ieblYang/CIFAR-10 – ieblYang ","date":"2020-03-12","objectID":"/face05/:7:0","tags":["FaceRecognition","TensorFlow","Cifar-10"],"title":"Tensorflow Cifar-10图像分类任务","uri":"/face05/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 TensorFlow基础串讲","date":"2020-03-12","objectID":"/face04/","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 TensorFlow基础串讲 ","date":"2020-03-12","objectID":"/face04/:0:0","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"1 什么是TensorFlow？ Google开源的基于数据流图的科学计算库，适合用于机器学习、深度学习等人工智能领； https://github.com/tensorflow https://github.com/tensorflow/models Tensor(张量、数据)+Flow（数据流、数据流向）=TensorFlow（整个数据按一定的方向流动，在流动的同时需要进行一系列的运算） ","date":"2020-03-12","objectID":"/face04/:1:0","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"2 TensorFlow的架构 前端：编程模型、构造计算图、Python、C++、Java（计算图的设计） 后端：运行计算图、C++（计算图的搭建） ","date":"2020-03-12","objectID":"/face04/:2:0","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"3 TensorFlow的优点 高度的灵活性（支持非常原子的操作，比如 +、-、*、/ 、与或非等基本运算，提供了非常丰富的API接口） 真正的可移植性（底层采用C实现） 将科研与产品联系在一起（采用TensorFlow进行的科研模型可以直接用在产品上） 自动求微分 多语言支持（Python、C++、Java） 性能最优化（由Google维护） 社区内容丰富（Github收藏量远远高于其他深度学习模块） ","date":"2020-03-12","objectID":"/face04/:3:0","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"4 TensorFlow中的基本概念 ","date":"2020-03-12","objectID":"/face04/:4:0","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"4.1 Graph 图描述了计算的过程，可以通过tensorboard图形化流程结构 声明（单个/多个） 保存为pb文件（包括网络结构和网络参数） 从pb中恢复Graph TensorFlow可视化 #声明 g = tf.Graph() g = tf.get_default_graph() g = tf.constant(0) g = x.graph #如何声明和交叉使用多个Graph？ g1 = tf.Graph() with g1.as_default(): x1 = tf.constant(1.0,name=\"x1\") g2 = tf.Graph() with g2.as_default(): x2 = tf.constant(2.0,name=\"x2\") with tf.Session(graph=g2) as sess1: x1_list = tf.tf.import_graph_def(g1.as_graph_def, return_elements = [\"x1:0\"],name = \"\") print(sess_1.run(x1_list[0] + x2))) #保存pb g1 = tf.Graph() tf.train.write_graph(g1.as_graph_def(),'.','graph.pb',False) #从pb中恢复Graph #load graph with gfile.FastGFile(\"graph.pb\",'rb') as f: graph_def = tf.GraphDef() graph_def.ParseFromString(f.read()) tf.import_graph_def(graph_def,name='') sess = tf.Session() c1_tensor = sess.graph.get_tensor_by_name(\"c1:0\") #获取计算图的节点 c1 = sess.run(c1_tensor) #计算计算图相应节点的值 #使用tensorboard可视化计算图结构 import tensorflow as tf a = tf.constant(1,name='input a') #定义常量 b = tf.constant(2,name='input b') c = tf.multiply(a,b,name='maltiply_c') d = tf.add(a,b,name='add_d') e = tf.add(d,c,name='add_e') sess = tf.Session() sess.run(e) writer = tf.summary.FileWriter('graph',sess.graph) ","date":"2020-03-12","objectID":"/face04/:4:1","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"4.2 Session 图必须在称之为“会话”的上下文中执行。 会话将图的op（操作）分发到诸如CPU或GPU之类的设备上执行。 前段和后端的沟通，起到桥梁的作用 #创建和关闭会话 sess = tf.Session() #常用 sess = tf.InteractiveSession() #交互式，对交互性要求比较高的脚本中，希望实时看到脚本运行的结果 with tf.Session() as Sess: #定义Session的作用域，和sess = tf.Session() 等价 ... sess.close() #注入机制,完成计算图的运算，桥梁作用 sess.run(...) sess.run(tf.global_variables_initializer()) a = tf.placeholder(dtype=tf.float32) b = tf.placeholder(dtype=tf.float32) add = a + b add_val = sess.run(add,feed_dict={a:1,b:2}) #制定资源设备 a = tf.placeholder(dtype=tf.float32) b = tf.placeholder(dtype=tf.float32) add = a + b with tf.Session() as sess: with tf.device(\"/cpu:0\") print(sess.run(ass,feed_dict = {a:1,b:1})) #资源分配-控制GPU资源使用率 config = tf.ConfigProto() config.gpu_options.allow_growth = True #按需分配 session = tf.Session(config=config,...) ","date":"2020-03-12","objectID":"/face04/:4:2","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"4.3 Tensor 在TensorFlow中，所有在结点之间传递的数据都为Tensor对象 N维数组，图像：（batch*height*width*channel） #Tensor的定义 #tf.constant() 常量 cons = tf.constant(value=[1,2],dtype=tf.float32,shape=(1,2),name='testconst',verify_shape=False) # 取值 类型 形状 名称 形状是否可以改变 #tf.Variable() 变量 W = tf.Variable(tf.zeros([3,10]),dtype=tf.float64,name='W') #tf.placeholder() 占位符 X = tf.placeholder(dtype=tf.float32,shape=[144,10],name='X') X = tf.placeholder(dtype=tf.float32,shape=[None,None],name='X') #tf.SparseTensor() 稀疏的张量 ","date":"2020-03-12","objectID":"/face04/:4:3","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"4.4 Operation TensorFlow Graph 中的计算节点，输入输出均为Tensor 调用Session.run(tensor)或者tensor.eval()方可获取该Tensor的值 ","date":"2020-03-12","objectID":"/face04/:4:4","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"4.5 Feed 通过feed为计算图注入值 a = tf.placeholder(tf.float32) b = tf.placeholder(tf.float32) c = tf.add(a,b) with tf.Session() as sess: result = sess.run(c,feed_dict={a:3,b:4}) print(result) ","date":"2020-03-12","objectID":"/face04/:4:5","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"5 TensorFlow在深度学习中使用的API tf.split(split_dam,num_split,value,name='split') tf.concat(concat_dim,values,name='concat') tf.cast() tf.reshape() tf.equal() tf.matmul(a,b) tf.argmax() tf.squeeze() #tf.nn tf.nn.conv2d tf.nn.max_pool tf.nn.avg_pool tf.nn.relu tf.nn.dropout tf.nn.l2_normalize tf.nn.batch_normalization tf.nn.l2_loss tf.nn.softmax_cross_enyropy_with_logits #tf.train tf.train.Saver.save tf.train.Saver.restore tf.train.GradientDescentOptimizer(0.01).minimize(loss) tf.train.exponential_decay(1e-2,global_step,decay_steps=sample_size/batch,decay_rate=0.98,staircase=True) tf.train.string_input_producer(filenames,num_epochs=num_epochs,shuffle=True) tf.train.shuffle_batch([example,lable],batch_size=batch_size,capacity=capacity,min_after_dequeue=min_after_dequeue) tf.train.Coordinator tf.train.start_queue_runners(sess=sess,coord=coord ","date":"2020-03-12","objectID":"/face04/:5:0","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"6 TensorFlow中的数据操作 TensorFlow提供了TFRecord的格式来统一存储数据 ","date":"2020-03-12","objectID":"/face04/:6:0","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"6.1 TFRecord TFRecord将图像数据和标签放在一起的二进制文件（protocol buffer），能更好的利用内存，实现快速的复制，移动， 读取，存储 数据读取：tf.train.string_input_producer 数据解析：tf.TFRecordReader、tf.parse_single_example 数据写入：tf.python_io.TFRecordWriter ","date":"2020-03-12","objectID":"/face04/:6:1","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"6.2 数据写入相关的API方法 writer = tf.python_io.TFRecordWriter() example = tf.train.Example() writer.close() writer.writer(example.SerializeToString()) ","date":"2020-03-12","objectID":"/face04/:6:2","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"6.3 数据读取相关的API方法 直接从文件中读取图片 从TF-Record中解析打包的图片数据 tf.train.string_input_producer、tf.train.slice_input_producer tf.data库（动态图机制） ","date":"2020-03-12","objectID":"/face04/:6:3","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"7 TensorFlow在深度学习中高级封装 ","date":"2020-03-12","objectID":"/face04/:7:0","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"7.1 TensorFlow在深度学习中使用的API #slim slim layers slim.arg_scope slim.data slim evaluation slim learning slim losses slim nets slim variables slim metrics ","date":"2020-03-12","objectID":"/face04/:7:1","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"7.2 slim.arg_scope arg_scope(list_ops_or_scope,**kwargs) list_ops_or_scope:操作列表或作用域列表 kwargs: 参数，以keyword=value方式显示 net = slim.conv2d(inputs,64, [11, 11],4, padding='SAME', weights_initializer= tf.truncated_normal_initializer (stddey=0.01)， weights_regularizer= slim.12_regularizer(0.0005),scope='convl') with slim.arg_scope ([slim.conv2d],padding='SAME', weights_initializer= tf.truncated normal initializer(stddev=0.01) weights_regularizer= slim.12_regularizer(0. 0005)): net = slim.conv2d (inputs, 64,[11， 11], scope='conv1') net = slim.conv2d (net, 128,[11， 11], padding='VALID', scope= 'conv2') net = slim.conv2d(net， 256,[11， 11], scope= 'conv3') ","date":"2020-03-12","objectID":"/face04/:7:2","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"7.3 BatchNorm层使用技巧 #slim.batch_norm()函数 normalizer_fn = slim.batch_norm normalizer_params = batch_norm_params #batch_norm_params 'is_training':is_training, 'zero_debias_moving_mean':True, 'decay':batch_norm_decay, 'epsilon':batch_norm_epsilon, 'scale':batch_nrom_scale, 'updates_collections':tf.GraphKeys.UPDATE_OPS, with slim.arg_ scope( [slim.conv2d], weights_regularizer=slim.12_regularizer(weight_decay), weights_initializer=slim.variance_scaling_initializer(), activation_fn=tf.nn.relu, normalizer_fn=slim.batch_ norm, normalizer_params=batch_norm_params) : with slim.arg_scope([slim.batch_norm], **batch_norm_params ): with slim.arg_scope([slim.max_pool2d], padding='SAME') as arg_SC: return arg_SC update_ops = tf.get_collection(tf.GraphKeys.UPDATE OPS) with tf.control_dependencies(update_ops): train step = tf.train. GradientDescentoptimizer (0.01). minimize (total_loss) batchnorm updates = tf.get_collection (UPDATE_OPS_COLLECTION) batchnorm updates_op = tf.group (*batchnorm_updates) ","date":"2020-03-12","objectID":"/face04/:7:3","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"7.4 slim net from tensorflow.contrib.slim.python.slim.nets import alexnet from tensorflow.contrib.slim.python.slim.nets import inception from tensorflow.contrib.slim.python.slim.nets import oxerfeat from tensorflow.contrib.slim.python.slim.nets import resnet_utils from tensorf1ow.contrib.slim.python.slim.nets import resnet_v1 from tensorflow.contrib.slim.python.slim.nets import resnet_v2 from tensorflow.contrib.slim.python.slim.nets import ygg ","date":"2020-03-12","objectID":"/face04/:7:4","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"7.5 slim loss 经验风险小 分类损失 平方损失 等等 正则化LOSS 变量的L2正则化约束 weights_ regularizer = slim.12 regularizer (0.0005) ) loss_val = tf.nn.12_loss (var) regularization_loss = tf.add_n( slim.losses.get_regularization_losses() ) total_loss1 = classification_loss + sum_of_squares_loss + pose_loss + regularization_loss slim.losses.add_loss(pose_loss) total_loss2 = slim.losses.get_total_loss() ","date":"2020-03-12","objectID":"/face04/:7:5","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"7.6 slim learn 梯度/学习率/BP 学习率更新 优化函数 等等 学习率 tf.train.piecewise_constant 分段常数衰减 tf.train.inverse_time_decay 反时限衰减 tf.train.polynomial_decay 多项式衰减 tf.train.exponential_decay 指数衰减 ... ","date":"2020-03-12","objectID":"/face04/:7:6","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"7.7 slim metrics TF-Slim提供了一系列度量操作，使评估模型变得简单 value_ op是一个幂等操作，返回度量的当前值。 update_ op是执行上述聚合步骤以及返回度量值的操作。 mae_ value_ op, mae_ update _op = slim.metrics.streaming_mean_absolute_error( predictions, labels ) ","date":"2020-03-12","objectID":"/face04/:7:7","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"7.8 slim ecaluation TF-Slim提供一个评估模块evaluation.py，其中包含用于使用metric_ ops.py模块中的指标编写模型评估脚本的帮助 slim.evaluation.evaluation_1oop( 'local', checkpoint_dir, 1og_dir, num_evals=num batches, eval_op=names_to_updates.values(), summary_op=tf.summary.merge(summary_ops), eval_interval secs=eval_interval_secs) 函数: evaluation_ loop、evaluation once ","date":"2020-03-12","objectID":"/face04/:7:8","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"7.9 slim data slim.data包 下面有很多对数据的操作方法 在slim._init_中有如下几种: from tensorflow.contrib.slim.python.slim.data import data_decoder from tensorflow.contrib.slim.python.slim.data import data_provider from tensorflow.contrib.slim.python.slim.data import dataset from tensorflow.contrib.slim.python.slim.data import dataset_data_provider from tensorflow.contrib.slim.python.slim.data import parallel_reader from tensorflow.contrib.slim.python.slim.data import prefetch_queue from tensorflow.contrib.slim.python.slim.data import tfexample_decoder ","date":"2020-03-12","objectID":"/face04/:7:9","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"8 TensorFlow常见的数据增强方法 ","date":"2020-03-12","objectID":"/face04/:8:0","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"8.1 tf.image库进行数据增强 颜色扰动(亮度、对比度、HSV、 RGB等) 裁剪/Pad 噪声/模糊 翻转/旋转(空间几何变换/放射变换) Draw Boxes 标准化 ","date":"2020-03-12","objectID":"/face04/:8:1","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"8.2 其他数据增强的方法 Mixup Oversampling 锐化/浮雕/灰度 边界检测 超像素 255-V \"\"\"图像亮度[-1, 1]\"\"\" # img_data = tf.image.adjust_brightness(img_data, delta=-.7) \"\"\"随机图像亮度\"\"\" # img_data = tf.image.random_brightness(img_data, max_delta=0.6) \"\"\"随机对比度\"\"\" # img_data = tf.image.random_contrast(img.data, lower=0, upper=4) \"\"\"随机色调\"\"\" # img_data = tf.image.random_hue(img. data, 0.5) \"\"\"随机饱和度\"\"\" # img_data = tf.image.random_saturation(img_data, lower=0, upper=2) \"\"\"图片标准化 (x-mean) / max(stddev, 1.0/sqrt(image.NumElements()))\"\"\" # img_data = tf.image.per_image_standardization( img.data) ","date":"2020-03-12","objectID":"/face04/:8:2","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"9 Tensorboard使用介绍 ","date":"2020-03-12","objectID":"/face04/:9:0","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"9.1 Tensorboard可以进行网络可视化/训练中间结果可视化 pip3 install tensorboard tensorboard --logdir logs #Scalars/Graph/lmage/Histogram/Distributions ","date":"2020-03-12","objectID":"/face04/:9:1","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"9.2 tf.summary writer = tf.summary.FileWriter(\"logs/\", sess.graph) tf.summary.histogram'bias',bias) tf.summary.scalar('loss',loss) tf.summary.image( 'image',image) merged = tf.summary.merge_all() rs=sess.run(merged) writer.add_summary(rs,step) ","date":"2020-03-12","objectID":"/face04/:9:2","tags":["FaceRecognition","TensorFlow"],"title":"TensorFlow基础串讲","uri":"/face04/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 卷积神经网基础串讲","date":"2020-03-12","objectID":"/face03/","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 卷积神经网基础串讲 ","date":"2020-03-12","objectID":"/face03/:0:0","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"1 卷积神经网发展历程与基本概念 ","date":"2020-03-12","objectID":"/face03/:1:0","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"1.1 什么是卷积神经网 笔记 以卷积结构为主，搭建起来的深度网络 将图片作为网络的输入，自动提取特征，并对图片的变形（如平移、比例缩放、倾斜）等具有高度不变形 ","date":"2020-03-12","objectID":"/face03/:1:1","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"2 卷积神经网络的重要组成单元 ","date":"2020-03-12","objectID":"/face03/:2:0","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"2.1 卷积 2.1.1 基本定义 笔记 基本定义：对图像和滤波矩阵做内积（逐个元素相乘再求和）的操作 滤波器 每一种卷积对应一种特征 lm2col实现卷积运算 2.1.2 卷集中的重要参数 1. 卷积核 最常用为2D卷积核（k_w * k_h） 权重和偏置项 常用卷积核：1*1、3*3、5*5 保护位置信息 padding时对称 2. 卷积 权值共享与局部连接（局部感受野/局部感知） 卷积运算作用在局部 Feature map使用同一个卷积核运算后得到一种特征 多种特征采用多个卷积核（channel） 3. 卷积核与感受野 如何计算卷积参数量？（Parameters） ( k_w * k_h * In_channel + 1 ) * Out_channel 如何计算卷积的计算量？（FLOPs） In_w * In_h * ( k_w * k_h * In_channel + 1 ) * Out_channel 4. 步长 下采样过程 输出 Feature Map 的大小如何变化？ 参数量和计算量？ 5. Pad 确保Feature Map整数倍变化，对尺度相关的任务尤为重要 参数量和计算量？ 2.1.3 卷积的定义与使用（caffe） layer{ name:\"conv1\" type:\"Convolution\" bottom:\"data\" top:\"conv1\" param{} convolution_param{} } param{ lr_mult:1 //weight } param{ lr_mult:2 //bias } convlolution_param{ num_output:20 kernel_size:5 stride:1 weight_filler{ type:\"xavier\"} bias_filler{ type:\"constant\"} } 2.1.4 卷积的定义与使用（TensorFlow） filter_weight = tf.get_variable('weight',[5,5,3,16], initializer = tf.truncated_normal_initializer(stddev=0.1)) biases = ft.get_variable('biases',[16],initializer = tf.constant_initializer(0.1)) conv = tf.nn.conv2d(input,filter_weight,strides=[1,1,1,1],padding='SAME') bias = tf.nn.bias_add(conv,biases) net = slim.conv2d(input_x,64,[3,3],scope='conv1_1') ","date":"2020-03-12","objectID":"/face03/:2:1","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"2.2 池化 2.2.1 基本定义 笔记 基本定义：对输入的特征图进行压缩 使特征图变小，简化网络计算复杂度 进行特征压缩，提取主要特征 增大感受野 2.2.2 常见的池化策略 最大池化（Max Pooling） 平均池化（Average Pooling） 随机池化（Stochastic Pooling） ","date":"2020-03-12","objectID":"/face03/:2:2","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"2.3 激活 2.3.1 基本定义 笔记 基本概念：增加网络的非线性，进而提升网络的表达能力 非线性 单调性 可微性 取值范围 Sigmoid、Tanh、ReLU、ELU、Maxout、Softplus、Softsign 2.3.2 Sigmoid 梯度弥散/梯度饱和 指数运算 输出不是以零为中心 2.3.3 Tanh 双曲正切函数（Tanh） 完全可微分的，反对称，对称中心在原点 指数运算 2.3.4 ReLU 修正线性单元（Rectified Linear Unit，ReLU） 保留了step函数的生物学启发（只有输入超出阈值时神经元才激活） 函数形式简单，正数时不存在梯度饱和 一旦输入到了负数，ReLU就会死掉 ","date":"2020-03-12","objectID":"/face03/:2:3","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"2.4 BN（BatchNorm） 2.4.1 基本概念 笔记 基本概念：通过一定的规范化手段，把每层神经网络任意神经元这个输入值的分布强行拉回到均值为0方差为1的标准正态分布 2.4.2 BatchNorm层优点 减少了参数的人为选择，可以取消Dropout和L2正则项参数，或者采取更小的L2正则项约束参数； 减少了对学习率的要求 可以不再使用局部响应归一化，BN本身就是归一化网络（局部响应归一化——AlexNet）； 破坏原来的数据分布，一定程度上缓和过拟合。 2.4.3 BatchNorm层使用 在Caffe中使用BN层需要注意： 要配合Scale层一起使用 训练时use_global_stats设置为 false 测试时user_global_stats设置为 true layer{ bottom:\"conv1\" top:\"conv1\" name:\"bn_conv1\" type:\"BatchNorm\" batch_norm_param{ use_global_stats:true } } ","date":"2020-03-12","objectID":"/face03/:2:4","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"2.5 全连接层（Fully Connected Layer） 连接所有的特征，将输出值分送给分类器（softmax分类器） 将网络的输出变成一个向量 可以采用卷积替代全连接层 全连接层是尺度敏感的 配合使用dropout层 ","date":"2020-03-12","objectID":"/face03/:2:5","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"2.6 Dropout层 在训练过程中，随机的丢弃一部分输入，此时丢弃部分对应的参数不会更新 数据过拟合问题 取平均的作用 减少神经元之间复杂的共适应关系 ","date":"2020-03-12","objectID":"/face03/:2:6","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"2.7 损失层（LOSS） 2.7.1 损失函数 损失函数：用来评估模型的预测值和真实值的不一致程度。 经验风险小 结构风险小 交叉熵损失、softmax loss等 2.7.2 损失层 损失层定义了使用的损失函数，通过最小化损失来驱动网络的训练 网络的损失通过前项操作计算 网络参数相对于损失函数的梯度则通过反向操作计算 分类任务损失：交叉熵损失 回归任务损失：L1损失、L2损失 2.7.3 交叉熵损失 log-likelihood cost 非负性 当真实输出a与期望输出y接近的时候，代价函数接近于0 # 交叉熵损失实现 tf.nn.softmax_cross_entrpoy_with_logits(_sentinel=None,labels=None, logits=None,dim=-1,name=None) tf.nn.sparse_softmax_cross_entrpoy_with_logits(_sentinel=None,labels=None, logits=None,name=None) L1、L2、Smooth L1损失 Smooth L1是L1的变形，用于Faster RCNN、SSD等网络计算损失 ","date":"2020-03-12","objectID":"/face03/:2:7","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"3 常见的卷积神经网结构 ","date":"2020-03-12","objectID":"/face03/:3:0","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"3.1 LeNet 麻雀虽小五脏俱全 1998年，LeCun提出 用于解决手写数字识别，MNIST ","date":"2020-03-12","objectID":"/face03/:3:1","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"3.2 AlexNet 3.2.1 概念 2012年，Hinton的学生Alex Krizhevsky 做出DeepLearning模型。 con - relu - pooling - LRN fc - relu - dropout fc - softmax 参数量60M以上 模型大小\u003e200M 3.2.2 AlexNet的特点 ReLU非线性激活函数 Dropout层防止过拟合 数据增强，减少过拟合 标准化层（Local Response Normalization） 3.2.3 AlexNet的意义 证明了CNN在复杂模型下的有效性 GPU实现使得训练在可接受的时间范围内得到结果 ","date":"2020-03-12","objectID":"/face03/:3:2","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"3.3 ZFNet 在AlexNet基础上进行细节调整，并取得2013年ILSVA的冠军 从可视化的角度出发，解释CNN有非常好的性能的原因 ZFNet与特征可视化 特征分层次体系结构 深层特征更鲁棒 深层特征更有区分度 深层特征收敛更慢 …… ","date":"2020-03-12","objectID":"/face03/:3:3","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"3.4 VGGNet 3.4.1 概念 由牛津大学计算机视觉组和Google Deepmind共同设计 为了研究网络深度对模型准确度的影响，并采用小卷积堆叠的方式来搭建整个网络结构 参数量：138M 模型大小\u003e500M 3.4.2 VGGNet的特点 更深的网络结构，结构更加规整、简单； 全部使用33的小型卷积核和22的最大池化层 每次池化后Feature Map宽高降低一半，通道数量增加一倍； 网络层数更多、结构更深，模型参数量更大。 3.4.3 VGGNet的意义 证明了更深的网络，能够提取更好的特征 成为后续很多网络的backbone 规范化了后续网络设计的思路 ","date":"2020-03-12","objectID":"/face03/:3:4","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"3.5 GoogLeNet/Inception v1 3.5.1 概念 在设计网络结构时，不仅强调网络的深度，也会考虑网络的宽度，并将这种结构定义为Inception结构（一种网中网（Network In Network）的结构，及原来的结点也是一个网络） 证明了用更多的卷积，更深的层次可以得到更好的结构 参数量6.8M 模型大小50M 3.5.2 GoogLeNet/Inception v1特点 更深的网络结构 两个LOSS层，降低过拟合风险 考虑网络宽度 巧妙地利用1*1的卷积核来进行通道降维，减小计算量 3.5.3 从卷积的角度思考，如何减少网络中的计算量？ 小卷积核来对大卷积核进行拆分 Stride = 2代替pooling层 巧妙地利用1*1的卷积核来进行 ","date":"2020-03-12","objectID":"/face03/:3:5","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"3.6 ResNet 3.6.1 概念 2015年，由何凯明团队提出，引入跳连的结构来防止梯度消失的问题，进而可以进一步加大网络深度。 3.6.2 ResNet中的Bootleneck与恒等映射 Bootleneck：跳连结构（Short-Cut）恒等映射，解决梯度消失问题； 3.6.3 ResNet中的BatchNorm 每个卷积之后都会配合一个BatchNorm层 对数据scale和分布来进行约束 简单的正则化，提高网络抗过拟合能力 3.6.4 ResNet的设计特点 核心单元简单堆叠 跳连结构解决网络梯度消失问题 Average Pooling层代替FC层 BN层加快网络训练速度和收敛时的稳定性 加大网络深度，提高模型特征提取能力 3.6.5 ResNet的变种网络 ResNetXt 分组卷积 DenseNet 更多的跳连 Wide-ResNet 加大网络宽度 ResNet In ResNet 网中网 Inception-ResNet Inception结构 ","date":"2020-03-12","objectID":"/face03/:3:6","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"4 轻量型卷积神经网 笔记 更少的参数量 更少的计算量 移动端、嵌入式平台 ","date":"2020-03-12","objectID":"/face03/:4:0","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"4.1 SqueezeNet LCLR-2017，作者分别来自Berkeley和Stanford 提出 Fire Module，由两部分组成：Squeeze 层 + Expand层 SqueezeNet的特点 1*1卷积核减小计算量 不同size的卷积核，类似Inception deep compression技术 ","date":"2020-03-12","objectID":"/face03/:4:1","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"4.2 MobileNet V1/V2 由Google团队提出，并发表于CVPR-2017 Depth-wise Separable Convolution 的卷积方式代替传统卷积方式，以达到减少网络权值参数的目的。 MobileNet 网络设计思想 Depth-wise Convolution Point-wise Convolution MobileNet V2 Inverted residuals（倒置残差） Linear bottlenecks ","date":"2020-03-12","objectID":"/face03/:4:2","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"4.3 ShuffleNet V1/V2 ShuffleNet V1由旷视科技提出的一种轻量型卷积网络 深度卷积来代替标准卷积 分组卷积+通道shuffle ShuffleNet V2旷视科技针对ShuffleNet V1改进的轻量型卷积神经网 ECCV 2018 该模型最大的贡献点在于解释了如何去设计轻量型卷积网络的几个标准和规范 笔记 轻量型卷积神经网设计标准 相同的通道宽度可最小化内存访问成本（MAC） 过度的组卷积会增加MAC 网络碎片化（例如GoogleNet的多路径结构）会降低并行度 元素级运算不可忽视 ","date":"2020-03-12","objectID":"/face03/:4:3","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"4.4 Xception 由Google提出，arXiv的V1版本于2016年10月公开 同样借鉴了深度卷积的思想，但又存在差异，具体如下： Xception先采用1*1卷积，再进行主通道卷积； Xception再1*1卷积后，加入ReLU； ","date":"2020-03-12","objectID":"/face03/:4:4","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"5 多分支卷积神经网络 ","date":"2020-03-12","objectID":"/face03/:5:0","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"5.1 Siamese Net 孪生网络 余弦距离 余弦距离，也称余弦相似度，是用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异大小的度量 余弦距离——拓展Loss Center Loss SphereFace CosFace ArcFace CCL AMSoftmax 度量问题 分类问题 回归问题 度量问题 相似度 排序问题 ","date":"2020-03-12","objectID":"/face03/:5:1","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"5.2 Troplet Net Anchor + Negative + Positive Troplet Net 网络结构 Troplet Net 网络特点 提取Embedding Feature 细粒度的识别任务 正负样本比例失衡——难例挖掘 ","date":"2020-03-12","objectID":"/face03/:5:2","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"5.3 Quadruplet Net 相比Troplet Net 多加入一张负样本 正度样本之间的绝对距离 ","date":"2020-03-12","objectID":"/face03/:5:3","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"5.4 多任务网络 ","date":"2020-03-12","objectID":"/face03/:5:4","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"6 卷积神经网中的Attention机制 笔记 人类大脑在接受和处理外界信号时的一种机制 one-hot分布或者soft的软分布 Soft-Attention或者Hard-Attention Attention实现机制： 保留所有分量均做加权（即soft attention） 在分布中以某种采样策略选取部分分量（即hard attention） 原图、特征图、空间尺度、通道、特征图上的每个元素、不同历史时刻 ResNet + Attention SENet/Channel Attention ","date":"2020-03-12","objectID":"/face03/:6:0","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"7 模型压缩 笔记 学院派VS工程派 学院派注重精度 工程派注重精度与效率的结合 ","date":"2020-03-12","objectID":"/face03/:7:0","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"7.1 模型剪枝 除无意义的权重和激活来减少模型的大小 贡献度排序 去除小贡献度单元 重新fine-tuning 模型剪枝技巧 全连接部分通常会存在大量的参数冗余 对卷积窗口进行剪枝的方式，可以使减少卷积窗口权重，或者直接丢弃掉卷积窗口的某一维度； 丢弃稀疏的卷积窗口，但这并不会使模型运行速度有数量级的提升； 首先训练一个较大的神经网络模型，在逐步剪枝得到的小模型。 ","date":"2020-03-12","objectID":"/face03/:7:1","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"7.2 模型量化/定点化 减少数据在内存中的位数操作，可以采用8位类型来表示32位浮点（定点化）或者直接训练低于8位的模型，比如：2bit模型、4bit模型等 较少内存开销，节省更多的带宽 对于某些定点运算方式，甚至可以消除乘法操作，只剩加法操作，某些二值模型，直接使用位操作 代价通常是位数越低，精度下降越明显 在TensorFlow中，通常采用引入量化层的方式来更改计算图，进而达到量化的目的。 ","date":"2020-03-12","objectID":"/face03/:7:2","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"7.3 知识蒸馏（Knowledge Distillation） 采用一个大的、复杂的网络模型来指导一个小的、精简之后的网络模型进行模型训练和学习 ","date":"2020-03-12","objectID":"/face03/:7:3","tags":["FaceRecognition","CNN"],"title":"卷积神经网基础串讲","uri":"/face03/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 深度学习基础串讲","date":"2020-03-12","objectID":"/face02/","tags":["FaceRecognition","DeepLearning"],"title":"深度学习基础串讲","uri":"/face02/"},{"categories":["FaceRecognition"],"content":"基于TensorFlow的人脸识别智能小程序的设计与实现 深度学习基础串讲 ","date":"2020-03-12","objectID":"/face02/:0:0","tags":["FaceRecognition","DeepLearning"],"title":"深度学习基础串讲","uri":"/face02/"},{"categories":["FaceRecognition"],"content":"1 内容概况（卷积神经网） ","date":"2020-03-12","objectID":"/face02/:1:0","tags":["FaceRecognition","DeepLearning"],"title":"深度学习基础串讲","uri":"/face02/"},{"categories":["FaceRecognition"],"content":"2 深度学习相关概念 ","date":"2020-03-12","objectID":"/face02/:2:0","tags":["FaceRecognition","DeepLearning"],"title":"深度学习基础串讲","uri":"/face02/"},{"categories":["FaceRecognition"],"content":"2.1 深度学习发展历程 ","date":"2020-03-12","objectID":"/face02/:2:1","tags":["FaceRecognition","DeepLearning"],"title":"深度学习基础串讲","uri":"/face02/"},{"categories":["FaceRecognition"],"content":"2.2 人工神经网络 ","date":"2020-03-12","objectID":"/face02/:2:2","tags":["FaceRecognition","DeepLearning"],"title":"深度学习基础串讲","uri":"/face02/"},{"categories":["FaceRecognition"],"content":"2.3 感知器 多层感知器（MLP）也叫人工神经网络（ANN） ","date":"2020-03-12","objectID":"/face02/:2:3","tags":["FaceRecognition","DeepLearning"],"title":"深度学习基础串讲","uri":"/face02/"},{"categories":["FaceRecognition"],"content":"2.4 深度学习 含多隐层的多层感知器就是一种深度学习结构 ","date":"2020-03-12","objectID":"/face02/:2:4","tags":["FaceRecognition","DeepLearning"],"title":"深度学习基础串讲","uri":"/face02/"},{"categories":["FaceRecognition"],"content":"2.5 神经元 -\u003e 感知器 -\u003e 神经网络 -\u003e 深度学习 多层感知器 -\u003e 神经网络 多隐层的多层感知器 -\u003e 深度学习 ","date":"2020-03-12","objectID":"/face02/:2:5","tags":["FaceRecognition","DeepLearning"],"title":"深度学习基础串讲","uri":"/face02/"},{"categories":["FaceRecognition"],"content":"3 深度学习相关理论 ","date":"2020-03-12","objectID":"/face02/:3:0","tags":["FaceRecognition","DeepLearning"],"title":"深度学习基础串讲","uri":"/face02/"},{"categories":["FaceRecognition"],"content":"3.1 深度学习中的核心知识 3.1.1 前向运算（怎么用？） 计算输出值得过程称为前向运算 3.1.2 反向传播（怎么学？） 1. 神经网络（参数模型）训练方法 1986年由Rumelhar和Hinton等人提出 解决神经网络优化问题 计算输出层结果与真实值之间的偏差来进行逐层调节参数 2. 神经网络参数训练是一个不断迭代的过程 3. 参数更新多少？ 参数优化的问题 导数和学习率 3.1.3 梯度下降算法 沿着导数下降的方法，进行参数更新 选择合适的步长/学习率 局部最优解 ","date":"2020-03-12","objectID":"/face02/:3:1","tags":["FaceRecognition","DeepLearning"],"title":"深度学习基础串讲","uri":"/face02/"},{"categories":["FaceRecognition"],"content":"3.2 深度学习发展迅猛的原因 数据：imageNet 算力：GPU+深度学习芯片 算法：分类、检测、分割等 ","date":"2020-03-12","objectID":"/face02/:3:2","tags":["FaceRecognition","DeepLearning"],"title":"深度学习基础串讲","uri":"/face02/"},{"categories":["FaceRecognition"],"content":"4 常见的深度学习模型 卷积神经网（CNN） 循环神经网（RNN） 自动编码机（Autoencoder） Restricted Boltzmann Machines（RBM，受限玻尔兹曼机） 深度信念网络（DBN，Deep Belief Network） ","date":"2020-03-12","objectID":"/face02/:4:0","tags":["FaceRecognition","DeepLearning"],"title":"深度学习基础串讲","uri":"/face02/"},{"categories":["Ubuntu"],"content":"这篇文章展示了如何在Ubuntu16.04系统中安装中文输入法","date":"2020-03-12","objectID":"/ubuntu-fcitx/","tags":["Ubuntu16.04","Fcitx","中文输入法"],"title":"Ubuntu16.04安装中文输入法","uri":"/ubuntu-fcitx/"},{"categories":["Ubuntu"],"content":"这篇文章展示了如何在Ubuntu16.04系统中安装中文输入法. 系统环境 Ubuntu 16.04 ","date":"2020-03-12","objectID":"/ubuntu-fcitx/:0:0","tags":["Ubuntu16.04","Fcitx","中文输入法"],"title":"Ubuntu16.04安装中文输入法","uri":"/ubuntu-fcitx/"},{"categories":["Ubuntu"],"content":"1 安装Fcitx 配置 System Settings -\u003e Language Support -\u003e Install/Remove Languages 选择 Chinese(simplified) -\u003e Apply ","date":"2020-03-12","objectID":"/ubuntu-fcitx/:1:0","tags":["Ubuntu16.04","Fcitx","中文输入法"],"title":"Ubuntu16.04安装中文输入法","uri":"/ubuntu-fcitx/"},{"categories":["Ubuntu"],"content":"2 重启系统 reboot ","date":"2020-03-12","objectID":"/ubuntu-fcitx/:2:0","tags":["Ubuntu16.04","Fcitx","中文输入法"],"title":"Ubuntu16.04安装中文输入法","uri":"/ubuntu-fcitx/"},{"categories":["Ubuntu"],"content":"3 设置输入法为Fcitx 配置 System Settings -\u003e Language Support -\u003e Keaboard input method system 选择 fcitx -\u003e close ","date":"2020-03-12","objectID":"/ubuntu-fcitx/:3:0","tags":["Ubuntu16.04","Fcitx","中文输入法"],"title":"Ubuntu16.04安装中文输入法","uri":"/ubuntu-fcitx/"},{"categories":["Ubuntu"],"content":"4 重启系统 ","date":"2020-03-12","objectID":"/ubuntu-fcitx/:4:0","tags":["Ubuntu16.04","Fcitx","中文输入法"],"title":"Ubuntu16.04安装中文输入法","uri":"/ubuntu-fcitx/"},{"categories":["Ubuntu"],"content":"5 右上角出现企鹅 配置 点击企鹅 -\u003e ConfigureFcitx -\u003e 点击左下角\"+\" -\u003e 取消勾选 Only Show Current Language 点击 Sunpinyin -\u003e OK ","date":"2020-03-12","objectID":"/ubuntu-fcitx/:5:0","tags":["Ubuntu16.04","Fcitx","中文输入法"],"title":"Ubuntu16.04安装中文输入法","uri":"/ubuntu-fcitx/"},{"categories":["Ubuntu"],"content":"6 参考资料 参考资料 https://blog.csdn.net/qq_38329375/article/details/81538443 ","date":"2020-03-12","objectID":"/ubuntu-fcitx/:6:0","tags":["Ubuntu16.04","Fcitx","中文输入法"],"title":"Ubuntu16.04安装中文输入法","uri":"/ubuntu-fcitx/"},{"categories":["Ubuntu"],"content":"这篇文章展示了如何在Ubuntu16.04系统中安装Pycharm","date":"2020-03-12","objectID":"/ubuntu-pycharm/","tags":["Ubuntu16.04","Pycharm"],"title":"Ubuntu16.04安装pycharm","uri":"/ubuntu-pycharm/"},{"categories":["Ubuntu"],"content":"这篇文章展示了如何在Ubuntu16.04系统中安装Pycharm并进行基本配置. 系统环境 Ubuntu 16.04 ","date":"2020-03-12","objectID":"/ubuntu-pycharm/:0:0","tags":["Ubuntu16.04","Pycharm"],"title":"Ubuntu16.04安装pycharm","uri":"/ubuntu-pycharm/"},{"categories":["Ubuntu"],"content":"1 下载 在pycharm官网下载所需版本: https://www.jetbrains.com/pycharm/download/#section=linux 建议下载专业版 将下载得到的安装包移动到Home文件夹下 ","date":"2020-03-12","objectID":"/ubuntu-pycharm/:1:0","tags":["Ubuntu16.04","Pycharm"],"title":"Ubuntu16.04安装pycharm","uri":"/ubuntu-pycharm/"},{"categories":["Ubuntu"],"content":"2 解压 ","date":"2020-03-12","objectID":"/ubuntu-pycharm/:2:0","tags":["Ubuntu16.04","Pycharm"],"title":"Ubuntu16.04安装pycharm","uri":"/ubuntu-pycharm/"},{"categories":["Ubuntu"],"content":"2.1打开终端，输入解压指令 tar -zxvf pycharm-2019.3.3.tar.gz ","date":"2020-03-12","objectID":"/ubuntu-pycharm/:2:1","tags":["Ubuntu16.04","Pycharm"],"title":"Ubuntu16.04安装pycharm","uri":"/ubuntu-pycharm/"},{"categories":["Ubuntu"],"content":"2.2 得到解压后的文件pycharm-2019.3.3 ","date":"2020-03-12","objectID":"/ubuntu-pycharm/:2:2","tags":["Ubuntu16.04","Pycharm"],"title":"Ubuntu16.04安装pycharm","uri":"/ubuntu-pycharm/"},{"categories":["Ubuntu"],"content":"3 启动 ","date":"2020-03-12","objectID":"/ubuntu-pycharm/:3:0","tags":["Ubuntu16.04","Pycharm"],"title":"Ubuntu16.04安装pycharm","uri":"/ubuntu-pycharm/"},{"categories":["Ubuntu"],"content":"3.1 运行pycharm.sh # 进入 pycharm-2019.3.3/bin 目录下 运行pycharm.sh cd pycharm-2019.3.3/bin sh pycharm.sh ","date":"2020-03-12","objectID":"/ubuntu-pycharm/:3:1","tags":["Ubuntu16.04","Pycharm"],"title":"Ubuntu16.04安装pycharm","uri":"/ubuntu-pycharm/"},{"categories":["Ubuntu"],"content":"3.2 进行激活等配置后进入软件 ","date":"2020-03-12","objectID":"/ubuntu-pycharm/:3:2","tags":["Ubuntu16.04","Pycharm"],"title":"Ubuntu16.04安装pycharm","uri":"/ubuntu-pycharm/"},{"categories":["Ubuntu"],"content":"4 配置 ","date":"2020-03-12","objectID":"/ubuntu-pycharm/:4:0","tags":["Ubuntu16.04","Pycharm"],"title":"Ubuntu16.04安装pycharm","uri":"/ubuntu-pycharm/"},{"categories":["Ubuntu"],"content":"4.1 调出pycharm顶部菜单栏 配置 按Ctrl + Shift + A打开Find Action对话框，键入Experimental features，然后按Enter键。 取消linux.native.menu选项旁边的复选框，应用更改并关闭对话框。 重启PyCharm ","date":"2020-03-12","objectID":"/ubuntu-pycharm/:4:1","tags":["Ubuntu16.04","Pycharm"],"title":"Ubuntu16.04安装pycharm","uri":"/ubuntu-pycharm/"},{"categories":["Ubuntu"],"content":"4.2 将pycharm固定到系统桌面菜单栏 配置 顶部菜单栏-\u003etools-\u003eCreate Desktop Entry… ","date":"2020-03-12","objectID":"/ubuntu-pycharm/:4:2","tags":["Ubuntu16.04","Pycharm"],"title":"Ubuntu16.04安装pycharm","uri":"/ubuntu-pycharm/"},{"categories":["Ubuntu"],"content":"5 完成 基本配置结束，下次直接双击桌面图标即可启动！ ","date":"2020-03-12","objectID":"/ubuntu-pycharm/:5:0","tags":["Ubuntu16.04","Pycharm"],"title":"Ubuntu16.04安装pycharm","uri":"/ubuntu-pycharm/"},{"categories":["Ubuntu"],"content":"6 参考资料 参考资料 https://blog.csdn.net/shuiyixin/article/details/89530415 https://blog.csdn.net/loco1223/article/details/91127366 https://blog.csdn.net/Boogyman/article/details/100527532 https://blog.csdn.net/qq_42517220/article/details/86756538 ","date":"2020-03-12","objectID":"/ubuntu-pycharm/:6:0","tags":["Ubuntu16.04","Pycharm"],"title":"Ubuntu16.04安装pycharm","uri":"/ubuntu-pycharm/"},{"categories":["Ubuntu"],"content":"这篇文章展示了如何在Ubuntu16.04系统中安装Python3.5","date":"2020-03-12","objectID":"/ubuntu-python/","tags":["Ubuntu16.04","Python3.5"],"title":"Ubuntu16.04安装Python3.5","uri":"/ubuntu-python/"},{"categories":["Ubuntu"],"content":"这篇文章展示了如何在Ubuntu16.04系统中安装Python3.5并将python3.5设置为默认版本. 系统环境 Ubuntu 16.04 原始python版本 python2.7 安装python版本 python3.5 ","date":"2020-03-12","objectID":"/ubuntu-python/:0:0","tags":["Ubuntu16.04","Python3.5"],"title":"Ubuntu16.04安装Python3.5","uri":"/ubuntu-python/"},{"categories":["Ubuntu"],"content":"1 ubuntu安装Python3.5 sudo add-apt-repository ppa:fkrull/deadsnakes sudo apt-get update #检查系统更新 sudo apt-get install python3.5 python --version #查看当前版本号 sudo apt-get install python3-pip #装pip3 ","date":"2020-03-12","objectID":"/ubuntu-python/:1:0","tags":["Ubuntu16.04","Python3.5"],"title":"Ubuntu16.04安装Python3.5","uri":"/ubuntu-python/"},{"categories":["Ubuntu"],"content":"2 设置python3为默认版本 ","date":"2020-03-12","objectID":"/ubuntu-python/:2:0","tags":["Ubuntu16.04","Python3.5"],"title":"Ubuntu16.04安装Python3.5","uri":"/ubuntu-python/"},{"categories":["Ubuntu"],"content":"2.1 执行命令 sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100 sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 ","date":"2020-03-12","objectID":"/ubuntu-python/:2:1","tags":["Ubuntu16.04","Python3.5"],"title":"Ubuntu16.04安装Python3.5","uri":"/ubuntu-python/"},{"categories":["Ubuntu"],"content":"2.2 如果要切换回 python2 sudo update-alternatives --config python #按照提示输入选择数字回车即可 ","date":"2020-03-12","objectID":"/ubuntu-python/:2:2","tags":["Ubuntu16.04","Python3.5"],"title":"Ubuntu16.04安装Python3.5","uri":"/ubuntu-python/"},{"categories":["Ubuntu"],"content":"3 参考资料 参考资料 https://blog.csdn.net/qq_36801146/article/details/89380491 ","date":"2020-03-12","objectID":"/ubuntu-python/:3:0","tags":["Ubuntu16.04","Python3.5"],"title":"Ubuntu16.04安装Python3.5","uri":"/ubuntu-python/"},{"categories":["Ubuntu"],"content":"这篇文章展示了如何解决ubuntu16.04安装桌面后只能访客登录的方法","date":"2020-03-12","objectID":"/ubuntu-only-guest/","tags":["Ubuntu16.04"],"title":"Ubuntu16.04安装桌面后只能访客登录","uri":"/ubuntu-only-guest/"},{"categories":["Ubuntu"],"content":"这篇文章展示了如何解决ubuntu16.04安装桌面后只能访客登录的方法. 系统环境 Ubuntu 16.04 Aliyun Workbench Aliyun VNC 警告 图形化桌面安装好后，远程连接进去，发现只能使用guest帐号，不能选择其他用户 登录进去有警告信息！ ","date":"2020-03-12","objectID":"/ubuntu-only-guest/:0:0","tags":["Ubuntu16.04"],"title":"Ubuntu16.04安装桌面后只能访客登录","uri":"/ubuntu-only-guest/"},{"categories":["Ubuntu"],"content":"1 连接Terminal 通过云服务器管理控制台的Workbench连接Terminal ","date":"2020-03-12","objectID":"/ubuntu-only-guest/:1:0","tags":["Ubuntu16.04"],"title":"Ubuntu16.04安装桌面后只能访客登录","uri":"/ubuntu-only-guest/"},{"categories":["Ubuntu"],"content":"2 修改root权限 修改/usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf文件 vim /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf ","date":"2020-03-12","objectID":"/ubuntu-only-guest/:2:0","tags":["Ubuntu16.04"],"title":"Ubuntu16.04安装桌面后只能访客登录","uri":"/ubuntu-only-guest/"},{"categories":["Ubuntu"],"content":"修改前 [Seat:*] user-session=ubuntu ","date":"2020-03-12","objectID":"/ubuntu-only-guest/:2:1","tags":["Ubuntu16.04"],"title":"Ubuntu16.04安装桌面后只能访客登录","uri":"/ubuntu-only-guest/"},{"categories":["Ubuntu"],"content":"修改后 [Seat:*] user-session=ubuntu greeter-show-manual-login=true allow-guest=false ","date":"2020-03-12","objectID":"/ubuntu-only-guest/:2:2","tags":["Ubuntu16.04"],"title":"Ubuntu16.04安装桌面后只能访客登录","uri":"/ubuntu-only-guest/"},{"categories":["Ubuntu"],"content":"3 重启服务器 reboot ","date":"2020-03-12","objectID":"/ubuntu-only-guest/:3:0","tags":["Ubuntu16.04"],"title":"Ubuntu16.04安装桌面后只能访客登录","uri":"/ubuntu-only-guest/"},{"categories":["Ubuntu"],"content":"4 关闭警告信息 重启之后就可以用root用户登录，登录后还是有警告 ","date":"2020-03-12","objectID":"/ubuntu-only-guest/:4:0","tags":["Ubuntu16.04"],"title":"Ubuntu16.04安装桌面后只能访客登录","uri":"/ubuntu-only-guest/"},{"categories":["Ubuntu"],"content":"修改/root/.profile文件 修改前 # ~/.profile: executed by Bourne-compatible login shells. if [ \"$BASH\" ]; then if [ -f ~/.bashrc ]; then . ~/.bashrc fi fi mesg n || true 修改后 # ~/.profile: executed by Bourne-compatible login shells. if [ \"$BASH\" ]; then if [ -f ~/.bashrc ]; then . ~/.bashrc fi fi tty -s \u0026\u0026 mesg n || true ","date":"2020-03-12","objectID":"/ubuntu-only-guest/:4:1","tags":["Ubuntu16.04"],"title":"Ubuntu16.04安装桌面后只能访客登录","uri":"/ubuntu-only-guest/"},{"categories":["Ubuntu"],"content":"5 重启服务器 reboot ","date":"2020-03-12","objectID":"/ubuntu-only-guest/:5:0","tags":["Ubuntu16.04"],"title":"Ubuntu16.04安装桌面后只能访客登录","uri":"/ubuntu-only-guest/"},{"categories":["Ubuntu"],"content":"6 完成 重启之后，只有root用户，登录后也没有警告信息 ","date":"2020-03-12","objectID":"/ubuntu-only-guest/:6:0","tags":["Ubuntu16.04"],"title":"Ubuntu16.04安装桌面后只能访客登录","uri":"/ubuntu-only-guest/"},{"categories":["Ubuntu"],"content":"7 参考资料 参考资料 https://blog.csdn.net/Never_Give_up_z/article/details/83190285 ","date":"2020-03-12","objectID":"/ubuntu-only-guest/:7:0","tags":["Ubuntu16.04"],"title":"Ubuntu16.04安装桌面后只能访客登录","uri":"/ubuntu-only-guest/"},{"categories":["Ubuntu"],"content":"这篇文章展示了通过VNCViewer远程控制阿里云ECS服务器的安装配置操作","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"这篇文章展示了通过VNCViewer远程控制阿里云ECS服务器的安装配置操作. 系统环境 桌面端版本：Windows 10 远程端版本：Ubuntu 16.04 VNCViewer版本：6.20.113 ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:0:0","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"1 安装配置好服务器 ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:1:0","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"2 添加安全组 为阿里云ECS添加安全组 安全组 协议类型：自定义TCP 端口范围：5900/59001 授权对象：0.0.0.0/0 ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:2:0","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"3 连接Terminal 通过自带的Workbench连接Terminal ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:3:0","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"4 安装VNCServer ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:4:0","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"4.1 更新系统软件 sudo apt-get update ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:4:1","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"4.2 安装vnc4server sudo apt-get install vnc4server # 中间会有确认安装的提示，输入 Y 确认安装 ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:4:2","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"4.3 启动vncserver vncserver # 第一次启动会提示设置密码（19981112） ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:4:3","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"5 安装Ubuntu gnome界面 ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:5:0","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"5.1 安装 x-windows 的基础 sudo apt-get install x-window-system-core ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:5:1","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"5.2 安装登录管理器 sudo apt-get install gdm # 选择lightdm ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:5:2","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"5.3 安装Ubuntu界面程序 sudo apt-get install ubuntu-desktop ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:5:3","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"5.4 安装Ubuntu界面其他依赖 sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:5:4","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"6 修改 ~/.vnc/xstartup\\ vim ~/.vnc/xstartup #用vim进行编辑 ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:6:0","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"修改前 #!/bin/sh # Uncomment the following two lines for normal desktop: # unset SESSION_MANAGER # exec /etc/X11/xinit/xinitrc [ -x /etc/vnc/xstartup ] \u0026\u0026 exec /etc/vnc/xstartup [ -r $HOME/.Xresources ] \u0026\u0026 xrdb $HOME/.Xresources xsetroot -solid grey vncconfig -iconic \u0026 #x-terminal-emulator -geometry 80x24+10+10 -ls -title \"$VNCDESKTOP Desktop\" \u0026 x-window-manager \u0026 ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:6:1","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"修改后 #!/bin/sh # Uncomment the following two lines for normal desktop: export XKL_XMODMAP_DISABLE=1 unset SESSION_MANAGER unset DBUS_SESSION_BUS_ADDRESS # exec /etc/X11/xinit/xinitrc [ -x /etc/vnc/xstartup ] \u0026\u0026 exec /etc/vnc/xstartup [ -r $HOME/.Xresources ] \u0026\u0026 xrdb $HOME/.Xresources xsetroot -solid grey vncconfig -iconic \u0026 #x-terminal-emulator -geometry 80x24+10+10 -ls -title \"$VNCDESKTOP Desktop\" \u0026 # x-window-manager \u0026 gnome-session \u0026 gnome-panel \u0026 gnome-settings-daemon \u0026 metacity \u0026 nautilus \u0026 gnome-terminal \u0026 ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:6:2","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"7 启动vncserver 技巧 自动生成新桌面 第一次生成:1 第二次生成:2 表示不同的桌面 vncviewer ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:7:0","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"8 关闭生成的桌面 vncserver -kill :1 #:1表示桌面号 ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:8:0","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"9 使用vnc工具连接 ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:9:0","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"9.1 在官网下载VNCViewer ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:9:1","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"9.2 创建新的连接 创建新链接 File -\u003e New connection 在VNC Server中输入IP:桌面号39.105.95.4:1 ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:9:2","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Ubuntu"],"content":"10 参考资料 参考资料 https://www.jianshu.com/p/a4c99712a2b4 https://blog.csdn.net/u012435142/article/details/82261586 ","date":"2020-03-12","objectID":"/vncviever-aliyun-ecs/:10:0","tags":["VNCViewer","Ubuntu16.04","aliyun"],"title":"VNCViewer远程阿里云ECS服务器","uri":"/vncviever-aliyun-ecs/"},{"categories":["Github"],"content":"这篇文章介绍了如何在windows系统上基于github.io利用hugo搭建自己的个人博客。","date":"2020-03-11","objectID":"/github-build/","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":["Github"],"content":"这篇文章介绍了如何在windows系统上基于github.io利用hugo搭建自己的个人博客。 系统环境 Windows 10 hugo_extended_0.68.3_Windows-64bit ","date":"2020-03-11","objectID":"/github-build/:0:0","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":["Github"],"content":"1 git 下载地址：https://git-scm.com/downloads 按步骤安装即可 ","date":"2020-03-11","objectID":"/github-build/:1:0","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":["Github"],"content":"2 hugo ","date":"2020-03-11","objectID":"/github-build/:2:0","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":["Github"],"content":"2.1 下载 下载地址：https://github.com/gohugoio/hugo/releases 由于使用主题的限制，我使用的版本是:hugo_extended_0.68.3_Windows-64bit ","date":"2020-03-11","objectID":"/github-build/:2:1","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":["Github"],"content":"2.2 配置 创建文件夹 D:\\hugo\\bin 将解压后的hugo.exe放到新建的 D:\\hugo\\bin 目录下 配置系统环境变量。 将 D:\\hugo\\bin 加到 path 中 检查配置是否成功 进入cmd $ hugo version 显示下面的信息即表示安装成功 Hugo Static Site Generator v0.67.0-7F1DA3EF windows/386 BuildDate: 2020-03-09T20:37:49Z ","date":"2020-03-11","objectID":"/github-build/:2:2","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":["Github"],"content":"2.3 生成站点 进入D:\\hugo\\下，单机鼠标右键选择 Git Bash Here $ hugo new site 文件名称（如 blog） 执行后，在hugo目录下会生成一个blog站点文件夹，目录结构如下： ├── archetypes ├── content ├── data ├── layouts ├── static ├── themes ├── config.toml 笔记 archetypes：存放default.md，头文件格式，每次新建文章默认显示的头部信息在此修改 content：存放博客文章，markdown格式文件 data：存放自定义或者导入的模板 layouts：存放网站的数据模板 static：存放图片、css、js等静态资源 themes：存放主题文件，每个主题都是一个独立的文件夹 config.toml：网站配置文件 ","date":"2020-03-11","objectID":"/github-build/:2:3","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":["Github"],"content":"2.4 创建文章 进入站点根目录即D:\\hugo\\blog下，执行命令 $ hugo new post/test.md 执行后，会自动在content/post下生成test.md文件，打开可编辑内容 文件头部的draft要改为false，这样部署后才能看到文章。 当前网站是没有任何内容的，需要下载个主题。 ","date":"2020-03-11","objectID":"/github-build/:2:4","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":["Github"],"content":"2.5 下载主题 主题下载地址：https://themes.gohugo.io 将下载好的主题解压后放到themes文件夹下 根据主题的说明进行相关配置（每个主题不一样，不做详细说明） 主题需要在config.toml中指定，如：theme = “LoveIt” 进入站点根目录即D:\\hugo\\blog下，执行命令启动服务 $ hugo server 执行结果： Building sites … | EN | ZH-CN -------------------+-----+-------- Pages | 116 | 116 Paginator pages | 4 | 4 Non-page files | 0 | 0 Static files | 217 | 217 Processed images | 0 | 0 Aliases | 35 | 34 Sitemaps | 2 | 1 Cleaned | 0 | 0 Built in 455 ms Watching for changes in D:\\hugo\\blog\\{archetypes,content,data,layouts,themes} Watching for config changes in D:\\hugo\\blog\\config.toml Environment: \"development\" Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 访问http://localhost:1313/或http://127.0.0.1:1313/查看效果 ","date":"2020-03-11","objectID":"/github-build/:2:5","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":["Github"],"content":"3 部署到github pages ","date":"2020-03-11","objectID":"/github-build/:3:0","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":["Github"],"content":"3.1 创建github.io仓库 登录github，点击左上角的New 创建 github.io 仓库，图中的 yourname 要与成自己的github用户名一致，即上图中 Owner 显示的用户名。 最后点击 Creat repository 完成创建 ","date":"2020-03-11","objectID":"/github-build/:3:1","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":["Github"],"content":"3.2 编译 将站点根目录config.toml中 baseURL 换成自己建立的仓库，如 baseURL = \"https://yourname.github.io/\" 进入站点根目录即D:\\hugo\\blog下，执行编译命令： $ hugo 执行后，站点根目录下会生成一个 public 文件夹，该文件下的内容即 Hugo 生成的整个静态网站。每次更新内容后，将 pubilc 目录里所有文件 push 到 GitHub 即可。 ","date":"2020-03-11","objectID":"/github-build/:3:2","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":["Github"],"content":"3.3 部署 进入D:\\hugo\\blog\\public 首次使用执行以下命令： $ git init $ git remote add origin https://github.com/yourname/yourname.github.io.git 将本地目录链接到远程服务器的代码仓库 $ git add -A $ git commit -m \"first commit\" $ git push -u origin master 等待上传完成，就可以去 yournamne.github.io 看自己的博客了 我的博客地址：https://ieblyang.github.io/，欢迎交流学习！ ","date":"2020-03-11","objectID":"/github-build/:3:3","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":["Github"],"content":"3.4 更新 以后每次站点根目录下执行hugo命令后，再到public下执行推送命令： $ git add -A $ git commit -m \"修改内容\" $ git push -u origin master (会有弹窗提示，需要登录自己的github账号) ","date":"2020-03-11","objectID":"/github-build/:3:4","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":["Github"],"content":"4 总结 整体来说并不复杂，最容易出问题的地方在“主题配置”部分，一定要按照主题作者的说明文档一步一步来，不是下载好放到themes文件夹下就算完成了，我使用的主题是 LoveIt ，推荐你使用！ ","date":"2020-03-11","objectID":"/github-build/:4:0","tags":["Github","Hugo","Windows"],"title":"Windows+Hugo+Github搭建个人博客","uri":"/github-build/"},{"categories":null,"content":"个人简介 昵称：菠萝 学校：郑州大学 专业：软件工程 编程语言：Java、Python、C语言 专业方向：Java Web、深度学习 特长：视频制作、摄影、After Effects、Premiere Pro、Photoshop 原博客：https://www.cnblogs.com/ieybl/ … 博客详情 技术支持： 技术支持： 使用主题：LoveIt 联系方式 QQ：1030007324 Mail：bolon.young@gmail.com TEL:15686961205 Bilibili：我家住这颗菠萝 ","date":"2020-03-11","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"}]